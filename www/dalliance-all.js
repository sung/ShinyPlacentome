(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// bam.js: indexed binary alignments
//

"use strict";

if (typeof require !== 'undefined') {
    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;

    var bin = require('./bin');
    var readInt = bin.readInt;
    var readShort = bin.readShort;
    var readByte = bin.readByte;
    var readInt64 = bin.readInt64;
    var readFloat = bin.readFloat;

    var lh3utils = require('./lh3utils');
    var readVob = lh3utils.readVob;
    var unbgzf = lh3utils.unbgzf;
    var reg2bins = lh3utils.reg2bins;
    var Chunk = lh3utils.Chunk;
}

var BAM_MAGIC = 0x14d4142;
var BAI_MAGIC = 0x1494142;

var BamFlags = {
    MULTIPLE_SEGMENTS: 0x1,
    ALL_SEGMENTS_ALIGN: 0x2,
    SEGMENT_UNMAPPED: 0x4,
    NEXT_SEGMENT_UNMAPPED: 0x8,
    REVERSE_COMPLEMENT: 0x10,
    NEXT_REVERSE_COMPLEMENT: 0x20,
    FIRST_SEGMENT: 0x40,
    LAST_SEGMENT: 0x80,
    SECONDARY_ALIGNMENT: 0x100,
    QC_FAIL: 0x200,
    DUPLICATE: 0x400,
    SUPPLEMENTARY: 0x800
};

function BamFile() {}

// Calculate the length (in bytes) of the BAI ref starting at offset.
// Returns {nbin, length, minBlockIndex}
function _getBaiRefLength(uncba, offset) {
    var p = offset;
    var nbin = readInt(uncba, p);p += 4;
    for (var b = 0; b < nbin; ++b) {
        var bin = readInt(uncba, p);
        var nchnk = readInt(uncba, p + 4);
        p += 8 + nchnk * 16;
    }
    var nintv = readInt(uncba, p);p += 4;

    var minBlockIndex = 1000000000;
    var q = p;
    for (var i = 0; i < nintv; ++i) {
        var v = readVob(uncba, q);q += 8;
        if (v) {
            var bi = v.block;
            if (v.offset > 0) bi += 65536;

            if (bi < minBlockIndex) minBlockIndex = bi;
            break;
        }
    }
    p += nintv * 8;

    return {
        minBlockIndex: minBlockIndex,
        nbin: nbin,
        length: p - offset
    };
}

function makeBam(data, bai, indexChunks, callback, attempted) {
    // Do an initial probe on the BAM file to catch any mixed-content errors.
    data.slice(0, 10).fetch(function (header) {
        if (header) {
            return makeBam2(data, bai, indexChunks, callback, attempted);
        } else {
            return callback(null, "Couldn't access BAM.");
        }
    }, { timeout: 5000 });
}

function makeBam2(data, bai, indexChunks, callback, attempted) {
    var bam = new BamFile();
    bam.data = data;
    bam.bai = bai;
    bam.indexChunks = indexChunks;

    var minBlockIndex = bam.indexChunks ? bam.indexChunks.minBlockIndex : 1000000000;

    // Fills out bam.chrToIndex and bam.indexToChr based on the first few bytes of the BAM.
    function parseBamHeader(r) {
        if (!r) {
            return callback(null, "Couldn't access BAM");
        }

        var unc = unbgzf(r, r.byteLength);
        var uncba = new Uint8Array(unc);

        var magic = readInt(uncba, 0);
        if (magic != BAM_MAGIC) {
            return callback(null, "Not a BAM file, magic=0x" + magic.toString(16));
        }
        var headLen = readInt(uncba, 4);
        var header = '';
        for (var i = 0; i < headLen; ++i) {
            header += String.fromCharCode(uncba[i + 8]);
        }

        var nRef = readInt(uncba, headLen + 8);
        var p = headLen + 12;

        bam.chrToIndex = {};
        bam.indexToChr = [];
        for (var i = 0; i < nRef; ++i) {
            var lName = readInt(uncba, p);
            var name = '';
            for (var j = 0; j < lName - 1; ++j) {
                name += String.fromCharCode(uncba[p + 4 + j]);
            }
            var lRef = readInt(uncba, p + lName + 4);
            bam.chrToIndex[name] = i;
            if (name.indexOf('chr') == 0) {
                bam.chrToIndex[name.substring(3)] = i;
            } else {
                bam.chrToIndex['chr' + name] = i;
            }
            bam.indexToChr.push(name);

            p = p + 8 + lName;
        }

        if (bam.indices) {
            return callback(bam);
        }
    }

    function parseBai(header) {
        if (!header) {
            return "Couldn't access BAI";
        }

        var uncba = new Uint8Array(header);
        var baiMagic = readInt(uncba, 0);
        if (baiMagic != BAI_MAGIC) {
            return callback(null, 'Not a BAI file, magic=0x' + baiMagic.toString(16));
        }

        var nref = readInt(uncba, 4);

        bam.indices = [];

        var p = 8;
        for (var ref = 0; ref < nref; ++ref) {
            var blockStart = p;
            var o = _getBaiRefLength(uncba, blockStart);
            p += o.length;

            minBlockIndex = Math.min(o.minBlockIndex, minBlockIndex);

            var nbin = o.nbin;

            if (nbin > 0) {
                bam.indices[ref] = new Uint8Array(header, blockStart, p - blockStart);
            }
        }

        return true;
    }

    if (!bam.indexChunks) {
        bam.bai.fetch(function (header) {
            // Do we really need to fetch the whole thing? :-(
            var result = parseBai(header);
            if (result !== true) {
                if (bam.bai.url && typeof attempted === "undefined") {
                    // Already attempted x.bam.bai not there so now trying x.bai
                    bam.bai.url = bam.data.url.replace(new RegExp('.bam$'), '.bai');

                    // True lets us know we are making a second attempt
                    makeBam2(data, bam.bai, indexChunks, callback, true);
                } else {
                    // We've attempted x.bam.bai & x.bai and nothing worked
                    callback(null, result);
                }
            } else {
                bam.data.slice(0, minBlockIndex).fetch(parseBamHeader);
            }
        }); // Timeout on first request to catch Chrome mixed-content error.
    } else {
        var chunks = bam.indexChunks.chunks;
        bam.indices = [];
        for (var i = 0; i < chunks.length; i++) {
            bam.indices[i] = null; // To be filled out lazily as needed
        }
        bam.data.slice(0, minBlockIndex).fetch(parseBamHeader);
    }
}

BamFile.prototype.blocksForRange = function (refId, min, max) {
    var index = this.indices[refId];
    if (!index) {
        return [];
    }

    var intBinsL = reg2bins(min, max);
    var intBins = [];
    for (var i = 0; i < intBinsL.length; ++i) {
        intBins[intBinsL[i]] = true;
    }
    var leafChunks = [],
        otherChunks = [];

    var nbin = readInt(index, 0);
    var p = 4;
    for (var b = 0; b < nbin; ++b) {
        var bin = readInt(index, p);
        var nchnk = readInt(index, p + 4);
        //        dlog('bin=' + bin + '; nchnk=' + nchnk);
        p += 8;
        if (intBins[bin]) {
            for (var c = 0; c < nchnk; ++c) {
                var cs = readVob(index, p);
                var ce = readVob(index, p + 8);
                (bin < 4681 ? otherChunks : leafChunks).push(new Chunk(cs, ce));
                p += 16;
            }
        } else {
            p += nchnk * 16;
        }
    }
    // console.log('leafChunks = ' + JSON.stringify(leafChunks));
    // console.log('otherChunks = ' + JSON.stringify(otherChunks));

    var nintv = readInt(index, p);
    // console.log('nintv=' + nintv);
    var lowest = null;
    var minLin = Math.min(min >> 14, nintv - 1),
        maxLin = Math.min(max >> 14, nintv - 1);
    for (var i = minLin; i <= maxLin; ++i) {
        var lb = readVob(index, p + 4 + i * 8);
        if (!lb) {
            continue;
        }
        if (!lowest || lb.block < lowest.block || lb.block == lowest.block && lb.offset < lowest.offset) {
            lowest = lb;
        }
    }
    // console.log('Lowest LB = ' + lowest);

    var prunedOtherChunks = [];
    if (lowest != null) {
        for (var i = 0; i < otherChunks.length; ++i) {
            var chnk = otherChunks[i];
            if (chnk.maxv.block > lowest.block || chnk.maxv.block == lowest.block && chnk.maxv.offset >= lowest.offset) {
                prunedOtherChunks.push(chnk);
            }
        }
    }
    // console.log('prunedOtherChunks = ' + JSON.stringify(prunedOtherChunks));
    otherChunks = prunedOtherChunks;

    var intChunks = [];
    for (var i = 0; i < otherChunks.length; ++i) {
        intChunks.push(otherChunks[i]);
    }
    for (var i = 0; i < leafChunks.length; ++i) {
        intChunks.push(leafChunks[i]);
    }

    intChunks.sort(function (c0, c1) {
        var dif = c0.minv.block - c1.minv.block;
        if (dif != 0) {
            return dif;
        } else {
            return c0.minv.offset - c1.minv.offset;
        }
    });
    var mergedChunks = [];
    if (intChunks.length > 0) {
        var cur = intChunks[0];
        for (var i = 1; i < intChunks.length; ++i) {
            var nc = intChunks[i];
            if (nc.minv.block == cur.maxv.block /* && nc.minv.offset == cur.maxv.offset */) {
                    // no point splitting mid-block
                    cur = new Chunk(cur.minv, nc.maxv);
                } else {
                mergedChunks.push(cur);
                cur = nc;
            }
        }
        mergedChunks.push(cur);
    }
    // console.log('mergedChunks = ' + JSON.stringify(mergedChunks));

    return mergedChunks;
};

BamFile.prototype.fetch = function (chr, min, max, callback, opts) {
    var thisB = this;
    opts = opts || {};

    var chrId = this.chrToIndex[chr];
    var chunks;
    if (chrId === undefined) {
        chunks = [];
    } else {
        // Fetch this portion of the BAI if it hasn't been loaded yet.
        if (this.indices[chrId] === null && this.indexChunks.chunks[chrId]) {
            var start_stop = this.indexChunks.chunks[chrId];
            return this.bai.slice(start_stop[0], start_stop[1]).fetch(function (data) {
                var buffer = new Uint8Array(data);
                this.indices[chrId] = buffer;
                return this.fetch(chr, min, max, callback, opts);
            }.bind(this));
        }

        chunks = this.blocksForRange(chrId, min, max);
        if (!chunks) {
            callback(null, 'Error in index fetch');
        }
    }

    var records = [];
    var index = 0;
    var data;

    function tramp() {
        if (index >= chunks.length) {
            return callback(records);
        } else if (!data) {
            var c = chunks[index];
            var fetchMin = c.minv.block;
            var fetchMax = c.maxv.block + (1 << 16); // *sigh*
            // console.log('fetching ' + fetchMin + ':' + fetchMax);
            thisB.data.slice(fetchMin, fetchMax - fetchMin).fetch(function (r) {
                data = unbgzf(r, c.maxv.block - c.minv.block + 1);
                return tramp();
            });
        } else {
            var ba = new Uint8Array(data);
            var finished = thisB.readBamRecords(ba, chunks[index].minv.offset, records, min, max, chrId, opts);
            data = null;
            ++index;
            if (finished) return callback(records);else return tramp();
        }
    }
    tramp();
};

var SEQRET_DECODER = ['=', 'A', 'C', 'x', 'G', 'x', 'x', 'x', 'T', 'x', 'x', 'x', 'x', 'x', 'x', 'N'];
var CIGAR_DECODER = ['M', 'I', 'D', 'N', 'S', 'H', 'P', '=', 'X', '?', '?', '?', '?', '?', '?', '?'];

function BamRecord() {}

BamFile.prototype.readBamRecords = function (ba, offset, sink, min, max, chrId, opts) {
    while (true) {
        var blockSize = readInt(ba, offset);
        var blockEnd = offset + blockSize + 4;
        if (blockEnd > ba.length) {
            return false;
        }

        var record = new BamRecord();

        var refID = readInt(ba, offset + 4);
        var pos = readInt(ba, offset + 8);

        var bmn = readInt(ba, offset + 12);
        var bin = (bmn & 0xffff0000) >> 16;
        var mq = (bmn & 0xff00) >> 8;
        var nl = bmn & 0xff;

        var flag_nc = readInt(ba, offset + 16);
        var flag = (flag_nc & 0xffff0000) >> 16;
        var nc = flag_nc & 0xffff;

        var lseq = readInt(ba, offset + 20);

        var nextRef = readInt(ba, offset + 24);
        var nextPos = readInt(ba, offset + 28);

        var tlen = readInt(ba, offset + 32);

        record.segment = this.indexToChr[refID];
        record.flag = flag;
        record.pos = pos;
        record.mq = mq;
        if (opts.light) record.seqLength = lseq;

        if (!opts.light || opts.includeName) {
            var readName = '';
            for (var j = 0; j < nl - 1; ++j) {
                readName += String.fromCharCode(ba[offset + 36 + j]);
            }
            record.readName = readName;
        }

        if (!opts.light) {
            if (nextRef >= 0) {
                record.nextSegment = this.indexToChr[nextRef];
                record.nextPos = nextPos;
            }

            var p = offset + 36 + nl;

            var cigar = '';
            for (var c = 0; c < nc; ++c) {
                var cigop = readInt(ba, p);
                cigar = cigar + (cigop >> 4) + CIGAR_DECODER[cigop & 0xf];
                p += 4;
            }
            record.cigar = cigar;

            var seq = '';
            var seqBytes = lseq + 1 >> 1;
            for (var j = 0; j < seqBytes; ++j) {
                var sb = ba[p + j];
                seq += SEQRET_DECODER[(sb & 0xf0) >> 4];
                if (seq.length < lseq) seq += SEQRET_DECODER[sb & 0x0f];
            }
            p += seqBytes;
            record.seq = seq;

            var qseq = '';
            for (var j = 0; j < lseq; ++j) {
                qseq += String.fromCharCode(ba[p + j] + 33);
            }
            p += lseq;
            record.quals = qseq;

            while (p < blockEnd) {
                var tag = String.fromCharCode(ba[p], ba[p + 1]);
                var type = String.fromCharCode(ba[p + 2]);
                var value;

                if (type == 'A') {
                    value = String.fromCharCode(ba[p + 3]);
                    p += 4;
                } else if (type == 'i' || type == 'I') {
                    value = readInt(ba, p + 3);
                    p += 7;
                } else if (type == 'c' || type == 'C') {
                    value = ba[p + 3];
                    p += 4;
                } else if (type == 's' || type == 'S') {
                    value = readShort(ba, p + 3);
                    p += 5;
                } else if (type == 'f') {
                    value = readFloat(ba, p + 3);
                    p += 7;
                } else if (type == 'Z' || type == 'H') {
                    p += 3;
                    value = '';
                    for (;;) {
                        var cc = ba[p++];
                        if (cc == 0) {
                            break;
                        } else {
                            value += String.fromCharCode(cc);
                        }
                    }
                } else if (type == 'B') {
                    var atype = String.fromCharCode(ba[p + 3]);
                    var alen = readInt(ba, p + 4);
                    var elen;
                    var reader;
                    if (atype == 'i' || atype == 'I' || atype == 'f') {
                        elen = 4;
                        if (atype == 'f') reader = readFloat;else reader = readInt;
                    } else if (atype == 's' || atype == 'S') {
                        elen = 2;
                        reader = readShort;
                    } else if (atype == 'c' || atype == 'C') {
                        elen = 1;
                        reader = readByte;
                    } else {
                        throw 'Unknown array type ' + atype;
                    }

                    p += 8;
                    value = [];
                    for (var i = 0; i < alen; ++i) {
                        value.push(reader(ba, p));
                        p += elen;
                    }
                } else {
                    throw 'Unknown type ' + type;
                }
                record[tag] = value;
            }
        }

        if (!min || record.pos <= max && record.pos + lseq >= min) {
            if (chrId === undefined || refID == chrId) {
                sink.push(record);
            }
        }
        if (record.pos > max) {
            return true;
        }
        offset = blockEnd;
    }

    // Exits via top of loop.
};

if (typeof module !== 'undefined') {
    module.exports = {
        makeBam: makeBam,
        BAM_MAGIC: BAM_MAGIC,
        BAI_MAGIC: BAI_MAGIC,
        BamFlags: BamFlags
    };
}

},{"./bin":4,"./lh3utils":26,"./spans":40}],2:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// bedwig.js
//

"use strict";

if (typeof require !== 'undefined') {
    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;

    var sa = require('./sourceadapters');
    var dalliance_registerParserFactory = sa.registerParserFactory;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;

    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;
}

function BedWigParser(type) {
    this.type = type;
}

BedWigParser.prototype.createSession = function (sink) {
    if (this.type == 'wig') return new WigParseSession(this, sink);else return new BedParseSession(this, sink);
};

var __KV_REGEXP = /([^=]+)=(.+)/;
var __SPACE_REGEXP = /\s+/;
var BED_COLOR_REGEXP = new RegExp("^[0-9]+,[0-9]+,[0-9]+");

function BedParseSession(parser, sink) {
    this.parser = parser;
    this.sink = sink;
}

BedParseSession.prototype.parse = function (line) {
    var toks = line.split(__SPACE_REGEXP);
    if (toks.length < 3) return;

    var start = parseInt(toks[1]) + 1;
    var end = parseInt(toks[2]);

    var f = { segment: toks[0],
        min: start,
        max: end };

    if (toks.length > 3 && toks[3] !== '.') {
        f.label = toks[3];
    }

    if (toks.length > 4) {
        f.score = parseFloat(toks[4]);
    }

    if (toks.length > 5) {
        f.orientation = toks[5];
    }

    if (toks.length > 8) {
        var color = toks[8];
        if (BED_COLOR_REGEXP.test(color)) {
            f.itemRgb = 'rgb(' + color + ')';
        }
    }

    if (toks.length >= 12) {
        var thickStart = parseInt(toks[6]);
        var thickEnd = parseInt(toks[7]);
        var blockCount = parseInt(toks[9]);
        var blockSizes = toks[10].split(',').map(function (x) {
            return parseInt(x);
        });
        var blockStarts = toks[11].split(',').map(function (x) {
            return parseInt(x);
        });

        // Only handle "block" data if things look reasonably sane.
        if (blockSizes.length == blockStarts.length && blockSizes.length == blockCount) {
            f.type = 'transcript';
            var grp = new DASGroup();
            grp.id = toks[3];
            grp.type = 'transcript';
            grp.notes = [];
            f.groups = [grp];

            if (toks.length > 12) {
                var geneId = toks[12];
                var geneName = geneId;
                if (toks.length > 13) {
                    geneName = toks[13];
                }
                var gg = new DASGroup();
                gg.id = geneId;
                gg.label = geneName;
                gg.type = 'gene';
                f.groups.push(gg);
            }

            var spans = null;
            for (var b = 0; b < blockCount; ++b) {
                var bmin = blockStarts[b] + start;
                var bmax = bmin + blockSizes[b] - 1;
                var span = new Range(bmin, bmax);
                if (spans) {
                    spans = union(spans, span);
                } else {
                    spans = span;
                }
            }

            var tsList = spans.ranges();
            for (var s = 0; s < tsList.length; ++s) {
                var ts = tsList[s];
                var bf = shallowCopy(f);
                bf.min = ts.min();
                bf.max = ts.max();
                this.sink(bf);
            }

            if (thickEnd > thickStart) {
                var codingRegion = f.orientation == '+' ? new Range(thickStart, thickEnd + 3) : new Range(thickStart - 3, thickEnd);
                // +/- 3 to account for stop codon

                var tl = intersection(spans, codingRegion);
                if (tl) {
                    f.type = 'translation';
                    var tlList = tl.ranges();
                    var readingFrame = 0;
                    for (var s = 0; s < tlList.length; ++s) {
                        // Record reading frame for every exon
                        var index = s;
                        if (f.orientation == '-') index = tlList.length - s - 1;
                        var ts = tlList[index];
                        var bf = shallowCopy(f);
                        bf.min = ts.min();
                        bf.max = ts.max();
                        f.readframe = readingFrame;
                        var length = ts.max() - ts.min();
                        readingFrame = (readingFrame + length) % 3;
                        this.sink(bf);
                    }
                }
            }

            return;
        }
    }

    this.sink(f);
};

BedParseSession.prototype.flush = function () {};

function WigParseSession(parser, sink) {
    this.parser = parser;
    this.sink = sink;
    this.wigState = null;
}

WigParseSession.prototype.parse = function (line) {
    var toks = line.split(__SPACE_REGEXP);

    if (toks[0] == 'fixedStep') {
        this.wigState = 'fixedStep';
        this.chr = this.pos = this.step = null;
        this.span = 1;

        for (var ti = 1; ti < toks.length; ++ti) {
            var m = __KV_REGEXP.exec(toks[ti]);
            if (m) {
                if (m[1] == 'chrom') {
                    this.chr = m[2];
                } else if (m[1] == 'start') {
                    this.pos = parseInt(m[2]);
                } else if (m[1] == 'step') {
                    this.step = parseInt(m[2]);
                } else if (m[1] == 'span') {
                    this.span = parseInt(m[2]);
                }
            }
        }
    } else if (toks[0] == 'variableStep') {
        this.wigState = 'variableStep';
        this.chr = null;
        this.span = 1;

        for (var ti = 1; ti < toks.length; ++ti) {
            var m = __KV_REGEXP.exec(toks[ti]);
            if (m[1] == 'chrom') {
                this.chr = m[2];
            } else if (m[1] == 'span') {
                this.span = parseInt(m[2]);
            }
        }
    } else {
        if (!this.wigState) {
            if (toks.length < 4) return;

            var f = { segment: toks[0],
                min: parseInt(toks[1]) + 1,
                max: parseInt(toks[2]),
                score: parseFloat(toks[3]) };

            this.sink(f);
        } else if (this.wigState == 'fixedStep') {
            if (toks.length != 1) return;
            var score = parseFloat(toks[0]);
            var f = { segment: this.chr, min: this.pos, max: this.pos + this.span - 1, score: score };
            this.pos += this.step;
            this.sink(f);
        } else if (this.wigState == 'variableStep') {
            if (toks.length != 2) return;
            var pos = parseInt(toks[0]);
            var score = parseFloat(toks[1]);
            var f = { segment: this.chr, min: pos, max: pos + this.span - 1, score: score };
            this.sink(f);
        }
    }
};

WigParseSession.prototype.flush = function () {};

BedWigParser.prototype.getStyleSheet = function (callback) {
    var thisB = this;
    var stylesheet = new DASStylesheet();

    if (this.type == 'wig') {
        var wigStyle = new DASStyle();
        wigStyle.glyph = 'HISTOGRAM';
        wigStyle.BGCOLOR = 'blue';
        wigStyle.HEIGHT = 30;
        stylesheet.pushStyle({ type: 'default' }, null, wigStyle);
    } else {
        var wigStyle = new DASStyle();
        wigStyle.glyph = 'BOX';
        wigStyle.FGCOLOR = 'black';
        wigStyle.BGCOLOR = 'blue';
        wigStyle.HEIGHT = 8;
        wigStyle.BUMP = true;
        wigStyle.LABEL = true;
        wigStyle.ZINDEX = 20;
        stylesheet.pushStyle({ type: 'default' }, null, wigStyle);

        var wigStyle = new DASStyle();
        wigStyle.glyph = 'BOX';
        wigStyle.FGCOLOR = 'black';
        wigStyle.BGCOLOR = 'red';
        wigStyle.HEIGHT = 10;
        wigStyle.BUMP = true;
        wigStyle.ZINDEX = 20;
        stylesheet.pushStyle({ type: 'translation' }, null, wigStyle);

        var tsStyle = new DASStyle();
        tsStyle.glyph = 'BOX';
        tsStyle.FGCOLOR = 'black';
        tsStyle.BGCOLOR = 'white';
        tsStyle.HEIGHT = 10;
        tsStyle.ZINDEX = 10;
        tsStyle.BUMP = true;
        tsStyle.LABEL = true;
        stylesheet.pushStyle({ type: 'transcript' }, null, tsStyle);

        var densStyle = new DASStyle();
        densStyle.glyph = 'HISTOGRAM';
        densStyle.COLOR1 = 'white';
        densStyle.COLOR2 = 'black';
        densStyle.HEIGHT = 30;
        stylesheet.pushStyle({ type: 'density' }, null, densStyle);
    }

    return callback(stylesheet);
};

dalliance_registerParserFactory('bed', function (t) {
    return new BedWigParser(t);
});
dalliance_registerParserFactory('wig', function (t) {
    return new BedWigParser(t);
});

},{"./das":10,"./sourceadapters":38,"./spans":40,"./utils":55}],3:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// bigwig.js: indexed binary WIG (and BED) files
//

"use strict";

if (typeof require !== 'undefined') {
    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;

    var das = require('./das');
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;

    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;

    var bin = require('./bin');
    var readInt = bin.readInt;

    var jszlib = require('jszlib');
    var jszlib_inflate_buffer = jszlib.inflateBuffer;
    var arrayCopy = jszlib.arrayCopy;
}

var BIG_WIG_MAGIC = 0x888FFC26;
var BIG_WIG_MAGIC_BE = 0x26FC8F88;
var BIG_BED_MAGIC = 0x8789F2EB;
var BIG_BED_MAGIC_BE = 0xEBF28987;

var BIG_WIG_TYPE_GRAPH = 1;
var BIG_WIG_TYPE_VSTEP = 2;
var BIG_WIG_TYPE_FSTEP = 3;

var M1 = 256;
var M2 = 256 * 256;
var M3 = 256 * 256 * 256;
var M4 = 256 * 256 * 256 * 256;

var BED_COLOR_REGEXP = new RegExp("^[0-9]+,[0-9]+,[0-9]+");

function bwg_readOffset(ba, o) {
    var offset = ba[o] + ba[o + 1] * M1 + ba[o + 2] * M2 + ba[o + 3] * M3 + ba[o + 4] * M4;
    return offset;
}

function BigWig() {}

BigWig.prototype.readChromTree = function (callback) {
    var thisB = this;
    this.chromsToIDs = {};
    this.idsToChroms = {};
    this.maxID = 0;

    var udo = this.unzoomedDataOffset;
    var eb = udo - this.chromTreeOffset & 3;
    udo = udo + 4 - eb;

    this.data.slice(this.chromTreeOffset, udo - this.chromTreeOffset).fetch(function (bpt) {
        var ba = new Uint8Array(bpt);
        var sa = new Int16Array(bpt);
        var la = new Int32Array(bpt);
        var bptMagic = la[0];
        var blockSize = la[1];
        var keySize = la[2];
        var valSize = la[3];
        var itemCount = bwg_readOffset(ba, 16);
        var rootNodeOffset = 32;

        var bptReadNode = function bptReadNode(offset) {
            var nodeType = ba[offset];
            var cnt = sa[offset / 2 + 1];
            offset += 4;
            for (var n = 0; n < cnt; ++n) {
                if (nodeType == 0) {
                    offset += keySize;
                    var childOffset = bwg_readOffset(ba, offset);
                    offset += 8;
                    childOffset -= thisB.chromTreeOffset;
                    bptReadNode(childOffset);
                } else {
                    var key = '';
                    for (var ki = 0; ki < keySize; ++ki) {
                        var charCode = ba[offset++];
                        if (charCode != 0) {
                            key += String.fromCharCode(charCode);
                        }
                    }
                    var chromId = ba[offset + 3] << 24 | ba[offset + 2] << 16 | ba[offset + 1] << 8 | ba[offset + 0];
                    var chromSize = ba[offset + 7] << 24 | ba[offset + 6] << 16 | ba[offset + 5] << 8 | ba[offset + 4];
                    offset += 8;

                    thisB.chromsToIDs[key] = chromId;
                    if (key.indexOf('chr') == 0) {
                        thisB.chromsToIDs[key.substr(3)] = chromId;
                    }
                    thisB.idsToChroms[chromId] = key;
                    thisB.maxID = Math.max(thisB.maxID, chromId);
                }
            }
        };
        bptReadNode(rootNodeOffset);

        callback(thisB);
    });
};

function BigWigView(bwg, cirTreeOffset, cirTreeLength, isSummary) {
    this.bwg = bwg;
    this.cirTreeOffset = cirTreeOffset;
    this.cirTreeLength = cirTreeLength;
    this.isSummary = isSummary;
}

BigWigView.prototype.readWigData = function (chrName, min, max, callback) {
    var chr = this.bwg.chromsToIDs[chrName];
    if (chr === undefined) {
        // Not an error because some .bwgs won't have data for all chromosomes.
        return callback([]);
    } else {
        this.readWigDataById(chr, min, max, callback);
    }
};

BigWigView.prototype.readWigDataById = function (chr, min, max, callback) {
    var thisB = this;
    if (!this.cirHeader) {
        this.bwg.data.slice(this.cirTreeOffset, 48).fetch(function (result) {
            thisB.cirHeader = result;
            var la = new Int32Array(thisB.cirHeader);
            thisB.cirBlockSize = la[1];
            thisB.readWigDataById(chr, min, max, callback);
        });
        return;
    }

    var blocksToFetch = [];
    var outstanding = 0;

    var beforeBWG = Date.now();

    var filter = function filter(chromId, fmin, fmax, toks) {
        return (chr < 0 || chromId == chr) && fmin <= max && fmax >= min;
    };

    var cirFobRecur = function cirFobRecur(offset, level) {
        if (thisB.bwg.instrument) console.log('level=' + level + '; offset=' + offset + '; time=' + (Date.now() | 0));

        outstanding += offset.length;

        if (offset.length == 1 && offset[0] - thisB.cirTreeOffset == 48 && thisB.cachedCirRoot) {
            cirFobRecur2(thisB.cachedCirRoot, 0, level);
            --outstanding;
            if (outstanding == 0) {
                thisB.fetchFeatures(filter, blocksToFetch, callback);
            }
            return;
        }

        var maxCirBlockSpan = 4 + thisB.cirBlockSize * 32; // Upper bound on size, based on a completely full leaf node.
        var spans;
        for (var i = 0; i < offset.length; ++i) {
            var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);
            spans = spans ? union(spans, blockSpan) : blockSpan;
        }

        var fetchRanges = spans.ranges();
        for (var r = 0; r < fetchRanges.length; ++r) {
            var fr = fetchRanges[r];
            cirFobStartFetch(offset, fr, level);
        }
    };

    var cirFobStartFetch = function cirFobStartFetch(offset, fr, level, attempts) {
        var length = fr.max() - fr.min();
        thisB.bwg.data.slice(fr.min(), fr.max() - fr.min()).fetch(function (resultBuffer) {
            for (var i = 0; i < offset.length; ++i) {
                if (fr.contains(offset[i])) {
                    cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);

                    if (offset[i] - thisB.cirTreeOffset == 48 && offset[i] - fr.min() == 0) thisB.cachedCirRoot = resultBuffer;

                    --outstanding;
                    if (outstanding == 0) {
                        thisB.fetchFeatures(filter, blocksToFetch, callback);
                    }
                }
            }
        });
    };

    var cirFobRecur2 = function cirFobRecur2(cirBlockData, offset, level) {
        var ba = new Uint8Array(cirBlockData);
        var sa = new Int16Array(cirBlockData, 0, cirBlockData.byteLength >> 1);
        var la = new Int32Array(cirBlockData, 0, cirBlockData.byteLength >> 2);

        var isLeaf = ba[offset];
        var cnt = sa[offset / 2 + 1];
        offset += 4;

        if (isLeaf != 0) {
            for (var i = 0; i < cnt; ++i) {
                var lo = offset / 4;
                var startChrom = la[lo];
                var startBase = la[lo + 1];
                var endChrom = la[lo + 2];
                var endBase = la[lo + 3];
                var blockOffset = bwg_readOffset(ba, offset + 16);
                var blockSize = bwg_readOffset(ba, offset + 24);
                if ((chr < 0 || startChrom < chr || startChrom == chr && startBase <= max) && (chr < 0 || endChrom > chr || endChrom == chr && endBase >= min)) {
                    blocksToFetch.push({ offset: blockOffset, size: blockSize });
                }
                offset += 32;
            }
        } else {
            var recurOffsets = [];
            for (var i = 0; i < cnt; ++i) {
                var lo = offset / 4;
                var startChrom = la[lo];
                var startBase = la[lo + 1];
                var endChrom = la[lo + 2];
                var endBase = la[lo + 3];
                var blockOffset = bwg_readOffset(ba, offset + 16);
                if ((chr < 0 || startChrom < chr || startChrom == chr && startBase <= max) && (chr < 0 || endChrom > chr || endChrom == chr && endBase >= min)) {
                    recurOffsets.push(blockOffset);
                }
                offset += 24;
            }
            if (recurOffsets.length > 0) {
                cirFobRecur(recurOffsets, level + 1);
            }
        }
    };

    cirFobRecur([thisB.cirTreeOffset + 48], 1);
};

BigWigView.prototype.fetchFeatures = function (filter, blocksToFetch, callback) {
    var thisB = this;

    blocksToFetch.sort(function (b0, b1) {
        return (b0.offset | 0) - (b1.offset | 0);
    });

    if (blocksToFetch.length == 0) {
        callback([]);
    } else {
        var features = [];
        var createFeature = function createFeature(chr, fmin, fmax, opts) {
            if (!opts) {
                opts = {};
            }

            var f = new DASFeature();
            f._chromId = chr;
            f.segment = thisB.bwg.idsToChroms[chr];
            f.min = fmin;
            f.max = fmax;
            f.type = thisB.bwg.type;

            for (var k in opts) {
                f[k] = opts[k];
            }

            features.push(f);
        };

        var tramp = function tramp() {
            if (blocksToFetch.length == 0) {
                var afterBWG = Date.now();
                // dlog('BWG fetch took ' + (afterBWG - beforeBWG) + 'ms');
                callback(features);
                return; // just in case...
            } else {
                var block = blocksToFetch[0];
                if (block.data) {
                    thisB.parseFeatures(block.data, createFeature, filter);
                    blocksToFetch.splice(0, 1);
                    tramp();
                } else {
                    var fetchStart = block.offset;
                    var fetchSize = block.size;
                    var bi = 1;
                    while (bi < blocksToFetch.length && blocksToFetch[bi].offset == fetchStart + fetchSize) {
                        fetchSize += blocksToFetch[bi].size;
                        ++bi;
                    }

                    thisB.bwg.data.slice(fetchStart, fetchSize).fetch(function (result) {
                        var offset = 0;
                        var bi = 0;
                        while (offset < fetchSize) {
                            var fb = blocksToFetch[bi];

                            var data;
                            if (thisB.bwg.uncompressBufSize > 0) {
                                data = jszlib_inflate_buffer(result, offset + 2, fb.size - 2);
                            } else {
                                var tmp = new Uint8Array(fb.size); // FIXME is this really the best we can do?
                                arrayCopy(new Uint8Array(result, offset, fb.size), 0, tmp, 0, fb.size);
                                data = tmp.buffer;
                            }
                            fb.data = data;

                            offset += fb.size;
                            ++bi;
                        }
                        tramp();
                    });
                }
            }
        };
        tramp();
    }
};

BigWigView.prototype.parseFeatures = function (data, createFeature, filter) {
    var ba = new Uint8Array(data);

    if (this.isSummary) {
        var sa = new Int16Array(data);
        var la = new Int32Array(data);
        var fa = new Float32Array(data);

        var itemCount = data.byteLength / 32;
        for (var i = 0; i < itemCount; ++i) {
            var chromId = la[i * 8];
            var start = la[i * 8 + 1];
            var end = la[i * 8 + 2];
            var validCnt = la[i * 8 + 3];
            var minVal = fa[i * 8 + 4];
            var maxVal = fa[i * 8 + 5];
            var sumData = fa[i * 8 + 6];
            var sumSqData = fa[i * 8 + 7];

            if (filter(chromId, start + 1, end)) {
                var summaryOpts = { type: 'bigwig', score: sumData / validCnt, maxScore: maxVal };
                if (this.bwg.type == 'bigbed') {
                    summaryOpts.type = 'density';
                }
                createFeature(chromId, start + 1, end, summaryOpts);
            }
        }
    } else if (this.bwg.type == 'bigwig') {
        var sa = new Int16Array(data);
        var la = new Int32Array(data);
        var fa = new Float32Array(data);

        var chromId = la[0];
        var blockStart = la[1];
        var blockEnd = la[2];
        var itemStep = la[3];
        var itemSpan = la[4];
        var blockType = ba[20];
        var itemCount = sa[11];

        if (blockType == BIG_WIG_TYPE_FSTEP) {
            for (var i = 0; i < itemCount; ++i) {
                var score = fa[i + 6];
                var fmin = blockStart + i * itemStep + 1,
                    fmax = blockStart + i * itemStep + itemSpan;
                if (filter(chromId, fmin, fmax)) createFeature(chromId, fmin, fmax, { score: score });
            }
        } else if (blockType == BIG_WIG_TYPE_VSTEP) {
            for (var i = 0; i < itemCount; ++i) {
                var start = la[i * 2 + 6] + 1;
                var end = start + itemSpan - 1;
                var score = fa[i * 2 + 7];
                if (filter(chromId, start, end)) createFeature(chromId, start, end, { score: score });
            }
        } else if (blockType == BIG_WIG_TYPE_GRAPH) {
            for (var i = 0; i < itemCount; ++i) {
                var start = la[i * 3 + 6] + 1;
                var end = la[i * 3 + 7];
                var score = fa[i * 3 + 8];
                if (start > end) {
                    start = end;
                }
                if (filter(chromId, start, end)) createFeature(chromId, start, end, { score: score });
            }
        } else {
            console.log('Currently not handling bwgType=' + blockType);
        }
    } else if (this.bwg.type == 'bigbed') {
        var offset = 0;
        var dfc = this.bwg.definedFieldCount;
        var schema = this.bwg.schema;

        while (offset < ba.length) {
            var chromId = ba[offset + 3] << 24 | ba[offset + 2] << 16 | ba[offset + 1] << 8 | ba[offset + 0];
            var start = ba[offset + 7] << 24 | ba[offset + 6] << 16 | ba[offset + 5] << 8 | ba[offset + 4];
            var end = ba[offset + 11] << 24 | ba[offset + 10] << 16 | ba[offset + 9] << 8 | ba[offset + 8];
            offset += 12;
            var rest = '';
            while (true) {
                var ch = ba[offset++];
                if (ch != 0) {
                    rest += String.fromCharCode(ch);
                } else {
                    break;
                }
            }

            var featureOpts = {};

            var bedColumns;
            if (rest.length > 0) {
                bedColumns = rest.split('\t');
            } else {
                bedColumns = [];
            }
            if (bedColumns.length > 0 && dfc > 3) {
                featureOpts.label = bedColumns[0];
            }
            if (bedColumns.length > 1 && dfc > 4) {
                var score = parseInt(bedColumns[1]);
                if (!isNaN(score)) featureOpts.score = score;
            }
            if (bedColumns.length > 2 && dfc > 5) {
                featureOpts.orientation = bedColumns[2];
            }
            if (bedColumns.length > 5 && dfc > 8) {
                var color = bedColumns[5];
                if (BED_COLOR_REGEXP.test(color)) {
                    featureOpts.itemRgb = 'rgb(' + color + ')';
                }
            }

            if (bedColumns.length > dfc - 3 && schema) {
                for (var col = dfc - 3; col < bedColumns.length; ++col) {
                    featureOpts[schema.fields[col + 3].name] = bedColumns[col];
                }
            }

            if (filter(chromId, start + 1, end, bedColumns)) {
                if (dfc < 12) {
                    createFeature(chromId, start + 1, end, featureOpts);
                } else {
                    var thickStart = bedColumns[3] | 0;
                    var thickEnd = bedColumns[4] | 0;
                    var blockCount = bedColumns[6] | 0;
                    var blockSizes = bedColumns[7].split(',');
                    var blockStarts = bedColumns[8].split(',');

                    if (featureOpts.exonFrames) {
                        var exonFrames = featureOpts.exonFrames.split(',');
                        featureOpts.exonFrames = undefined;
                    }

                    featureOpts.type = 'transcript';
                    var grp = new DASGroup();
                    for (var k in featureOpts) {
                        grp[k] = featureOpts[k];
                    }
                    grp.id = bedColumns[0];
                    grp.segment = this.bwg.idsToChroms[chromId];
                    grp.min = start + 1;
                    grp.max = end;
                    grp.notes = [];
                    featureOpts.groups = [grp];

                    // Moving towards using bigGenePred model, but will
                    // still support old Dalliance-style BED12+gene-name for the
                    // foreseeable future.
                    if (bedColumns.length > 9) {
                        var geneId = featureOpts.geneName || bedColumns[9];
                        var geneName = geneId;
                        if (bedColumns.length > 10) {
                            geneName = bedColumns[10];
                        }
                        if (featureOpts.geneName2) geneName = featureOpts.geneName2;

                        var gg = shallowCopy(grp);
                        gg.id = geneId;
                        gg.label = geneName;
                        gg.type = 'gene';
                        featureOpts.groups.push(gg);
                    }

                    var spanList = [];
                    for (var b = 0; b < blockCount; ++b) {
                        var bmin = (blockStarts[b] | 0) + start;
                        var bmax = bmin + (blockSizes[b] | 0);
                        var span = new Range(bmin, bmax);
                        spanList.push(span);
                    }
                    var spans = union(spanList);

                    var tsList = spans.ranges();
                    for (var s = 0; s < tsList.length; ++s) {
                        var ts = tsList[s];
                        createFeature(chromId, ts.min() + 1, ts.max(), featureOpts);
                    }

                    if (thickEnd > thickStart) {
                        var codingRegion = featureOpts.orientation == '+' ? new Range(thickStart, thickEnd + 3) : new Range(thickStart - 3, thickEnd);
                        // +/- 3 to account for stop codon

                        var tl = intersection(spans, codingRegion);
                        if (tl) {
                            featureOpts.type = 'translation';
                            var tlList = tl.ranges();
                            var readingFrame = 0;

                            var tlOffset = 0;
                            while (tlList[0].min() > tsList[tlOffset].max()) {
                                tlOffset++;
                            }for (var s = 0; s < tlList.length; ++s) {
                                // Record reading frame for every exon
                                var index = s;
                                if (featureOpts.orientation == '-') index = tlList.length - s - 1;
                                var ts = tlList[index];
                                featureOpts.readframe = readingFrame;
                                if (exonFrames) {
                                    var brf = parseInt(exonFrames[index + tlOffset]);
                                    if (typeof brf === 'number' && brf >= 0 && brf <= 2) {
                                        featureOpts.readframe = brf;
                                        featureOpts.readframeExplicit = true;
                                    }
                                }
                                var length = ts.max() - ts.min();
                                readingFrame = (readingFrame + length) % 3;
                                createFeature(chromId, ts.min() + 1, ts.max(), featureOpts);
                            }
                        }
                    }
                }
            }
        }
    } else {
        throw Error("Don't know what to do with " + this.bwg.type);
    }
};

//
// nasty cut/paste, should roll back in!
//

BigWigView.prototype.getFirstAdjacent = function (chrName, pos, dir, callback) {
    var chr = this.bwg.chromsToIDs[chrName];
    if (chr === undefined) {
        // Not an error because some .bwgs won't have data for all chromosomes.
        return callback([]);
    } else {
        this.getFirstAdjacentById(chr, pos, dir, callback);
    }
};

BigWigView.prototype.getFirstAdjacentById = function (chr, pos, dir, callback) {
    var thisB = this;
    if (!this.cirHeader) {
        this.bwg.data.slice(this.cirTreeOffset, 48).fetch(function (result) {
            thisB.cirHeader = result;
            var la = new Int32Array(thisB.cirHeader);
            thisB.cirBlockSize = la[1];
            thisB.getFirstAdjacentById(chr, pos, dir, callback);
        });
        return;
    }

    var blockToFetch = null;
    var bestBlockChr = -1;
    var bestBlockOffset = -1;

    var outstanding = 0;

    var beforeBWG = Date.now();

    var cirFobRecur = function cirFobRecur(offset, level) {
        outstanding += offset.length;

        var maxCirBlockSpan = 4 + thisB.cirBlockSize * 32; // Upper bound on size, based on a completely full leaf node.
        var spans;
        for (var i = 0; i < offset.length; ++i) {
            var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);
            spans = spans ? union(spans, blockSpan) : blockSpan;
        }

        var fetchRanges = spans.ranges();
        for (var r = 0; r < fetchRanges.length; ++r) {
            var fr = fetchRanges[r];
            cirFobStartFetch(offset, fr, level);
        }
    };

    var cirFobStartFetch = function cirFobStartFetch(offset, fr, level, attempts) {
        var length = fr.max() - fr.min();
        thisB.bwg.data.slice(fr.min(), fr.max() - fr.min()).fetch(function (resultBuffer) {
            for (var i = 0; i < offset.length; ++i) {
                if (fr.contains(offset[i])) {
                    cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);
                    --outstanding;
                    if (outstanding == 0) {
                        if (!blockToFetch) {
                            if (dir > 0 && (chr != 0 || pos > 0)) {
                                return thisB.getFirstAdjacentById(0, 0, dir, callback);
                            } else if (dir < 0 && (chr != thisB.bwg.maxID || pos < 1000000000)) {
                                return thisB.getFirstAdjacentById(thisB.bwg.maxID, 1000000000, dir, callback);
                            }
                            return callback([]);
                        }

                        thisB.fetchFeatures(function (chrx, fmin, fmax, toks) {
                            return dir < 0 && (chrx < chr || fmax < pos) || dir > 0 && (chrx > chr || fmin > pos);
                        }, [blockToFetch], function (features) {
                            var bestFeature = null;
                            var bestChr = -1;
                            var bestPos = -1;
                            for (var fi = 0; fi < features.length; ++fi) {
                                var f = features[fi];
                                var chrx = f._chromId,
                                    fmin = f.min,
                                    fmax = f.max;
                                if (bestFeature == null || dir < 0 && (chrx > bestChr || fmax > bestPos) || dir > 0 && (chrx < bestChr || fmin < bestPos)) {
                                    bestFeature = f;
                                    bestPos = dir < 0 ? fmax : fmin;
                                    bestChr = chrx;
                                }
                            }

                            if (bestFeature != null) return callback([bestFeature]);else return callback([]);
                        });
                    }
                }
            }
        });
    };

    var cirFobRecur2 = function cirFobRecur2(cirBlockData, offset, level) {
        var ba = new Uint8Array(cirBlockData);
        var sa = new Int16Array(cirBlockData);
        var la = new Int32Array(cirBlockData);

        var isLeaf = ba[offset];
        var cnt = sa[offset / 2 + 1];
        offset += 4;

        if (isLeaf != 0) {
            for (var i = 0; i < cnt; ++i) {
                var lo = offset / 4;
                var startChrom = la[lo];
                var startBase = la[lo + 1];
                var endChrom = la[lo + 2];
                var endBase = la[lo + 3];
                var blockOffset = bwg_readOffset(ba, offset + 16);
                var blockSize = bwg_readOffset(ba, offset + 24);
                if (dir < 0 && (startChrom < chr || startChrom == chr && startBase <= pos) || dir > 0 && (endChrom > chr || endChrom == chr && endBase >= pos)) {
                    // console.log('Got an interesting block: startBase=' + startChrom + ':' + startBase + '; endBase=' + endChrom + ':' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);
                    if (/_random/.exec(thisB.bwg.idsToChroms[startChrom])) {
                        // dlog('skipping random: ' + thisB.bwg.idsToChroms[startChrom]);
                    } else if (blockToFetch == null || dir < 0 && (endChrom > bestBlockChr || endChrom == bestBlockChr && endBase > bestBlockOffset) || dir > 0 && (startChrom < bestBlockChr || startChrom == bestBlockChr && startBase < bestBlockOffset)) {
                        //                        dlog('best is: startBase=' + startChrom + ':' + startBase + '; endBase=' + endChrom + ':' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);
                        blockToFetch = { offset: blockOffset, size: blockSize };
                        bestBlockOffset = dir < 0 ? endBase : startBase;
                        bestBlockChr = dir < 0 ? endChrom : startChrom;
                    }
                }
                offset += 32;
            }
        } else {
            var bestRecur = -1;
            var bestPos = -1;
            var bestChr = -1;
            for (var i = 0; i < cnt; ++i) {
                var lo = offset / 4;
                var startChrom = la[lo];
                var startBase = la[lo + 1];
                var endChrom = la[lo + 2];
                var endBase = la[lo + 3];
                var blockOffset = la[lo + 4] << 32 | la[lo + 5];
                if (dir < 0 && (startChrom < chr || startChrom == chr && startBase <= pos) && endChrom >= chr || dir > 0 && (endChrom > chr || endChrom == chr && endBase >= pos) && startChrom <= chr) {
                    if (bestRecur < 0 || endBase > bestPos) {
                        bestRecur = blockOffset;
                        bestPos = dir < 0 ? endBase : startBase;
                        bestChr = dir < 0 ? endChrom : startChrom;
                    }
                }
                offset += 24;
            }
            if (bestRecur >= 0) {
                cirFobRecur([bestRecur], level + 1);
            }
        }
    };

    cirFobRecur([thisB.cirTreeOffset + 48], 1);
};

BigWig.prototype.readWigData = function (chrName, min, max, callback) {
    this.getUnzoomedView().readWigData(chrName, min, max, callback);
};

BigWig.prototype.getUnzoomedView = function () {
    if (!this.unzoomedView) {
        var cirLen = 4000;
        var nzl = this.zoomLevels[0];
        if (nzl) {
            cirLen = this.zoomLevels[0].dataOffset - this.unzoomedIndexOffset;
        }
        this.unzoomedView = new BigWigView(this, this.unzoomedIndexOffset, cirLen, false);
    }
    return this.unzoomedView;
};

BigWig.prototype.getZoomedView = function (z) {
    var zh = this.zoomLevels[z];
    if (!zh.view) {
        zh.view = new BigWigView(this, zh.indexOffset, /* this.zoomLevels[z + 1].dataOffset - zh.indexOffset */4000, true);
    }
    return zh.view;
};

function makeBwg(data, callback, name) {
    var bwg = new BigWig();
    bwg.data = data;
    bwg.name = name;
    bwg.data.slice(0, 512).salted().fetch(function (result) {
        if (!result) {
            return callback(null, "Couldn't fetch file");
        }

        var header = result;
        var ba = new Uint8Array(header);
        var sa = new Int16Array(header);
        var la = new Int32Array(header);
        var magic = ba[0] + M1 * ba[1] + M2 * ba[2] + M3 * ba[3];
        if (magic == BIG_WIG_MAGIC) {
            bwg.type = 'bigwig';
        } else if (magic == BIG_BED_MAGIC) {
            bwg.type = 'bigbed';
        } else if (magic == BIG_WIG_MAGIC_BE || magic == BIG_BED_MAGIC_BE) {
            return callback(null, "Currently don't support big-endian BBI files");
        } else {
            return callback(null, "Not a supported format, magic=0x" + magic.toString(16));
        }

        bwg.version = sa[2]; // 4
        bwg.numZoomLevels = sa[3]; // 6
        bwg.chromTreeOffset = bwg_readOffset(ba, 8);
        bwg.unzoomedDataOffset = bwg_readOffset(ba, 16);
        bwg.unzoomedIndexOffset = bwg_readOffset(ba, 24);
        bwg.fieldCount = sa[16]; // 32
        bwg.definedFieldCount = sa[17]; // 34
        bwg.asOffset = bwg_readOffset(ba, 36);
        bwg.totalSummaryOffset = bwg_readOffset(ba, 44);
        bwg.uncompressBufSize = la[13]; // 52
        bwg.extHeaderOffset = bwg_readOffset(ba, 56);

        bwg.zoomLevels = [];
        for (var zl = 0; zl < bwg.numZoomLevels; ++zl) {
            var zlReduction = la[zl * 6 + 16];
            var zlData = bwg_readOffset(ba, zl * 24 + 72);
            var zlIndex = bwg_readOffset(ba, zl * 24 + 80);
            bwg.zoomLevels.push({ reduction: zlReduction, dataOffset: zlData, indexOffset: zlIndex });
        }

        bwg.readChromTree(function () {
            bwg.getAutoSQL(function (as) {
                bwg.schema = as;
                return callback(bwg);
            });
        });
    }, { timeout: 5000 }); // Potential timeout on first request to catch mixed-content errors on
    // Chromium.
}

BigWig.prototype._tsFetch = function (zoom, chr, min, max, callback) {
    var bwg = this;
    if (zoom >= this.zoomLevels.length - 1) {
        if (!this.topLevelReductionCache) {
            this.getZoomedView(this.zoomLevels.length - 1).readWigDataById(-1, 0, 300000000, function (feats) {
                bwg.topLevelReductionCache = feats;
                return bwg._tsFetch(zoom, chr, min, max, callback);
            });
        } else {
            var f = [];
            var c = this.topLevelReductionCache;
            for (var fi = 0; fi < c.length; ++fi) {
                if (c[fi]._chromId == chr) {
                    f.push(c[fi]);
                }
            }
            return callback(f);
        }
    } else {
        var view;
        if (zoom < 0) {
            view = this.getUnzoomedView();
        } else {
            view = this.getZoomedView(zoom);
        }
        return view.readWigDataById(chr, min, max, callback);
    }
};

BigWig.prototype.thresholdSearch = function (chrName, referencePoint, dir, threshold, callback) {
    dir = dir < 0 ? -1 : 1;
    var bwg = this;
    var initialChr = this.chromsToIDs[chrName];
    var candidates = [{ chrOrd: 0, chr: initialChr, zoom: bwg.zoomLevels.length - 4, min: 0, max: 300000000, fromRef: true }];
    for (var i = 1; i <= this.maxID + 1; ++i) {
        var chrId = (initialChr + dir * i) % (this.maxID + 1);
        if (chrId < 0) chrId += this.maxID + 1;
        candidates.push({ chrOrd: i, chr: chrId, zoom: bwg.zoomLevels.length - 1, min: 0, max: 300000000 });
    }

    function fbThresholdSearchRecur() {
        if (candidates.length == 0) {
            return callback(null);
        }
        candidates.sort(function (c1, c2) {
            var d = c1.zoom - c2.zoom;
            if (d != 0) return d;

            d = c1.chrOrd - c2.chrOrd;
            if (d != 0) return d;else return c1.min - c2.min * dir;
        });

        var candidate = candidates.splice(0, 1)[0];
        bwg._tsFetch(candidate.zoom, candidate.chr, candidate.min, candidate.max, function (feats) {
            var rp = dir > 0 ? 0 : 300000000;
            if (candidate.fromRef) rp = referencePoint;

            for (var fi = 0; fi < feats.length; ++fi) {
                var f = feats[fi];
                var score;
                if (f.maxScore != undefined) score = f.maxScore;else score = f.score;

                if (dir > 0) {
                    if (score > threshold) {
                        if (candidate.zoom < 0) {
                            if (f.min > rp) return callback(f);
                        } else if (f.max > rp) {
                            candidates.push({ chr: candidate.chr, chrOrd: candidate.chrOrd, zoom: candidate.zoom - 2, min: f.min, max: f.max, fromRef: candidate.fromRef });
                        }
                    }
                } else {
                    if (score > threshold) {
                        if (candidate.zoom < 0) {
                            if (f.max < rp) return callback(f);
                        } else if (f.min < rp) {
                            candidates.push({ chr: candidate.chr, chrOrd: candidate.chrOrd, zoom: candidate.zoom - 2, min: f.min, max: f.max, fromRef: candidate.fromRef });
                        }
                    }
                }
            }
            fbThresholdSearchRecur();
        });
    }

    fbThresholdSearchRecur();
};

BigWig.prototype.getAutoSQL = function (callback) {
    var thisB = this;
    if (!this.asOffset) return callback(null);

    this.data.slice(this.asOffset, 2048).fetch(function (result) {
        var ba = new Uint8Array(result);
        var s = '';
        for (var i = 0; i < ba.length; ++i) {
            if (ba[i] == 0) break;
            s += String.fromCharCode(ba[i]);
        }

        /* 
         * Quick'n'dirty attempt to parse autoSql format.
         * See: http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/059/5949/5949l2.html
         */

        var header_re = /(\w+)\s+(\w+)\s+("([^"]+)")?\s+\(\s*/;
        var field_re = /([\w\[\]]+)\s+(\w+)\s*;\s*("([^"]+)")?\s*/g;

        var headerMatch = header_re.exec(s);
        if (headerMatch) {
            var as = {
                declType: headerMatch[1],
                name: headerMatch[2],
                comment: headerMatch[4],

                fields: []
            };

            s = s.substring(headerMatch[0]);
            for (var m = field_re.exec(s); m != null; m = field_re.exec(s)) {
                as.fields.push({ type: m[1],
                    name: m[2],
                    comment: m[4] });
            }

            return callback(as);
        }
    });
};

BigWig.prototype.getExtraIndices = function (callback) {
    var thisB = this;
    if (this.version < 4 || this.extHeaderOffset == 0 || this.type != 'bigbed') {
        return callback(null);
    } else {
        this.data.slice(this.extHeaderOffset, 64).fetch(function (result) {
            if (!result) {
                return callback(null, "Couldn't fetch extension header");
            }

            var ba = new Uint8Array(result);
            var sa = new Int16Array(result);
            var la = new Int32Array(result);

            var extHeaderSize = sa[0];
            var extraIndexCount = sa[1];
            var extraIndexListOffset = bwg_readOffset(ba, 4);

            if (extraIndexCount == 0) {
                return callback(null);
            }

            // FIXME 20byte records only make sense for single-field indices.
            // Right now, these seem to be the only things around, but the format
            // is actually more general.
            thisB.data.slice(extraIndexListOffset, extraIndexCount * 20).fetch(function (eil) {
                if (!eil) {
                    return callback(null, "Couldn't fetch index info");
                }

                var ba = new Uint8Array(eil);
                var sa = new Int16Array(eil);
                var la = new Int32Array(eil);

                var indices = [];
                for (var ii = 0; ii < extraIndexCount; ++ii) {
                    var eiType = sa[ii * 10];
                    var eiFieldCount = sa[ii * 10 + 1];
                    var eiOffset = bwg_readOffset(ba, ii * 20 + 4);
                    var eiField = sa[ii * 10 + 8];
                    var index = new BBIExtraIndex(thisB, eiType, eiFieldCount, eiOffset, eiField);
                    indices.push(index);
                }
                callback(indices);
            });
        });
    }
};

function BBIExtraIndex(bbi, type, fieldCount, offset, field) {
    this.bbi = bbi;
    this.type = type;
    this.fieldCount = fieldCount;
    this.offset = offset;
    this.field = field;
}

BBIExtraIndex.prototype.lookup = function (name, callback) {
    var thisB = this;

    this.bbi.data.slice(this.offset, 32).fetch(function (bpt) {
        var ba = new Uint8Array(bpt);
        var sa = new Int16Array(bpt);
        var la = new Int32Array(bpt);
        var bptMagic = la[0];
        var blockSize = la[1];
        var keySize = la[2];
        var valSize = la[3];
        var itemCount = bwg_readOffset(ba, 16);
        var rootNodeOffset = 32;

        function bptReadNode(nodeOffset) {
            thisB.bbi.data.slice(nodeOffset, 4 + blockSize * (keySize + valSize)).fetch(function (node) {
                var ba = new Uint8Array(node);
                var sa = new Uint16Array(node);
                var la = new Uint32Array(node);

                var nodeType = ba[0];
                var cnt = sa[1];

                var offset = 4;
                if (nodeType == 0) {
                    var lastChildOffset = null;
                    for (var n = 0; n < cnt; ++n) {
                        var key = '';
                        for (var ki = 0; ki < keySize; ++ki) {
                            var charCode = ba[offset++];
                            if (charCode != 0) {
                                key += String.fromCharCode(charCode);
                            }
                        }

                        var childOffset = bwg_readOffset(ba, offset);
                        offset += 8;

                        if (name.localeCompare(key) < 0 && lastChildOffset) {
                            bptReadNode(lastChildOffset);
                            return;
                        }
                        lastChildOffset = childOffset;
                    }
                    bptReadNode(lastChildOffset);
                } else {
                    for (var n = 0; n < cnt; ++n) {
                        var key = '';
                        for (var ki = 0; ki < keySize; ++ki) {
                            var charCode = ba[offset++];
                            if (charCode != 0) {
                                key += String.fromCharCode(charCode);
                            }
                        }

                        // Specific for EI case.
                        if (key == name) {
                            var start = bwg_readOffset(ba, offset);
                            var length = readInt(ba, offset + 8);

                            return thisB.bbi.getUnzoomedView().fetchFeatures(function (chr, min, max, toks) {
                                if (toks && toks.length > thisB.field - 3) return toks[thisB.field - 3] == name;
                            }, [{ offset: start, size: length }], callback);
                        }
                        offset += valSize;
                    }
                    return callback([]);
                }
            });
        }

        bptReadNode(thisB.offset + rootNodeOffset);
    });
};

if (typeof module !== 'undefined') {
    module.exports = {
        makeBwg: makeBwg,
        BIG_BED_MAGIC: BIG_BED_MAGIC,
        BIG_WIG_MAGIC: BIG_WIG_MAGIC
    };
}

},{"./bin":4,"./das":10,"./spans":40,"./utils":55,"jszlib":60}],4:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// bin.js general binary data support
//

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;

    var sha1 = require('./sha1');
    var b64_sha1 = sha1.b64_sha1;

    var Promise = require('es6-promise').Promise;
}

function BlobFetchable(b) {
    this.blob = b;
}

BlobFetchable.prototype.slice = function (start, length) {
    var b;

    if (this.blob.slice) {
        if (length) {
            b = this.blob.slice(start, start + length);
        } else {
            b = this.blob.slice(start);
        }
    } else {
        if (length) {
            b = this.blob.webkitSlice(start, start + length);
        } else {
            b = this.blob.webkitSlice(start);
        }
    }
    return new BlobFetchable(b);
};

BlobFetchable.prototype.salted = function () {
    return this;
};

if (typeof FileReader !== 'undefined') {
    // console.log('defining async BlobFetchable.fetch');

    BlobFetchable.prototype.fetch = function (callback) {
        var reader = new FileReader();
        reader.onloadend = function (ev) {
            callback(bstringToBuffer(reader.result));
        };
        reader.readAsBinaryString(this.blob);
    };
} else {
    // if (console && console.log)
    //    console.log('defining sync BlobFetchable.fetch');

    BlobFetchable.prototype.fetch = function (callback) {
        var reader = new FileReaderSync();
        try {
            var res = reader.readAsArrayBuffer(this.blob);
            callback(res);
        } catch (e) {
            callback(null, e);
        }
    };
}

function URLFetchable(url, start, end, opts) {
    if (!opts) {
        if ((typeof start === 'undefined' ? 'undefined' : _typeof(start)) === 'object') {
            opts = start;
            start = undefined;
        } else {
            opts = {};
        }
    }

    this.url = url;
    this.start = start || 0;
    if (end) {
        this.end = end;
    }
    this.opts = opts;
}

URLFetchable.prototype.slice = function (s, l) {
    if (s < 0) {
        throw 'Bad slice ' + s;
    }

    var ns = this.start,
        ne = this.end;
    if (ns && s) {
        ns = ns + s;
    } else {
        ns = s || ns;
    }
    if (l && ns) {
        ne = ns + l - 1;
    } else {
        ne = ne || l - 1;
    }
    return new URLFetchable(this.url, ns, ne, this.opts);
};

var seed = 0;
var isSafari = typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Safari') >= 0 && navigator.userAgent.indexOf('Chrome') < 0;

URLFetchable.prototype.fetchAsText = function (callback) {
    var thisB = this;

    this.getURL().then(function (url) {
        try {
            var req = new XMLHttpRequest();
            var length;
            if ((isSafari || thisB.opts.salt) && url.indexOf('?') < 0) {
                url = url + '?salt=' + b64_sha1('' + Date.now() + ',' + ++seed);
            }
            req.open('GET', url, true);

            if (thisB.end) {
                if (thisB.end - thisB.start > 100000000) {
                    throw 'Monster fetch!';
                }
                req.setRequestHeader('Range', 'bytes=' + thisB.start + '-' + thisB.end);
                length = thisB.end - thisB.start + 1;
            }

            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (req.status == 200 || req.status == 206) {
                        return callback(req.responseText);
                    } else {
                        return callback(null);
                    }
                }
            };
            if (thisB.opts.credentials) {
                req.withCredentials = true;
            }
            req.send();
        } catch (e) {
            return callback(null);
        }
    }).catch(function (err) {
        console.log(err);
        return callback(null, err);
    });
};

URLFetchable.prototype.salted = function () {
    var o = shallowCopy(this.opts);
    o.salt = true;
    return new URLFetchable(this.url, this.start, this.end, o);
};

URLFetchable.prototype.getURL = function () {
    if (this.opts.resolver) {
        return this.opts.resolver(this.url).then(function (urlOrObj) {
            if (typeof urlOrObj === 'string') {
                return urlOrObj;
            } else {
                return urlOrObj.url;
            }
        });
    } else {
        return Promise.resolve(this.url);
    }
};

URLFetchable.prototype.fetch = function (callback, opts) {
    var thisB = this;

    opts = opts || {};
    var attempt = opts.attempt || 1;
    var truncatedLength = opts.truncatedLength;
    if (attempt > 3) {
        return callback(null);
    }

    this.getURL().then(function (url) {
        try {
            var timeout;
            if (opts.timeout && !thisB.opts.credentials) {
                timeout = setTimeout(function () {
                    console.log('timing out ' + url);
                    req.abort();
                    return callback(null, 'Timeout');
                }, opts.timeout);
            }

            var req = new XMLHttpRequest();
            var length;
            if ((isSafari || thisB.opts.salt) && url.indexOf('?') < 0) {
                url = url + '?salt=' + b64_sha1('' + Date.now() + ',' + ++seed);
            }
            req.open('GET', url, true);
            req.overrideMimeType('text/plain; charset=x-user-defined');
            if (thisB.end) {
                if (thisB.end - thisB.start > 100000000) {
                    throw 'Monster fetch!';
                }
                req.setRequestHeader('Range', 'bytes=' + thisB.start + '-' + thisB.end);
                length = thisB.end - thisB.start + 1;
            }
            req.responseType = 'arraybuffer';
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (timeout) clearTimeout(timeout);
                    if (req.status == 200 || req.status == 206) {
                        if (req.response) {
                            var bl = req.response.byteLength;
                            if (length && length != bl && (!truncatedLength || bl != truncatedLength)) {
                                return thisB.fetch(callback, { attempt: attempt + 1, truncatedLength: bl });
                            } else {
                                return callback(req.response);
                            }
                        } else if (req.mozResponseArrayBuffer) {
                            return callback(req.mozResponseArrayBuffer);
                        } else {
                            var r = req.responseText;
                            if (length && length != r.length && (!truncatedLength || r.length != truncatedLength)) {
                                return thisB.fetch(callback, { attempt: attempt + 1, truncatedLength: r.length });
                            } else {
                                return callback(bstringToBuffer(req.responseText));
                            }
                        }
                    } else {
                        return thisB.fetch(callback, { attempt: attempt + 1 });
                    }
                }
            };
            if (thisB.opts.credentials) {
                req.withCredentials = true;
            }
            req.send();
        } catch (e) {
            return callback(null);
        }
    }).catch(function (err) {
        console.log(err);
        return callback(null, err);
    });
};

function bstringToBuffer(result) {
    if (!result) {
        return null;
    }

    var ba = new Uint8Array(result.length);
    for (var i = 0; i < ba.length; ++i) {
        ba[i] = result.charCodeAt(i);
    }
    return ba.buffer;
}

// Read from Uint8Array

var convertBuffer = new ArrayBuffer(8);
var ba = new Uint8Array(convertBuffer);
var fa = new Float32Array(convertBuffer);

function readFloat(buf, offset) {
    ba[0] = buf[offset];
    ba[1] = buf[offset + 1];
    ba[2] = buf[offset + 2];
    ba[3] = buf[offset + 3];
    return fa[0];
}

function readInt64(ba, offset) {
    return ba[offset + 7] << 24 | ba[offset + 6] << 16 | ba[offset + 5] << 8 | ba[offset + 4];
}

var M1 = 256,
    M2 = M1 * 256,
    M3 = M2 * 256,
    M4 = M3 * 256,
    M5 = M4 * 256;

function readInt64LE(ba, offset) {
    return ba[offset] + ba[offset + 1] * M1 + ba[offset + 2] * M2 + ba[offset + 3] * M3 + ba[offset + 4] * M4 + ba[offset + 5] * M5;
}

function readInt64BE(ba, offset) {
    return ba[offset + 7] + ba[offset + 6] * M1 + ba[offset + 5] * M2 + ba[offset + 4] * M3 + ba[offset + 3] * M4 + ba[offset + 2] * M5;
}

function readInt(ba, offset) {
    return ba[offset + 3] << 24 | ba[offset + 2] << 16 | ba[offset + 1] << 8 | ba[offset];
}

function readShort(ba, offset) {
    return ba[offset + 1] << 8 | ba[offset];
}

function readByte(ba, offset) {
    return ba[offset];
}

function readIntBE(ba, offset) {
    return ba[offset] << 24 | ba[offset + 1] << 16 | ba[offset + 2] << 8 | ba[offset + 3];
}

// Exports if we are being used as a module

if (typeof module !== 'undefined') {
    module.exports = {
        BlobFetchable: BlobFetchable,
        URLFetchable: URLFetchable,

        readInt: readInt,
        readIntBE: readIntBE,
        readInt64: readInt64,
        readInt64LE: readInt64LE,
        readInt64BE: readInt64BE,
        readShort: readShort,
        readByte: readByte,
        readFloat: readFloat
    };
}

},{"./sha1":37,"./utils":55,"es6-promise":59}],5:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// browser-ui.js: standard UI wiring
//

"use strict";

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;

    var nf = require('./numformats');
    var formatLongInt = nf.formatLongInt;

    var makeZoomSlider = require('./zoomslider');

    // For side effects

    require('./tier-edit');
    require('./export-config');
    require('./export-ui');
    require('./export-image');
    require('./svg-export');
    require('./session');
}

/*
 * Quite a bit of this ought to be done using a templating system, but
 * since web-components isn't quite ready for prime time yet we'll stick
 * with constructing it all in Javascript for now...
 */

Browser.prototype.initUI = function (holder, genomePanel) {
    if (!this.noSourceCSS) {
        ['bootstrap-scoped.css', 'dalliance-scoped.css', 'font-awesome.min.css'].forEach(function (path) {
            document.head.appendChild(makeElement('link', '', {
                rel: 'stylesheet',
                href: this.resolveURL('$$css/' + path)
            }));
        }.bind(this));
    }

    var b = this;

    if (!b.disableDefaultFeaturePopup) {
        this.addFeatureListener(function (ev, feature, hit, tier) {
            b.featurePopup(ev, feature, hit, tier, { disableDrag: b.disableFeaturePopupDrag });
        });
    }

    holder.classList.add('dalliance');
    var toolbar = b.toolbar = makeElement('div', null, { className: 'btn-toolbar toolbar' }, { display: 'block' });

    var title = b.coordSystem.speciesName + ' ' + b.nameForCoordSystem(b.coordSystem);
    if (this.setDocumentTitle) {
        document.title = title + ' :: dalliance';
    }

    var locField = makeElement('input', '', { className: 'loc-field' });
    b.makeTooltip(locField, 'Enter a genomic location or gene name');
    var locStatusField = makeElement('p', '', { className: 'loc-status' });

    var zoomInBtn = makeElement('a', [makeElement('i', null, { className: 'fa fa-search-plus' })], { className: 'btn' });
    var zoomSlider = new makeZoomSlider({ width: b.zoomSliderWidth });
    b.makeTooltip(zoomSlider, "Highlighted button shows current zoom level, gray button shows inactive zoom level (click or tap SPACE to toggle).");

    var zoomOutBtn = makeElement('a', [makeElement('i', null, { className: 'fa fa-search-minus' })], { className: 'btn' });

    var clearHighlightsButton = makeElement('a', [makeElement('i', null, { className: 'fa fa-eraser' })], { className: 'btn' });

    var addTrackBtn = makeElement('a', [makeElement('i', null, { className: 'fa fa-plus' })], { className: 'btn' });
    var favBtn = makeElement('a', [makeElement('i', null, { className: 'fa fa-bookmark' })], { className: 'btn' });
    var svgBtn = makeElement('a', [makeElement('i', null, { className: 'fa fa-print' })], { className: 'btn' });
    var resetBtn = makeElement('a', [makeElement('i', null, { className: 'fa fa-refresh' })], { className: 'btn' });
    var optsButton = makeElement('a', [makeElement('i', null, { className: 'fa fa-cogs' })], { className: 'btn' });
    var helpButton = makeElement('a', [makeElement('i', null, { className: 'fa fa-question' })], { className: 'btn' });

    var tierEditButton = makeElement('a', [makeElement('i', null, { className: 'fa fa-road' })], { className: 'btn' });
    b.makeTooltip(tierEditButton, 'Configure currently selected track(s) (E)');

    var leapLeftButton = makeElement('a', [makeElement('i', null, { className: 'fa fa-angle-left' })], { className: 'btn' }, { width: '5px' });
    var leapRightButton = makeElement('a', [makeElement('i', null, { className: 'fa fa-angle-right' })], { className: 'btn pull-right' }, { width: '5px' });

    var modeButtons = makeElement('div', null, { className: 'btn-group pull-right' });
    if (!this.noTrackAdder) modeButtons.appendChild(addTrackBtn);
    if (!this.noTrackEditor) modeButtons.appendChild(tierEditButton);
    if (!this.noExport) modeButtons.appendChild(svgBtn);
    if (!this.noOptions) modeButtons.appendChild(optsButton);
    if (!this.noHelp) modeButtons.appendChild(helpButton);

    this.setUiMode = function (m) {
        this.uiMode = m;
        var mb = { help: helpButton, add: addTrackBtn, opts: optsButton, 'export': svgBtn, tier: tierEditButton };
        for (var x in mb) {
            if (x == m) mb[x].classList.add('active');else mb[x].classList.remove('active');
        }
    };

    if (!this.noLeapButtons) toolbar.appendChild(leapRightButton);

    if (modeButtons.firstChild) toolbar.appendChild(modeButtons);

    if (!this.noLeapButtons) toolbar.appendChild(leapLeftButton);
    if (!this.noTitle) {
        toolbar.appendChild(makeElement('div', makeElement('h4', title, {}, { margin: '0px' }), { className: 'btn-group title' }));
    }
    if (!this.noLocationField) toolbar.appendChild(makeElement('div', [locField, locStatusField], { className: 'btn-group loc-group' }));
    if (!this.noClearHighlightsButton) toolbar.appendChild(clearHighlightsButton);

    if (!this.noZoomSlider) {
        toolbar.appendChild(makeElement('div', [zoomInBtn, makeElement('span', zoomSlider, { className: 'btn' }), zoomOutBtn], { className: 'btn-group' }));
    }

    if (this.toolbarBelow) {
        holder.appendChild(genomePanel);
        holder.appendChild(toolbar);
    } else {
        holder.appendChild(toolbar);
        holder.appendChild(genomePanel);
    }

    var lt2 = Math.log(2) / Math.log(10);
    var lt5 = Math.log(5) / Math.log(10);
    var roundSliderValue = function roundSliderValue(x) {
        var ltx = (x / b.zoomExpt + Math.log(b.zoomBase)) / Math.log(10);

        var whole = ltx | 0;
        var frac = ltx - whole;
        var rounded;

        if (frac < 0.01) rounded = whole;else if (frac <= lt2 + 0.01) rounded = whole + lt2;else if (frac <= lt5 + 0.01) rounded = whole + lt5;else {
            rounded = whole + 1;
        }

        return (rounded * Math.log(10) - Math.log(b.zoomBase)) * b.zoomExpt;
    };

    var markSlider = function markSlider(x) {
        zoomSlider.addLabel(x, humanReadableScale(Math.exp(x / b.zoomExpt) * b.zoomBase));
    };

    this.addViewListener(function (chr, min, max, _oldZoom, zoom) {
        locField.value = chr + ':' + formatLongInt(min) + '..' + formatLongInt(max);
        zoomSlider.min = zoom.min | 0;
        zoomSlider.max = zoom.max | 0;
        if (zoom.isSnapZooming) {
            zoomSlider.value = zoom.alternate;
            zoomSlider.value2 = zoom.current;
            zoomSlider.active = 2;
        } else {
            zoomSlider.value = zoom.current;
            zoomSlider.value2 = zoom.alternate;
            zoomSlider.active = 1;
        }

        if (zoom.current == zoom.min) zoomInBtn.classList.add('disabled');else zoomInBtn.classList.remove('disabled');

        if (zoom.current == zoom.max) zoomOutBtn.classList.add('disabled');else zoomOutBtn.classList.remove('disabled');

        zoomSlider.removeLabels();
        var zmin = zoom.min;
        var zmax = zoom.max;
        var zrange = zmax - zmin;

        var numSliderTicks = 4;
        if (b.zoomSliderWidth && b.zoomSliderWidth < 150) numSliderTicks = 3;
        markSlider(roundSliderValue(zmin));
        for (var sti = 1; sti < numSliderTicks - 1; ++sti) {
            markSlider(roundSliderValue(zmin + 1.0 * sti * zrange / (numSliderTicks - 1)));
        }
        markSlider(roundSliderValue(zmax));

        if (b.storeStatus) {
            b.storeViewStatus();
        }

        if (b.highlights.length > 0) {
            clearHighlightsButton.style.display = 'inline-block';
        } else {
            clearHighlightsButton.style.display = 'none';
        }
    });

    this.addTierListener(function () {
        if (b.storeStatus) {
            b.storeTierStatus();
        }
    });

    locField.addEventListener('keydown', function (ev) {
        if (ev.keyCode == 40) {
            ev.preventDefault();ev.stopPropagation();
            b.setSelectedTier(0);
        }if (ev.keyCode == 10 || ev.keyCode == 13) {
            ev.preventDefault();

            var g = locField.value;
            b.search(g, function (err) {
                if (err) {
                    locStatusField.textContent = '' + err;
                } else {
                    locStatusField.textContent = '';
                }
            });
        }
    }, false);

    var trackAddPopup;
    addTrackBtn.addEventListener('click', function (ev) {
        b.showTrackAdder(ev);
    }, false);
    b.makeTooltip(addTrackBtn, 'Add a new track from the registry or an indexed file. (A)');

    zoomInBtn.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();

        b.zoomStep(-10);
    }, false);
    b.makeTooltip(zoomInBtn, 'Zoom in (+)');

    zoomOutBtn.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();

        b.zoomStep(10);
    }, false);
    b.makeTooltip(zoomOutBtn, 'Zoom out (-)');

    zoomSlider.addEventListener('change', function (ev) {
        var wantSnap = zoomSlider.active == 2;
        if (wantSnap != b.isSnapZooming) {
            b.savedZoom = b.zoomSliderValue - b.zoomMin;
            b.isSnapZooming = wantSnap;
        }
        var activeZSV = zoomSlider.active == 1 ? zoomSlider.value : zoomSlider.value2;

        b.zoomSliderValue = 1.0 * activeZSV;
        b.zoom(Math.exp(1.0 * activeZSV / b.zoomExpt));
    }, false);

    favBtn.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
    }, false);
    b.makeTooltip(favBtn, 'Favourite regions');

    svgBtn.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        b.openExportPanel();
    }, false);
    b.makeTooltip(svgBtn, 'Export publication-quality SVG. (X)');

    var optsPopup;
    optsButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();

        b.toggleOptsPopup(ev);
    }, false);
    b.makeTooltip(optsButton, 'Configure options.');

    helpButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        b.toggleHelpPopup(ev);
    });
    b.makeTooltip(helpButton, 'Help; Keyboard shortcuts. (H)');

    tierEditButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        if (b.selectedTiers.length == 1) {
            b.openTierPanel(b.tiers[b.selectedTiers[0]]);
        }
    }, false);

    leapLeftButton.addEventListener('click', function (ev) {
        b.leap(b.reverseKeyScrolling ? -1 : 1, false);
    }, false);

    leapRightButton.addEventListener('click', function (ev) {
        b.leap(b.reverseKeyScrolling ? 1 : -1, false);
    }, false);

    b.addTierSelectionListener(function () {
        var st = b.getSelectedTier();
        var tier;
        if (st >= 0) tier = b.tiers[st];

        var canLeap = false;
        if (tier && tier.featureSource) {
            if (b.sourceAdapterIsCapable(tier.featureSource, 'quantLeap') && typeof tier.quantLeapThreshold == 'number') {
                canLeap = true;
                leapLeftButton.title = 'Jump to the next feature in the selected track "' + (tier.config.name || tier.dasSource.name) + '" (ctrl+LEFT)';
                leapRightButton.title = 'Jump to the next region with a score above the threshold in the selected track "' + (tier.config.name || tier.dasSource.name) + '"" (ctrl+RIGHT)';
            } else if (b.sourceAdapterIsCapable(tier.featureSource, 'leap')) {
                leapLeftButton.title = 'Jump to the next feature in the selected track "' + (tier.config.name || tier.dasSource.name) + '" (ctrl+LEFT)';
                leapRightButton.title = 'Jump to the next feature in the selected track "' + (tier.config.name || tier.dasSource.name) + '" (ctrl+RIGHT)';
                canLeap = true;
            } else {
                leapLeftButton.title = 'Jump left (shift+LEFT)';
                leapRightButton.title = 'Jump right (shift+RIGHT)';
            }
        }

        leapLeftButton.firstChild.className = canLeap ? 'fa fa-angle-double-left' : 'fa fa-angle-left';
        leapRightButton.firstChild.className = canLeap ? 'fa fa-angle-double-right' : 'fa fa-angle-right';
    });

    clearHighlightsButton.addEventListener('click', function (ev) {
        b.clearHighlights();
    }, false);
    b.makeTooltip(clearHighlightsButton, 'Clear highlights (C)');

    b.addTierSelectionWrapListener(function (dir) {
        if (dir < 0) {
            b.setSelectedTier(null);
            locField.focus();
        }
    });

    b.addTierSelectionListener(function (sel) {
        if (b.uiMode === 'tier') {
            if (sel.length == 0) {
                b.hideToolPanel();
                b.manipulatingTier = null;
                b.uiMode = 'none';
            } else {
                var ft = b.tiers[sel[0]];
                if (ft != b.manipulatingTier) {
                    b.openTierPanel(ft);
                }
            }
        }
    });

    var uiKeyHandler = function uiKeyHandler(ev) {
        // console.log('bukh: ' + ev.keyCode);
        if (ev.keyCode == 65 || ev.keyCode == 97) {
            // a
            ev.preventDefault();ev.stopPropagation();
            b.showTrackAdder();
        } else if (ev.keyCode == 72 || ev.keyCode == 104) {
            // h
            ev.stopPropagation();ev.preventDefault();
            b.toggleHelpPopup(ev);
        } else if (ev.keyCode == 69 || ev.keyCode == 101) {
            //e
            ev.stopPropagation();ev.preventDefault();
            if (b.selectedTiers.length == 1) {
                b.openTierPanel(b.tiers[b.selectedTiers[0]]);
            }
        } else if (ev.keyCode == 88 || ev.keyCode == 120) {
            // x
            ev.stopPropagation();ev.preventDefault();
            b.openExportPanel();
        } else if (ev.keyCode == 67 || ev.keyCode == 99) {
            // c
            ev.stopPropagation();ev.preventDefault();
            b.clearHighlights();
        }
    };

    holder.addEventListener('focus', function (ev) {
        holder.addEventListener('keydown', uiKeyHandler, false);
    }, false);
    holder.addEventListener('blur', function (ev) {
        holder.removeEventListener('keydown', uiKeyHandler, false);
    }, false);

    holder.addEventListener('keydown', function (ev) {
        if (ev.keyCode === 27) {
            if (b.uiMode !== 'none') {
                // Only consume event if tool panel is open.
                ev.preventDefault();
                ev.stopPropagation();
                b.setUiMode('none');
                b.hideToolPanel();

                if (b.selectedTiers && b.selectedTiers.length > 0) {
                    b.browserHolder.focus();
                }
            }
        }
    }, false);
};

Browser.prototype.showToolPanel = function (panel, nowrap) {
    var thisB = this;

    if (this.activeToolPanel) {
        this.activeToolPanel.parentElement.removeChild(this.activeToolPanel);
    }

    var content;
    if (nowrap) content = panel;else content = makeElement('div', panel, {}, { overflowY: 'auto', width: '100%' });

    var divider = makeElement('div', makeElement('i', null, { className: 'fa fa-caret-right' }), { className: 'tool-divider' });
    divider.addEventListener('click', function (ev) {
        thisB.hideToolPanel();
        thisB.setUiMode('none');
    }, false);
    this.makeTooltip(divider, 'Close tool panel (ESC)');
    this.activeToolPanel = makeElement('div', [divider, content], { className: 'tool-holder' });
    this.svgHolder.appendChild(this.activeToolPanel);
    this.resizeViewer();

    var thisB = this;
};

Browser.prototype.hideToolPanel = function () {
    if (this.activeToolPanel) {
        this.activeToolPanel.parentElement.removeChild(this.activeToolPanel);
    }
    this.svgHolder.style.width = '100%';
    this.activeToolPanel = null;
    this.resizeViewer();
};

Browser.prototype.toggleHelpPopup = function (ev) {
    if (this.uiMode === 'help') {
        this.hideToolPanel();
        this.setUiMode('none');
    } else {
        var helpFrame = makeElement('iframe', null, { scrolling: 'yes', seamless: 'seamless', src: this.resolveURL('$$help/index.html'), className: 'help-panel' });
        this.showToolPanel(helpFrame, false);
        this.setUiMode('help');
    }
};

Browser.prototype.toggleOptsPopup = function (ev) {
    var b = this;

    if (this.uiMode === 'opts') {
        this.hideToolPanel();
        this.setUiMode('none');
    } else {
        var optsForm = makeElement('div', null, { className: 'form-horizontal' }, { boxSizing: 'border-box', MozBoxSizing: 'border-box', display: 'inline-block', verticalAlign: 'top' });
        var optsTable = makeElement('table');
        optsTable.cellPadding = 5;

        var scrollModeButton = makeElement('input', '', { type: 'checkbox', checked: b.reverseScrolling });
        scrollModeButton.addEventListener('change', function (ev) {
            b.reverseScrolling = scrollModeButton.checked;
            b.storeStatus();
        }, false);
        optsTable.appendChild(makeElement('tr', [makeElement('td', 'Reverse trackpad scrolling', { align: 'right' }), makeElement('td', scrollModeButton)]));

        var scrollKeyButton = makeElement('input', '', { type: 'checkbox', checked: b.reverseKeyScrolling });
        scrollKeyButton.addEventListener('change', function (ev) {
            b.reverseKeyScrolling = scrollKeyButton.checked;
            b.storeStatus();
        }, false);
        optsTable.appendChild(makeElement('tr', [makeElement('td', 'Reverse scrolling buttons and keys', { align: 'right' }), makeElement('td', scrollKeyButton)]));

        var rulerSelect = makeElement('select');
        rulerSelect.appendChild(makeElement('option', 'Left', { value: 'left' }));
        rulerSelect.appendChild(makeElement('option', 'Center', { value: 'center' }));
        rulerSelect.appendChild(makeElement('option', 'Right', { value: 'right' }));
        rulerSelect.appendChild(makeElement('option', 'None', { value: 'none' }));
        rulerSelect.value = b.rulerLocation;
        rulerSelect.addEventListener('change', function (ev) {
            b.rulerLocation = rulerSelect.value;
            b.positionRuler();
            for (var ti = 0; ti < b.tiers.length; ++ti) {
                b.tiers[ti].paintQuant();
            }
            b.storeStatus();
        }, false);
        optsTable.appendChild(makeElement('tr', [makeElement('td', 'Vertical guideline', { align: 'right' }), makeElement('td', rulerSelect)]));

        var singleBaseHighlightButton = makeElement('input', '', { type: 'checkbox', checked: b.singleBaseHighlight });
        singleBaseHighlightButton.addEventListener('change', function (ev) {
            b.singleBaseHighlight = singleBaseHighlightButton.checked;
            b.positionRuler();
            b.storeStatus();
        }, false);
        singleBaseHighlightButton.setAttribute('id', 'singleBaseHightlightButton'); // making this because access is required when the key 'u' is pressed and the options are visible
        optsTable.appendChild(makeElement('tr', [makeElement('td', 'Display and highlight current genome location', { align: 'right' }), makeElement('td', singleBaseHighlightButton)]));

        optsForm.appendChild(optsTable);

        var resetButton = makeElement('button', 'Reset browser', { className: 'btn' }, { marginLeft: 'auto', marginRight: 'auto', display: 'block' });
        resetButton.addEventListener('click', function (ev) {
            b.reset();
        }, false);
        optsForm.appendChild(resetButton);

        this.showToolPanel(optsForm);
        this.setUiMode('opts');
    }
};

function humanReadableScale(x) {
    var suffix = 'bp';
    if (x > 1000000000) {
        x /= 1000000000;
        suffix = 'Gb';
    } else if (x > 1000000) {
        x /= 1000000;
        suffix = 'Mb';
    } else if (x > 1000) {
        x /= 1000;
        suffix = 'kb';
    }
    return '' + Math.round(x) + suffix;
}

},{"./cbrowser":6,"./export-config":16,"./export-image":17,"./export-ui":18,"./numformats":29,"./session":36,"./svg-export":43,"./tier-edit":50,"./utils":55,"./zoomslider":58}],6:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// cbrowser.js: canvas browser container
//

"use strict";

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var Observed = utils.Observed;
    var Awaited = utils.Awaited;
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;
    var miniJSONify = utils.miniJSONify;
    var shallowCopy = utils.shallowCopy;
    var textXHR = utils.textXHR;
    var arrayEquals = utils.arrayEquals;

    var tier = require('./tier');
    var DasTier = tier.DasTier;

    var sha1 = require('./sha1');
    var hex_sha1 = sha1.hex_sha1;

    var thub = require('./thub');
    var connectTrackHub = thub.connectTrackHub;

    var VERSION = require('./version');

    var nf = require('./numformats');
    var formatQuantLabel = nf.formatQuantLabel;
    var formatLongInt = nf.formatLongInt;

    var Chainset = require('./chainset').Chainset;

    var Promise = require('es6-promise').Promise;

    var sourcecompare = require('./sourcecompare');
    var sourcesAreEqual = sourcecompare.sourcesAreEqual;
    var sourcesAreEqualModuloStyle = sourcecompare.sourcesAreEqualModuloStyle;
    var sourceDataURI = sourcecompare.sourceDataURI;
    var sourceStyleURI = sourcecompare.sourceStyleURI;

    var DefaultRenderer = require('./default-renderer');

    var MultiRenderer = require('./multi-renderer');
    var SubRenderer = require('./sub-renderer');

    var DummyRenderer = require('./dummy-renderer');
}

function Region(chr, min, max) {
    this.min = min;
    this.max = max;
    this.chr = chr;
}

function Browser(opts) {
    if (!opts) {
        opts = {};
    }

    this.renderers = { 'default': DefaultRenderer,
        'dummy': DummyRenderer,
        'multi': MultiRenderer,
        'sub': SubRenderer
    };

    this.defaultRenderer = opts.renderer || DefaultRenderer;

    this.prefix = '//www.biodalliance.org/release-0.14/';

    this.sources = [];
    this.tiers = [];
    this.tierGroups = {};

    this.searchOnlySources = [];
    this.searchOnlySourceHolders = [];

    this.featureListeners = [];
    this.featureHoverListeners = [];
    this.viewListeners = [];
    this.regionSelectListeners = [];
    this.tierListeners = [];
    this.tierSelectionListeners = [];
    this.tierSelectionWrapListeners = [];

    this.cookieKey = 'browser';

    this.chains = {};

    this.pageName = 'svgHolder';
    this.zoomFactor = 1.0;
    this.maxPixelsPerBase = 10;
    this.origin = 0;
    this.targetQuantRes = 1.0;
    this.featurePanelWidth = 750;
    this.zoomBase = 100;
    this.zoomExpt = 30.0; // Back to being fixed....
    this.zoomSliderValue = 100;
    this.entryPoints = null;
    this.currentSeqMax = -1; // init once EPs are fetched.

    this.highlights = [];
    this.selectedTiers = [1];

    this.maxViewWidth = 500000;
    this.defaultSubtierMax = 100;

    this.highZoomThreshold = 0.2;
    this.mediumZoomThreshold = 0.01;

    this.minExtraWidth = 100.0;
    this.maxExtraWidth = 1000.0;

    // Options.

    this.reverseScrolling = false;
    this.rulerLocation = 'center';
    this.defaultHighlightFill = 'red';
    this.defaultHighlightAlpha = 0.3;
    this.exportHighlights = true;
    this.exportRuler = true;
    this.exportBanner = true;
    this.exportRegion = true;
    this.singleBaseHighlight = true;

    // Visual config.

    // this.tierBackgroundColors = ["rgb(245,245,245)", "rgb(230,230,250)" /* 'white' */];
    this.tierBackgroundColors = ["rgb(245,245,245)", 'white'];
    this.minTierHeight = 20;
    this.noDefaultLabels = false;
    this.disableFeaturePopupDrag = opts.disableFeaturePopupDrag;

    // Registry

    this.availableSources = new Observed();
    this.defaultSources = [];
    this.mappableSources = {};

    // Central DAS Registry no longer available 2015-05

    this.registry = null; // '//www.dasregistry.org/das/sources';
    this.noRegistryTabs = true;

    this.defaultTrackAdderTab = null;

    this.hubs = [];
    this.hubObjects = [];

    this.sourceCache = new SourceCache();

    this.retina = true;

    this.useFetchWorkers = true;
    this.maxWorkers = 2;
    this.workerPath = '$$worker-all.js';
    this.resolvers = {};
    this.resolverSeed = 1;

    this.assemblyNamePrimary = true;
    this.assemblyNameUcsc = true;

    this.defaultSearchRegionPadding = 10000;

    // HTTP warning support

    this.httpCanaryURL = 'http://www.biodalliance.org/http-canary.txt';
    this.httpWarningURL = '//www.biodalliance.org/https.html';

    this.initListeners = [];

    if (opts.baseColors) {
        this.baseColors = opts.baseColors;
    } else {
        this.baseColors = {
            A: 'green',
            C: 'blue',
            G: 'orange',
            T: 'red',
            '-': 'hotpink', // deletion
            'I': 'red' // insertion
        };
    }

    if (opts.viewStart !== undefined && typeof opts.viewStart !== 'number') {
        throw Error('viewStart must be an integer');
    }
    if (opts.viewEnd !== undefined && typeof opts.viewEnd !== 'number') {
        throw Error('viewEnd must be an integer');
    }
    if (opts.offscreenInitWidth !== undefined && typeof opts.offscreenInitWidth !== 'number') {
        throw Error('offscreenInitWidth must be an integer');
    }

    for (var k in opts) {
        this[k] = opts[k];
    }

    if (typeof opts.uiPrefix === 'string' && typeof opts.prefix !== 'string') {
        this.prefix = opts.uiPrefix;
    }
    // If the prefix only starts with a single '/' this is relative to the current
    // site, so we need to prefix the prefix with //{hostname}
    if (this.prefix.indexOf('//') < 0 && this.prefix.indexOf('/') === 0) {
        var location = window.location.hostname;
        if (window.location.port) {
            location += ':' + window.location.port;
        };
        this.prefix = '//' + location + this.prefix;
    }
    if (this.prefix.indexOf('//') === 0) {
        var proto = window.location.protocol;
        if (proto == 'http:' || proto == 'https:') {
            // Protocol-relative URLs okay.
        } else {
            console.log(window.location.protocol);
            console.log('WARNING: prefix is set to a protocol-relative URL (' + this.prefix + ' when loading from a non-HTTP source');
            this.prefix = 'http:' + this.prefix;
        }
    }

    if (!this.coordSystem) {
        throw Error('Coordinate system must be configured');
    }

    if (this.chr === undefined || this.viewStart === undefined || this.viewEnd === undefined) {
        throw Error('Viewed region (chr:start..end) must be defined');
    }

    var thisB = this;

    if (document.readyState === 'complete') {
        thisB.realInit();
    } else {
        var loadListener = function loadListener(ev) {
            window.removeEventListener('load', loadListener, false);
            thisB.realInit();
        };
        window.addEventListener('load', loadListener, false);
    }
}

Browser.prototype.resolveURL = function (url) {
    return url.replace('$$', this.prefix);
};

Browser.prototype.destroy = function () {
    window.removeEventListener('resize', this.resizeListener, false);
    if (this.fetchWorkers) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = this.fetchWorkers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var worker = _step.value;

                worker.terminate();
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
};

Browser.prototype.realInit = function () {
    var self = this;
    var thisB = this;

    if (this.wasInitialized) {
        console.log('Attemping to call realInit on an already-initialized Dalliance instance');
        return;
    }

    this.wasInitialized = true;

    if (typeof navigator !== 'undefined') {
        var ua = navigator.userAgent || 'dummy';
        if (ua.indexOf('Trident') >= 0 && ua.indexOf('rv:11') >= 0) {
            // console.log('Detected IE11, disabling tier pinning.');
            this.disablePinning = true;
        }
    }

    this.defaultChr = this.chr;
    this.defaultStart = this.viewStart;
    this.defaultEnd = this.viewEnd;
    this.defaultSources = [];
    for (var i = 0; i < this.sources.length; ++i) {
        var s = this.sources[i];
        if (s) this.defaultSources.push(s);
    }

    if (this.restoreStatus) {
        this.statusRestored = this.restoreStatus();
    }

    if (this.injectionPoint && this.injectionPoint instanceof Element) {
        this.browserHolderHolder = this.injectionPoint;
    } else if (this.injectionPoint) {
        this.browserHolderHolder = document.getElementById(this.injectionPoint);
        if (!this.browserHolderHolder) {
            throw Error('injectionPoint must point to a valid DOM element of element ID');
        }
    } else {
        this.browserHolderHolder = document.getElementById(this.pageName);
        if (!this.browserHolderHolder) {
            throw Error('pageName must be a valid element ID (or use the injectionPoint option instead)');
        }
    }

    this.browserHolderHolder.classList.add('dalliance-injection-point');
    this.browserHolder = makeElement('div', null, { className: 'dalliance dalliance-root', tabIndex: -1 });
    if (this.maxHeight) {
        this.browserHolder.style.maxHeight = this.maxHeight + 'px';
    } else if (this.maxHeight != undefined) {
        this.browserHolder.style.maxHeight = null;
    }
    removeChildren(this.browserHolderHolder);
    this.browserHolderHolder.appendChild(this.browserHolder);
    this.svgHolder = makeElement('div', null, { className: 'main-holder' });

    this.initUI(this.browserHolder, this.svgHolder);

    this.pinnedTierHolder = makeElement('div', null, { className: 'tier-holder tier-holder-pinned' });
    this.tierHolder = makeElement('div', this.makeLoader(24), { className: 'tier-holder tier-holder-rest' });

    this.locSingleBase = makeElement('span', '', { className: 'loc-single-base' });
    var locSingleBaseHolder = makeElement('div', this.locSingleBase, { className: 'loc-single-base-holder' });
    // Add listener to update single base location
    this.addViewListener(function (chr, minFloor, maxFloor, zoomSliderValue, zoomSliderDict, min, max) {
        // Just setting textContent causes layout flickering in Blink.
        // This approach means that the element is never empty.
        var loc = Math.round((max + min) / 2);
        self.locSingleBase.appendChild(document.createTextNode(chr + ':' + formatLongInt(loc)));
        self.locSingleBase.removeChild(self.locSingleBase.firstChild);
    });

    if (this.disablePinning) {
        this.tierHolderHolder = this.tierHolder;
    } else {
        this.tierHolderHolder = makeElement('div', [locSingleBaseHolder, this.pinnedTierHolder, this.tierHolder], { className: 'tier-holder-holder' });
        this.svgHolder.appendChild(this.tierHolderHolder);
    }
    this.svgHolder.appendChild(this.tierHolderHolder);

    this.bhtmlRoot = makeElement('div');
    if (!this.disablePoweredBy) {
        this.bhtmlRoot.appendChild(makeElement('span', ['Powered by ', makeElement('a', 'Biodalliance', { href: 'http://www.biodalliance.org/' }), ' ' + VERSION], { className: 'powered-by' }));
    }
    this.browserHolder.appendChild(this.bhtmlRoot);

    this.resizeListener = function (ev) {
        thisB.resizeViewer();
    };

    this.ruler = makeElement('div', null, { className: 'guideline' });
    this.ruler2 = makeElement('div', null, { className: 'single-base-guideline' });
    this.tierHolderHolder.appendChild(this.ruler);
    this.tierHolderHolder.appendChild(this.ruler2);
    this.chainConfigs = this.chains || {};
    this.chains = {};
    for (var k in this.chainConfigs) {
        var cc = this.chainConfigs[k];
        if (cc instanceof Chainset) {
            console.log('WARNING: Should no longer use "new Chainset" in Biodalliance configurations.');
        }
        this.chains[k] = new Chainset(cc);
    }

    var promisedWorkers;
    if (this.maxWorkers > 0) {
        var pw = [];
        for (var fi = 0; fi < this.maxWorkers; ++fi) {
            pw.push(makeFetchWorker(this));
        }promisedWorkers = Promise.all(pw);
    } else {
        promisedWorkers = Promise.resolve([]);
    }

    this.fetchWorkers = null;
    this.nextWorker = 0;
    promisedWorkers.then(function (v) {
        console.log('Booted ' + v.length + ' workers');
        thisB.fetchWorkers = v;
    }, function (v) {
        console.log('Failed to boot workers', v);
    }).then(function () {
        if (self.offscreenInitWidth || window.getComputedStyle(thisB.browserHolderHolder).display != 'none' && thisB.tierHolder.getBoundingClientRect().width > 0) {
            setTimeout(function () {
                thisB.realInit2();
            }, 1);
        } else {
            var pollInterval = setInterval(function () {
                if (window.getComputedStyle(thisB.browserHolderHolder).display != 'none' && thisB.tierHolder.getBoundingClientRect().width > 0) {
                    clearInterval(pollInterval);
                    thisB.realInit2();
                }
            }, 300);
        }
    });
};

Browser.prototype.realInit2 = function () {
    var _this = this;

    var thisB = this;

    // Remove the loader icon, if needed
    removeChildren(this.tierHolder);
    removeChildren(this.pinnedTierHolder);

    this.featurePanelWidth = this.tierHolder.getBoundingClientRect().width | thisB.offscreenInitWidth | 0;
    window.addEventListener('resize', this.resizeListener, false);

    this.scale = this.featurePanelWidth / (this.viewEnd - this.viewStart);
    if (!this.zoomMax) {
        this.zoomMax = this.zoomExpt * Math.log(this.maxViewWidth / this.zoomBase);
        this.zoomMin = this.zoomExpt * Math.log(this.featurePanelWidth / this.maxPixelsPerBase / this.zoomBase);
    }
    this.zoomSliderValue = this.zoomExpt * Math.log((this.viewEnd - this.viewStart + 1) / this.zoomBase);

    // Event handlers

    this.tierHolderHolder.addEventListener('mousewheel', function (ev) {
        ev.stopPropagation();ev.preventDefault();

        if (ev.wheelDeltaX) {
            var delta = ev.wheelDeltaX / 5;
            if (!thisB.reverseScrolling) {
                delta = -delta;
            }
            thisB.move(delta);
        }

        if (ev.wheelDeltaY) {
            var delta = ev.wheelDeltaY;
            if (thisB.reverseScrolling) {
                delta = -delta;
            }
            thisB.tierHolder.scrollTop += delta;
        }
    }, false);

    this.tierHolderHolder.addEventListener('MozMousePixelScroll', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        if (ev.axis == 1) {
            if (ev.detail != 0) {
                var delta = ev.detail / 4;
                if (thisB.reverseScrolling) {
                    delta = -delta;
                }
                thisB.move(delta);
            }
        } else {
            var delta = ev.detail;
            if (!thisB.reverseScrolling) {
                delta = -delta;
            }

            thisB.tierHolder.scrollTop += delta;
        }
    }, false);

    this.tierHolderHolder.addEventListener('touchstart', function (ev) {
        return thisB.touchStartHandler(ev);
    }, false);
    this.tierHolderHolder.addEventListener('touchmove', function (ev) {
        return thisB.touchMoveHandler(ev);
    }, false);
    this.tierHolderHolder.addEventListener('touchend', function (ev) {
        return thisB.touchEndHandler(ev);
    }, false);
    this.tierHolderHolder.addEventListener('touchcancel', function (ev) {
        return thisB.touchCancelHandler(ev);
    }, false);

    var keyHandler = function keyHandler(ev) {
        // console.log('cbkh: ' + ev.keyCode);
        if (ev.keyCode == 13) {
            // enter
            var layoutsChanged = false;
            for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                var t = thisB.tiers[ti];
                if (t.wantedLayoutHeight && t.wantedLayoutHeight != t.layoutHeight) {
                    t.layoutHeight = t.wantedLayoutHeight;
                    t.clipTier();
                    layoutsChanged = true;
                }
            }
            if (layoutsChanged) {
                thisB.arrangeTiers();
            }
        } else if (ev.keyCode == 32 || ev.charCode == 32) {
            // space
            if (!thisB.isSnapZooming) {
                thisB.isSnapZooming = true;
                var newZoom = (thisB.savedZoom || 0.0) + thisB.zoomMin;
                thisB.savedZoom = thisB.zoomSliderValue - thisB.zoomMin;
                thisB.zoomSliderValue = newZoom;
                thisB.zoom(Math.exp(1.0 * newZoom / thisB.zoomExpt));
            } else {
                thisB.isSnapZooming = false;
                var newZoom = (thisB.savedZoom || 20.0) + thisB.zoomMin;
                thisB.savedZoom = thisB.zoomSliderValue - thisB.zoomMin;
                thisB.zoomSliderValue = newZoom;
                thisB.zoom(Math.exp(1.0 * newZoom / thisB.zoomExpt));
            }
            ev.stopPropagation();ev.preventDefault();
        } else if (ev.keyCode == 85) {
            // u
            if (thisB.uiMode === 'opts') {
                // if the options are visible, toggle the checkbox too
                var check = document.getElementById("singleBaseHightlightButton").checked;
                document.getElementById("singleBaseHightlightButton").checked = !check;
            }
            thisB.singleBaseHighlight = !thisB.singleBaseHighlight;
            thisB.positionRuler();
            ev.stopPropagation();ev.preventDefault();
        } else if (ev.keyCode == 39) {
            // right arrow
            ev.stopPropagation();ev.preventDefault();
            thisB.scrollArrowKey(ev, -1);
        } else if (ev.keyCode == 37) {
            // left arrow
            ev.stopPropagation();ev.preventDefault();
            thisB.scrollArrowKey(ev, 1);
        } else if (ev.keyCode == 38 || ev.keyCode == 87) {
            // up arrow | w
            ev.stopPropagation();ev.preventDefault();

            if (ev.shiftKey) {
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                var tt = thisB.tiers[st];
                var ch = tt.forceHeight || tt.subtiers[0].height;
                if (ch >= 40) {
                    tt.mergeConfig({ height: ch - 10 });
                }
            } else if (ev.ctrlKey || ev.metaKey) {
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                var tt = thisB.tiers[st];

                if (tt.quantLeapThreshold) {
                    var th = tt.subtiers[0].height;
                    var tq = tt.subtiers[0].quant;
                    if (!tq) return;

                    var qmin = 1.0 * tq.min;
                    var qmax = 1.0 * tq.max;

                    var qscale = (qmax - qmin) / th;
                    tt.mergeConfig({ quantLeapThreshold: qmin + ((Math.round((tt.quantLeapThreshold - qmin) / qscale) | 0) + 1) * qscale });

                    tt.notify('Threshold: ' + formatQuantLabel(tt.quantLeapThreshold));
                }
            } else if (ev.altKey) {
                var cnt = thisB.selectedTiers.length;
                if (cnt == 0) return;

                var st = thisB.selectedTiers[0];
                var contiguous = true;
                var mt = [];
                for (var si = 0; si < thisB.selectedTiers.length; ++si) {
                    mt.push(thisB.tiers[thisB.selectedTiers[si]]);
                    if (si > 0 && thisB.selectedTiers[si] - thisB.selectedTiers[si - 1] != 1) contiguous = false;
                }

                if (contiguous && st <= 0) return;

                for (var si = thisB.selectedTiers.length - 1; si >= 0; --si) {
                    thisB.tiers.splice(thisB.selectedTiers[si], 1);
                }thisB.selectedTiers.splice(0, cnt);

                var ip = contiguous ? st - 1 : st;
                for (var si = 0; si < mt.length; ++si) {
                    thisB.tiers.splice(ip + si, 0, mt[si]);
                    thisB.selectedTiers.push(ip + si);
                }

                thisB.withPreservedSelection(thisB._ensureTiersGrouped);
                thisB.markSelectedTiers();
                thisB.notifyTierSelection();
                thisB.reorderTiers();
                thisB.notifyTier("selected", st);
            } else {
                var st = thisB.getSelectedTier();
                if (st > 0) {
                    thisB.setSelectedTier(st - 1);
                    var nst = thisB.tiers[thisB.getSelectedTier()];
                    var top = nst.row.offsetTop,
                        bottom = top + nst.row.offsetHeight;
                    if (top < thisB.tierHolder.scrollTop || bottom > thisB.tierHolder.scrollTop + thisB.tierHolder.offsetHeight) {
                        thisB.tierHolder.scrollTop = top;
                    }
                } else {
                    thisB.notifyTierSelectionWrap(-1);
                }
            }
        } else if (ev.keyCode == 40 || ev.keyCode == 83) {
            // down arrow | s
            ev.stopPropagation();ev.preventDefault();

            if (ev.shiftKey) {
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                var tt = thisB.tiers[st];
                var ch = tt.forceHeight || tt.subtiers[0].height;
                tt.mergeConfig({ height: ch + 10 });
            } else if (ev.ctrlKey || ev.metaKey) {
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                var tt = thisB.tiers[st];

                if (tt.quantLeapThreshold) {
                    var th = tt.subtiers[0].height;
                    var tq = tt.subtiers[0].quant;
                    if (!tq) return;

                    var qmin = 1.0 * tq.min;
                    var qmax = 1.0 * tq.max;
                    var qscale = (qmax - qmin) / th;

                    var it = Math.round((tt.quantLeapThreshold - qmin) / qscale) | 0;
                    if (it > 1) {
                        tt.mergeConfig({ quantLeapThreshold: qmin + (it - 1) * qscale });
                        tt.notify('Threshold: ' + formatQuantLabel(tt.quantLeapThreshold));
                    }
                }
            } else if (ev.altKey) {
                var cnt = thisB.selectedTiers.length;
                if (cnt == 0) return;

                var st = thisB.selectedTiers[0];
                var discontig = 0;
                var mt = [];
                for (var si = 0; si < thisB.selectedTiers.length; ++si) {
                    mt.push(thisB.tiers[thisB.selectedTiers[si]]);
                    if (si > 0) discontig += thisB.selectedTiers[si] - thisB.selectedTiers[si - 1] - 1;
                }
                var contiguous = discontig == 0;

                if (contiguous && st + cnt >= thisB.tiers.length) return;

                for (var si = thisB.selectedTiers.length - 1; si >= 0; --si) {
                    thisB.tiers.splice(thisB.selectedTiers[si], 1);
                }thisB.selectedTiers.splice(0, cnt);

                var ip = contiguous ? st + 1 : st + discontig;
                for (var si = 0; si < mt.length; ++si) {
                    thisB.tiers.splice(ip + si, 0, mt[si]);
                    thisB.selectedTiers.push(ip + si);
                }

                thisB.withPreservedSelection(function () {
                    thisB._ensureTiersGrouped(true);
                });
                thisB.markSelectedTiers();
                thisB.notifyTierSelection();
                thisB.reorderTiers();
                thisB.notifyTier("selected", st);
            } else {
                var st = thisB.getSelectedTier();
                if (st < thisB.tiers.length - 1) {
                    thisB.setSelectedTier(st + 1);
                    var nst = thisB.tiers[thisB.getSelectedTier()];
                    var top = nst.row.offsetTop,
                        bottom = top + nst.row.offsetHeight;
                    if (top < thisB.tierHolder.scrollTop || bottom > thisB.tierHolder.scrollTop + thisB.tierHolder.offsetHeight) {
                        thisB.tierHolder.scrollTop = Math.min(top, bottom - thisB.tierHolder.offsetHeight);
                    }
                }
            }
        } else if (ev.keyCode == 187 || ev.keyCode == 61) {
            // +
            ev.stopPropagation();ev.preventDefault();
            thisB.zoomStep(-10);
        } else if (ev.keyCode == 189 || ev.keyCode == 173) {
            // -
            ev.stopPropagation();ev.preventDefault();
            thisB.zoomStep(10);
        } else if (ev.keyCode == 73 || ev.keyCode == 105) {
            // i
            ev.stopPropagation();ev.preventDefault();
            var st = thisB.getSelectedTier();
            if (st < 0) return;
            var t = thisB.tiers[st];
            if (!t.infoVisible) {
                t.infoElement.style.display = 'block';
                t.updateHeight();
                t.infoVisible = true;
            } else {
                t.infoElement.style.display = 'none';
                t.updateHeight();
                t.infoVisible = false;
            }
        } else if (ev.keyCode == 84 || ev.keyCode == 116) {
            // t
            var bumpStatus;
            if (ev.shiftKey) {
                ev.stopPropagation();ev.preventDefault();
                for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                    var t = thisB.tiers[ti];
                    if (t.dasSource.collapseSuperGroups) {
                        if (bumpStatus === undefined) {
                            bumpStatus = !t.bumped;
                        }
                        t.mergeConfig({ bumped: bumpStatus });
                    }
                }
            } else if (!ev.ctrlKey && !ev.metaKey) {
                ev.stopPropagation();ev.preventDefault();
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                var t = thisB.tiers[st];

                if (t.dasSource.collapseSuperGroups) {
                    if (bumpStatus === undefined) {
                        bumpStatus = !t.bumped;
                    }
                    t.mergeConfig({ bumped: bumpStatus });
                }
            }
        } else if (ev.keyCode == 77 || ev.keyCode == 109) {
            // m
            ev.stopPropagation();ev.preventDefault();
            if ((ev.ctrlKey || ev.metaKey) && thisB.selectedTiers.length > 1) {
                thisB.mergeSelectedTiers();
            }
        } else if (ev.keyCode == 68 || ev.keyCode == 100) {
            // d
            ev.stopPropagation();ev.preventDefault();
            if (ev.ctrlKey || ev.metaKey) {
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                thisB.addTier(thisB.tiers[st].dasSource);
            }
        } else if (ev.keyCode == 80 || ev.keyCode == 112) {
            // p
            if (ev.ctrlKey || ev.metaKey) {
                // Need to be careful because order of tiers could change
                // once we start updating pinning.
                var tt = [];
                for (var st = 0; st < thisB.selectedTiers.length; ++st) {
                    tt.push(thisB.tiers[thisB.selectedTiers[st]]);
                }
                for (var ti = 0; ti < tt.length; ++ti) {
                    tt[ti].mergeConfig({ pinned: !tt[ti].pinned });
                }
            }
        } else {
            // console.log('key: ' + ev.keyCode + '; char: ' + ev.charCode);
        }
    };

    this.browserHolder.addEventListener('focus', function (ev) {
        thisB.browserHolder.addEventListener('keydown', keyHandler, false);
    }, false);
    this.browserHolder.addEventListener('blur', function (ev) {
        thisB.browserHolder.removeEventListener('keydown', keyHandler, false);
    }, false);

    // Popup support (does this really belong here? FIXME)
    this.hPopupHolder = makeElement('div');
    this.hPopupHolder.style['font-family'] = 'helvetica';
    this.hPopupHolder.style['font-size'] = '12pt';
    this.hPopupHolder.classList.add('dalliance');
    document.body.appendChild(this.hPopupHolder);
    this.popups = [];

    var tierCreationPromises = [];
    for (var t = 0; t < this.sources.length; ++t) {
        var source = this.sources[t];
        if (!source) continue;

        var config = {};
        if (this.restoredConfigs) {
            config = this.restoredConfigs[t];
        }

        if (!source.disabled) {
            tierCreationPromises.push(this.makeTier(source, config));
        }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = this.searchOnlySources[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _source = _step2.value;

            if (!_source.disabled) {
                var _createSources = this.createSources(_source),
                    features = _createSources.features;

                if (features) {
                    this.searchOnlySourceHolders.push({
                        dasSource: _source,
                        featureSource: features
                    });
                }
            }
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    if (this.onFirstRender) {
        Promise.all(this.tiers.map(function (t) {
            return t.firstRenderPromise;
        })).then(function () {
            return _this.onFirstRender();
        }).catch(function (err) {
            return console.log(err);
        });
    }

    thisB._ensureTiersGrouped();
    thisB.arrangeTiers();
    thisB.reorderTiers();

    var ss = this.getSequenceSource();
    if (ss) {
        ss.getSeqInfo(this.chr, function (si) {
            if (si) thisB.currentSeqMax = si.length;else thisB.currentSeqMax = -1;
        });
    }

    this.queryRegistry();
    for (var m in this.chains) {
        this.queryRegistry(m, true);
    }

    if (this.hubs) {
        for (var hi = 0; hi < this.hubs.length; ++hi) {
            var hc = this.hubs[hi];
            if (typeof hc == 'string') {
                hc = { url: hc };
            };

            (function (hc) {
                connectTrackHub(hc.url, function (hub, err) {
                    if (err) {
                        console.log(err);
                    } else {
                        var tdb;
                        if (hc.genome) tdb = hub.genomes[hc.genome];else tdb = hub.genomes[thisB.coordSystem.ucscName];

                        if (tdb) {
                            if (hc.mapping) tdb.mapping = hc.mapping;
                            if (hc.label) tdb.hub.altLabel = hc.label;
                            thisB.hubObjects.push(tdb);
                        }
                    }
                }, hc);
            })(hc);
        }
    }

    if (this.fullScreen) {
        this.setFullScreenHeight();
    }

    if (!this.statusRestored && this.storeStatus) {
        this.storeStatus();
    }

    thisB.setLocation(this.chr, this.viewStart, this.viewEnd, function () {
        tierCreationPromises.forEach(function (p) {
            return p.then(function (t) {
                thisB.refreshTier(t, null, true);
            });
        });
        thisB.setSelectedTier(1);

        // Ping any init listeners.
        for (var ii = 0; ii < thisB.initListeners.length; ++ii) {
            try {
                thisB.initListeners[ii].call(thisB);
            } catch (e) {
                console.log(e);
            }
        }
    }, false, true);
};

//
// Touch event support
//

Browser.prototype.touchStartHandler = function (ev) {
    // Events not consumed so they can be interpretted as clicks as well.

    this.touchOriginX = ev.touches[0].pageX;
    this.touchOriginY = ev.touches[0].pageY;
    if (ev.touches.length == 2) {
        var sep = Math.abs(ev.touches[0].pageX - ev.touches[1].pageX);
        this.zooming = true;
        this.zoomLastSep = this.zoomInitialSep = sep;
        this.zoomInitialScale = this.scale;
    }
};

Browser.prototype.touchMoveHandler = function (ev) {
    // These events *are* consumed to ensure we never get any dragging that
    // we don't manage ourselves.

    ev.stopPropagation();ev.preventDefault();

    if (ev.touches.length == 1) {
        var touchX = ev.touches[0].pageX;
        var touchY = ev.touches[0].pageY;
        if (this.touchOriginX && touchX != this.touchOriginX) {
            this.move(touchX - this.touchOriginX);
        }
        if (this.touchOriginY && touchY != this.touchOriginY) {
            this.tierHolder.scrollTop -= touchY - this.touchOriginY;
        }
        this.touchOriginX = touchX;
        this.touchOriginY = touchY;
    } else if (this.zooming && ev.touches.length == 2) {
        var sep = Math.abs(ev.touches[0].pageX - ev.touches[1].pageX);
        if (sep != this.zoomLastSep) {
            var cp = (ev.touches[0].pageX + ev.touches[1].pageX) / 2;
            var scp = this.viewStart + cp / this.scale | 0;
            this.scale = this.zoomInitialScale * (sep / this.zoomInitialSep);
            this.viewStart = scp - cp / this.scale | 0;
            for (var i = 0; i < this.tiers.length; ++i) {
                this.getTierRenderer(tiers[i]).drawTier(tiers[i]);
            }
        }
        this.zoomLastSep = sep;
    }
};

Browser.prototype.touchEndHandler = function (ev) {};

Browser.prototype.touchCancelHandler = function (ev) {};

Browser.prototype.makeTier = function (source, config) {
    try {
        return this.realMakeTier(source, config);
    } catch (e) {
        console.log('Error initializing', source);
        console.log(e.stack || e);
    }
};

Browser.prototype.realMakeTier = function (source, config) {
    var thisB = this;
    var background = null;
    if (this.tierBackgroundColors) {
        background = this.tierBackgroundColors[this.tiers.length % this.tierBackgroundColors.length];
    }

    var tier = new DasTier(this, source, config, background);
    tier.oorigin = this.viewStart;

    var isDragging = false;
    var dragOrigin, dragMoveOrigin;
    var hoverTimeout;

    var featureLookup = function featureLookup(rx, ry) {
        var renderer = thisB.getTierRenderer(tier);
        if (renderer.featureLookup) return renderer.featureLookup(tier, rx, ry);
    };

    var dragMoveHandler = function dragMoveHandler(ev) {
        ev.preventDefault();ev.stopPropagation();
        var rx = ev.clientX;
        if (rx != dragMoveOrigin) {
            thisB.move(rx - dragMoveOrigin, true);
            dragMoveOrigin = rx;
        }
        thisB.isDragging = true;
    };

    var dragUpHandler = function dragUpHandler(ev) {
        window.removeEventListener('mousemove', dragMoveHandler, true);
        window.removeEventListener('mouseup', dragUpHandler, true);
        thisB.move(ev.clientX - dragMoveOrigin); // Snap back (FIXME: consider animation)
    };

    tier.viewport.addEventListener('mousedown', function (ev) {
        thisB.browserHolder.focus();
        ev.preventDefault();
        var br = tier.row.getBoundingClientRect();
        var rx = ev.clientX,
            ry = ev.clientY;

        window.addEventListener('mousemove', dragMoveHandler, true);
        window.addEventListener('mouseup', dragUpHandler, true);
        dragOrigin = dragMoveOrigin = rx;
        thisB.isDragging = false; // Not dragging until a movement event arrives.
    }, false);

    tier.viewport.addEventListener('mousemove', function (ev) {
        var br = tier.row.getBoundingClientRect();
        var rx = ev.clientX - br.left,
            ry = ev.clientY - br.top;

        var hit = featureLookup(rx, ry);
        if (hit && hit.length > 0) {
            tier.row.style.cursor = 'pointer';
        } else {
            tier.row.style.cursor = 'default';
        }

        if (hoverTimeout) {
            clearTimeout(hoverTimeout);
        }

        if (isDragging) {
            // if (tier.dasSource.tier_type !== 'sequence' && rx != dragMoveOrigin) {
            //    thisB.move((rx - dragMoveOrigin));
            //    dragMoveOrigin = rx;
            // }
        } else {
            if (hit !== thisB._overFeatures && !arrayEquals(hit, thisB._overFeatures)) {
                thisB._overFeatures = hit;
                if (hit && hit.length > 0) {
                    thisB.notifyImmediateFeatureHover(ev, hit[hit.length - 1], hit, tier);
                } else {
                    thisB.notifyImmediateFeatureHover(ev, undefined, undefined, tier);
                }
            }

            hoverTimeout = setTimeout(function () {
                var hit = featureLookup(rx, ry);
                if (hit && hit.length > 0) {
                    // flag, that there is something hovered on this tier
                    tier.hovered = true;
                    thisB.notifyDeferredFeatureHover(ev, hit[hit.length - 1], hit, tier);
                } else if (tier.hovered) {
                    tier.hovered = false;
                    thisB.notifyDeferredFeatureHover(ev, undefined, undefined, tier);
                }
            }, 1000);
        }
    });

    var doubleClickTimeout = null;
    tier.viewport.addEventListener('mouseup', function (ev) {
        var br = tier.row.getBoundingClientRect();
        var rx = ev.clientX - br.left,
            ry = ev.clientY - br.top;

        var hit = featureLookup(rx, ry);
        if (hit && hit.length > 0 && !thisB.isDragging) {
            if (doubleClickTimeout) {
                clearTimeout(doubleClickTimeout);
                doubleClickTimeout = null;
                thisB.featureDoubleClick(hit, rx, ry);
            } else {
                doubleClickTimeout = setTimeout(function () {
                    doubleClickTimeout = null;
                    thisB.notifyFeature(ev, hit[hit.length - 1], hit, tier);
                }, 500);
            }
        }

        if (thisB.isDragging && rx != dragOrigin && tier.sequenceSource) {
            var a = thisB.viewStart + rx / thisB.scale;
            var b = thisB.viewStart + dragOrigin / thisB.scale;

            var min, max;
            if (a < b) {
                min = a | 0;max = b | 0;
            } else {
                min = b | 0;max = a | 0;
            }

            thisB.notifyRegionSelect(thisB.chr, min, max);
        }
        thisB.isDragging = false;
    }, false);

    tier.viewport.addEventListener('mouseout', function (ev) {
        isDragging = false;
    });

    tier.removeButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        for (var ti = 0; ti < thisB.tiers.length; ++ti) {
            if (thisB.tiers[ti] === tier) {
                thisB.removeTier({ index: ti });
                break;
            }
        }
    }, false);
    tier.nameButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();

        if (ev.shiftKey) {
            var hitTier = -1;
            for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                if (thisB.tiers[ti] === tier) {
                    hitTier = ti;
                    break;
                }
            }
            if (hitTier >= 0) {
                var i = thisB.selectedTiers.indexOf(hitTier);
                if (i >= 0) {
                    thisB.selectedTiers.splice(i, 1);
                } else {
                    thisB.selectedTiers.push(hitTier);
                    thisB.selectedTiers.sort();
                }
                thisB.markSelectedTiers();
                thisB.notifyTierSelection();

                if (thisB.selectedTiers.length > 0) {
                    thisB.browserHolder.focus();
                } else {
                    thisB.notifyTierSelectionWrap(-1);
                }
            }
        } else {
            for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                if (thisB.tiers[ti] === tier) {
                    thisB.browserHolder.focus();
                    if (thisB.selectedTiers.length != 1 || thisB.selectedTiers[0] != ti) {
                        thisB.setSelectedTier(ti);
                        return;
                    }
                }
            }

            if (!tier.infoVisible) {
                tier.infoElement.style.display = 'block';
                tier.updateHeight();
                tier.infoVisible = true;
            } else {
                tier.infoElement.style.display = 'none';
                tier.updateHeight();
                tier.infoVisible = false;
            }
        }
    }, false);
    tier.bumpButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        var bumpStatus;
        var t = tier;
        if (t.dasSource.collapseSuperGroups) {
            if (bumpStatus === undefined) {
                bumpStatus = !t.bumped;
            }
            t.mergeConfig({ bumped: bumpStatus });
        }
    }, false);

    var dragLabel;
    var dragTierHolder;
    var dragTierHolderScrollLimit;
    var tierOrdinal;
    var yAtLastReorder;
    var tiersWereReordered = false;

    var labelDragHandler = function labelDragHandler(ev) {
        var label = tier.label;

        ev.stopPropagation();ev.preventDefault();
        if (!dragLabel) {
            if (tier.pinned) {
                dragTierHolder = thisB.pinnedTierHolder;
            } else {
                dragTierHolder = thisB.tierHolder;
            }
            dragTierHolderScrollLimit = dragTierHolder.scrollHeight - dragTierHolder.offsetHeight;

            dragLabel = label.cloneNode(true);
            dragLabel.style.cursor = 'pointer';
            dragTierHolder.appendChild(dragLabel);
            label.style.visibility = 'hidden';

            for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                if (thisB.tiers[ti] === tier) {
                    tierOrdinal = ti;
                    break;
                }
            }

            yAtLastReorder = ev.clientY;
        }

        var holderBCR = dragTierHolder.getBoundingClientRect();
        dragLabel.style.left = label.getBoundingClientRect().left - holderBCR.left + 'px';
        dragLabel.style.top = ev.clientY - holderBCR.top + dragTierHolder.scrollTop - 10 + 'px';

        var pty = ev.clientY - holderBCR.top + dragTierHolder.scrollTop;
        for (var ti = 0; ti < thisB.tiers.length; ++ti) {
            var tt = thisB.tiers[ti];
            if (tt.pinned ^ tier.pinned) continue;

            var ttr = tt.row.getBoundingClientRect();
            pty -= ttr.bottom - ttr.top;
            if (pty < 0) {
                if (ti < tierOrdinal && ev.clientY < yAtLastReorder || ti > tierOrdinal && ev.clientY > yAtLastReorder) {
                    thisB.withPreservedSelection(function () {
                        thisB.tiers.splice(tierOrdinal, 1);
                        thisB.tiers.splice(ti, 0, tier);
                        thisB._ensureTiersGrouped(ti > tierOrdinal);
                    });

                    for (var tix = 0; tix < thisB.tiers.length; ++tix) {
                        if (thisB.tiers[tix] == tier) tierOrdinal = tix;
                    }yAtLastReorder = ev.clientY;
                    thisB.reorderTiers();
                    dragTierHolder.appendChild(dragLabel); // Because reorderTiers removes all children.
                    tiersWereReordered = true;
                }
                break;
            }
        }

        if (dragLabel.offsetTop < dragTierHolder.scrollTop) {
            dragTierHolder.scrollTop -= dragTierHolder.scrollTop - dragLabel.offsetTop;
        } else if (dragLabel.offsetTop + dragLabel.offsetHeight > dragTierHolder.scrollTop + dragTierHolder.offsetHeight) {
            dragTierHolder.scrollTop = Math.min(dragTierHolder.scrollTop + (dragLabel.offsetTop + dragLabel.offsetHeight) - (dragTierHolder.scrollTop + dragTierHolder.offsetHeight), dragTierHolderScrollLimit);
        }
    };

    var labelReleaseHandler = function labelReleaseHandler(ev) {
        var label = tier.label;

        ev.stopPropagation();ev.preventDefault();
        if (dragLabel) {
            dragLabel.style.cursor = 'auto';
            dragTierHolder.removeChild(dragLabel);
            dragLabel = null;
            label.style.visibility = 'visible';
        }
        document.removeEventListener('mousemove', labelDragHandler, false);
        document.removeEventListener('mouseup', labelReleaseHandler, false);

        if (tiersWereReordered) {
            for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                if (thisB.tiers[ti] == tier) {
                    thisB.setSelectedTier(ti);
                    break;
                }
            }
            thisB.notifyTier("reordered", tier);
        }
    };

    tier.label.addEventListener('mousedown', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        tiersWereReordered = false;
        document.addEventListener('mousemove', labelDragHandler, false);
        document.addEventListener('mouseup', labelReleaseHandler, false);
    }, false);

    this.tiers.push(tier); // NB this currently tells any extant knownSpace about the new tier.

    // fetches stylesheet
    return tier.init().then(function (updatedTier) {
        updatedTier.currentlyHeight = 50;
        thisB.updateHeight();
        updatedTier.updateLabel();

        thisB.withPreservedSelection(thisB._ensureTiersGrouped);
        updatedTier._updateFromConfig();
        thisB.reorderTiers();

        return updatedTier;
    });
};

Browser.prototype.reorderTiers = function () {
    removeChildren(this.tierHolder);
    removeChildren(this.pinnedTierHolder);
    if (this.disablePinning) {
        this.tierHolder.appendChild(this.ruler);
        this.tierHolder.appendChild(this.ruler2);
    }
    var hasPinned = false;
    var pinnedTiers = [],
        unpinnedTiers = [];
    for (var i = 0; i < this.tiers.length; ++i) {
        var t = this.tiers[i];
        var visible = ['sub', 'dummy'].indexOf(this.tiers[i].dasSource.renderer) === -1;
        if (t.pinned && !this.disablePinning) {
            pinnedTiers.push(t);
            if (visible) this.pinnedTierHolder.appendChild(this.tiers[i].row);
            hasPinned = true;
        } else {
            unpinnedTiers.push(t);
            if (visible) this.tierHolder.appendChild(this.tiers[i].row);
        }
    }

    this.withPreservedSelection(function () {
        this.tiers.splice(0, this.tiers.length);
        for (var i = 0; i < pinnedTiers.length; ++i) {
            this.tiers.push(pinnedTiers[i]);
        }for (var i = 0; i < unpinnedTiers.length; ++i) {
            this.tiers.push(unpinnedTiers[i]);
        }
    });

    if (hasPinned) this.pinnedTierHolder.classList.add('tier-holder-pinned-full');else this.pinnedTierHolder.classList.remove('tier-holder-pinned-full');

    this.arrangeTiers();
};

Browser.prototype.withPreservedSelection = function (f) {
    var st = [];
    for (var xi = 0; xi < this.selectedTiers.length; ++xi) {
        st.push(this.tiers[this.selectedTiers[xi]]);
    }

    f.call(this);

    this.selectedTiers = [];
    for (var sti = 0; sti < this.tiers.length; ++sti) {
        if (st.indexOf(this.tiers[sti]) >= 0) this.selectedTiers.push(sti);
    }
};

Browser.prototype.refreshTier = function (tier, tierCallback, noInvalidate) {
    var renderer = this.getTierRenderer(tier);
    if (tier.dasSource.renderer === 'multi') {
        renderer.drawTier(tier);
    } else {
        var renderCallback = tierCallback || renderer.renderTier;
        if (this.knownSpace) {
            if (noInvalidate) {
                if (this.knownSpace.pool) this.knownSpace.startFetchesForTiers([tier]);
            } else {
                this.knownSpace.invalidate(tier, renderCallback);
            }
        }
    }
};

Browser.prototype.getTierRenderer = function (tier) {
    var renderer = tier.dasSource.renderer || this.defaultRenderer;
    if (typeof renderer === 'string') {
        return this.renderers[renderer];
    } else if (typeof renderer.renderTier === 'function' && typeof renderer.drawTier === 'function') {
        return renderer;
    } else {
        console.log("Tier doesn't have a renderer");
    }
};

/* Internal use only, assumes selection is being managed elsewhere... */

Browser.prototype._ensureTiersGrouped = function (down) {
    var groupedTiers = {};
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var t = this.tiers[ti];
        if (t.dasSource.tierGroup) {
            pusho(groupedTiers, t.dasSource.tierGroup, t);
        }
    }

    var newTiers = [];
    if (down) this.tiers.reverse();
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var t = this.tiers[ti];
        if (t.dasSource.tierGroup) {
            var nt = groupedTiers[t.dasSource.tierGroup];
            if (nt) {
                if (down) nt.reverse();
                for (var nti = 0; nti < nt.length; ++nti) {
                    newTiers.push(nt[nti]);
                }groupedTiers[t.dasSource.tierGroup] = null;
            }
        } else {
            newTiers.push(t);
        }
    }
    if (down) newTiers.reverse();
    this.tiers.splice(0, this.tiers.length);
    for (var nti = 0; nti < newTiers.length; ++nti) {
        this.tiers.push(newTiers[nti]);
    }
};

Browser.prototype.arrangeTiers = function () {
    var arrangedTiers = [];
    var groupedTiers = {};

    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var t = this.tiers[ti];
        if (t.pinned) {
            arrangedTiers.push(t);
            if (t.dasSource.tierGroup) {
                pusho(groupedTiers, t.dasSource.tierGroup, t);
            }
        }
    }
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var t = this.tiers[ti];
        if (!t.pinned) {
            arrangedTiers.push(t);
            if (t.dasSource.tierGroup) {
                pusho(groupedTiers, t.dasSource.tierGroup, t);
            }
        }
    }

    for (var g in groupedTiers) {
        var tiers = groupedTiers[g];
        var tierGroup = this.tierGroups[g];
        if (!tierGroup) {
            tierGroup = {
                element: makeElement('div', makeElement('span', g, { className: 'tier-group-label' }), { className: "tier-group" })
            };
            this.tierGroups[g] = tierGroup;
        }

        if (tierGroup.element.parentNode) tierGroup.element.parentNode.removeChild(tierGroup.element);

        var holder = tiers[0].pinned ? this.pinnedTierHolder : this.tierHolder;
        var min = 10000000,
            max = 0;
        for (var ti = 0; ti < tiers.length; ++ti) {
            var row = tiers[ti].row;
            min = Math.min(min, row.offsetTop);
            max = Math.max(max, row.offsetTop + row.offsetHeight);
        }
        tierGroup.element.style.top = min + 'px';
        tierGroup.element.style.left = '0px';
        tierGroup.element.style.height = max - min + 'px';
        holder.appendChild(tierGroup.element);
    }

    if (this.tierBackgroundColors) {
        for (var ti = 0; ti < arrangedTiers.length; ++ti) {
            var t = arrangedTiers[ti];
            t.setBackground(this.tierBackgroundColors[ti % this.tierBackgroundColors.length]);
            if (t.dasSource.tierGroup) t.label.style.left = '18px';else t.label.style.left = '2px';
            t.background = this.tierBackgroundColors[ti % this.tierBackgroundColors.length];
        }
    }
};

Browser.prototype.refresh = function (noStartFetches) {
    this.retrieveTierData(this.tiers, noStartFetches);
    this.drawOverlays();
    this.positionRuler();
};

var defaultTierRenderer = function defaultTierRenderer(status, tier) {
    console.log("DEPRECATED!");
};

Browser.prototype.retrieveTierData = function (tiers, noStartFetches) {
    this.notifyLocation();
    var width = this.viewEnd - this.viewStart + 1;
    var minExtraW = this.minExtraWidth / this.scale | 0;
    var maxExtraW = this.maxExtraWidth / this.scale | 0;

    var newOrigin = (this.viewStart + this.viewEnd) / 2;
    var oh = newOrigin - this.origin;
    this.origin = newOrigin;
    this.scaleAtLastRedraw = this.scale;
    for (var t = 0; t < tiers.length; ++t) {
        var od = oh;
        if (tiers[t].originHaxx) {
            od += tiers[t].originHaxx;
        }
        tiers[t].originHaxx = od;
    }

    var scaledQuantRes = this.targetQuantRes / this.scale;

    var innerDrawnStart = Math.max(1, (this.viewStart | 0) - minExtraW);
    var innerDrawnEnd = Math.min((this.viewEnd | 0) + minExtraW, (this.currentSeqMax | 0) > 0 ? this.currentSeqMax | 0 : 1000000000);
    var outerDrawnStart = Math.max(1, (this.viewStart | 0) - maxExtraW);
    var outerDrawnEnd = Math.min((this.viewEnd | 0) + maxExtraW, (this.currentSeqMax | 0) > 0 ? this.currentSeqMax | 0 : 1000000000);

    if (!this.knownSpace || this.knownSpace.chr !== this.chr) {
        var ss = this.getSequenceSource();
        if (this.knownSpace) this.knownSpace.cancel();
        // known space is created based on the entire tier list, for future caching purposes, even if only a subset of the tiers are needed to be rendered now.
        this.knownSpace = new KnownSpace(this.tiers, this.chr, outerDrawnStart, outerDrawnEnd, scaledQuantRes, ss);
    }

    var seg = this.knownSpace.bestCacheOverlapping(this.chr, innerDrawnStart, innerDrawnEnd);
    if (seg && seg.min <= innerDrawnStart && seg.max >= innerDrawnEnd) {
        this.drawnStart = Math.max(seg.min, outerDrawnStart);
        this.drawnEnd = Math.min(seg.max, outerDrawnEnd);
    } else {
        this.drawnStart = outerDrawnStart;
        this.drawnEnd = outerDrawnEnd;
    }
    // send in the subset of tiers to retrieve.
    this.knownSpace.retrieveFeatures(tiers, this.chr, this.drawnStart, this.drawnEnd, scaledQuantRes, noStartFetches);
};

function setSources(msh, availableSources, maybeMapping) {
    if (maybeMapping) {
        for (var s = 0; s < availableSources.length; ++s) {
            availableSources[s].mapping = maybeMapping;
        }
    }
    msh.set(availableSources);
}

Browser.prototype.queryRegistry = function (maybeMapping, tryCache) {
    if (!this.registry) return;

    var thisB = this;
    var coords, msh;
    if (maybeMapping) {
        coords = this.chains[maybeMapping].coords;
        if (!thisB.mappableSources[maybeMapping]) {
            thisB.mappableSources[maybeMapping] = new Observed();
        }
        msh = thisB.mappableSources[maybeMapping];
    } else {
        coords = this.coordSystem;
        msh = this.availableSources;
    }
    var cacheHash = hex_sha1(miniJSONify(coords));
    if (tryCache) {
        var cacheTime = localStorage['dalliance.registry.' + cacheHash + '.last_queried'];
        if (cacheTime) {
            try {
                setSources(msh, JSON.parse(localStorage['dalliance.registry.' + cacheHash + '.sources']), maybeMapping);
                var cacheAge = (Date.now() | 0) - (cacheTime | 0);
                if (cacheAge < 12 * 60 * 60 * 1000) {
                    return;
                }
            } catch (rex) {
                console.log('Bad registry cache: ' + rex);
            }
        }
    }

    var rurl = this.registry;
    if (rurl.indexOf('//') == 0) {
        var proto = window.location.protocol;
        if (proto != 'https:' && proto != 'http:') rurl = 'http:' + rurl;
    }
    new DASRegistry(rurl).sources(function (sources) {
        var availableSources = [];
        for (var s = 0; s < sources.length; ++s) {
            var source = sources[s];
            if (!source.coords || source.coords.length == 0) {
                continue;
            }
            var scoords = source.coords[0];
            if (scoords.taxon != coords.taxon || scoords.auth != coords.auth || scoords.version != coords.version) {
                continue;
            }
            availableSources.push(source);
        }

        localStorage['dalliance.registry.' + cacheHash + '.sources'] = JSON.stringify(availableSources);
        localStorage['dalliance.registry.' + cacheHash + '.last_queried'] = '' + Date.now();

        setSources(msh, availableSources, maybeMapping);
    }, function (error) {
        // msh.set(null);
    }, coords);
};

//
// Navigation
//

Browser.prototype.move = function (pos, soft) {
    var wid = this.viewEnd - this.viewStart;
    var nStart = this.viewStart - 1.0 * pos / this.scale;
    var nEnd = nStart + wid;

    if (!soft) {
        if (this.currentSeqMax > 0 && nEnd > this.currentSeqMax) {
            nEnd = this.currentSeqMax;
            nStart = this.viewEnd - wid;
        }
        if (nStart < 1) {
            nStart = 1;
            nEnd = nStart + wid;
        }
    }

    this.setLocation(null, nStart, nEnd, null, soft);
};

Browser.prototype.zoomStep = function (delta) {
    var oz = 1.0 * this.zoomSliderValue;
    var nz = oz + delta;
    if (nz < this.zoomMin) {
        nz = this.zoomMin;
    }
    if (nz > this.zoomMax) {
        nz = this.zoomMax;
    }

    if (nz != oz) {
        this.zoomSliderValue = nz; // FIXME maybe ought to set inside zoom!
        this.zoom(Math.exp(1.0 * nz / this.zoomExpt));
    }
};

Browser.prototype.zoom = function (factor) {
    this.zoomFactor = factor;
    var viewCenter = Math.round((this.viewStart + this.viewEnd) / 2.0) | 0;
    this.viewStart = viewCenter - this.zoomBase * this.zoomFactor / 2;
    this.viewEnd = viewCenter + this.zoomBase * this.zoomFactor / 2;
    if (this.currentSeqMax > 0 && this.viewEnd > this.currentSeqMax + 5) {
        var len = this.viewEnd - this.viewStart + 1;
        this.viewEnd = this.currentSeqMax;
        this.viewStart = this.viewEnd - len + 1;
    }
    if (this.viewStart < 1) {
        var len = this.viewEnd - this.viewStart + 1;
        this.viewStart = 1;
        this.viewEnd = this.viewStart + len - 1;
    }
    this.scale = this.featurePanelWidth / (this.viewEnd - this.viewStart);
    var width = this.viewEnd - this.viewStart + 1;

    var scaleRat = this.scale / this.scaleAtLastRedraw;

    this.notifyLocation();
    this.refresh();
};

Browser.prototype.spaceCheck = function (dontRefresh) {
    if (!this.knownSpace || this.knownSpace.chr !== this.chr) {
        this.refresh(dontRefresh);
        return;
    }

    var width = (this.viewEnd - this.viewStart | 0) + 1;
    var minExtraW = this.minExtraWidth / this.scale | 0;
    var maxExtraW = this.maxExtraWidth / this.scale | 0;

    if ((this.drawnStart | 0) > Math.max(1, (this.viewStart | 0) - minExtraW | 0) || (this.drawnEnd | 0) < Math.min((this.viewEnd | 0) + minExtraW, (this.currentSeqMax | 0) > 0 ? this.currentSeqMax | 0 : 1000000000)) {
        this.refresh(dontRefresh);
    }
};

Browser.prototype.resizeViewer = function (skipRefresh) {
    var width = this.tierHolder.getBoundingClientRect().width | 0;
    if (width == 0) return;

    var oldFPW = Math.max(this.featurePanelWidth, 300); // Can get silly values stored
    // when the browser is hidden.
    this.featurePanelWidth = width | 0;

    if (oldFPW != this.featurePanelWidth) {
        this.zoomMax = this.zoomExpt * Math.log(this.maxViewWidth / this.zoomBase);
        this.zoomMin = this.zoomExpt * Math.log(this.featurePanelWidth / this.maxPixelsPerBase / this.zoomBase); // FIXME hard-coded minimum.
        this.zoomSliderValue = this.zoomExpt * Math.log((this.viewEnd - this.viewStart + 1) / this.zoomBase);

        var viewWidth = this.viewEnd - this.viewStart;
        var nve = this.viewStart + viewWidth * this.featurePanelWidth / oldFPW;

        this.viewEnd = nve;

        var wid = this.viewEnd - this.viewStart + 1;
        if (this.currentSeqMax > 0 && this.viewEnd > this.currentSeqMax) {
            this.viewEnd = this.currentSeqMax;
            this.viewStart = this.viewEnd - wid + 1;
        }
        if (this.viewStart < 1) {
            this.viewStart = 1;
            this.viewEnd = this.viewStart + wid - 1;
        }

        this.positionRuler();

        if (!skipRefresh) {
            this.spaceCheck();
        }
        this.notifyLocation();
    }

    if (this.fullScreen) {
        this.setFullScreenHeight();
    }
};

Browser.prototype.setFullScreenHeight = function () {
    var rest = document.body.offsetHeight - this.browserHolder.offsetHeight;
    this.browserHolder.style.maxHeight = Math.max(300, window.innerHeight - rest - 20) + 'px';
};

Browser.prototype.addTier = function (conf) {
    var thisB = this;
    conf = shallowCopy(conf);
    conf.disabled = false;

    return this.makeTier(conf).then(function (tier) {
        thisB.refreshTier(tier);
        thisB.markSelectedTiers();
        thisB.positionRuler();
        thisB.notifyTier("added", tier);
        return tier;
    });
};

Browser.prototype.removeTier = function (conf, force) {
    var target = -1;

    if (typeof conf.index !== 'undefined' && conf.index >= 0 && conf.index < this.tiers.length) {
        target = conf.index;
    } else {
        for (var ti = 0; ti < this.tiers.length; ++ti) {
            var ts = this.tiers[ti].dasSource;

            if (sourcesAreEqual(conf, ts)) {
                target = ti;break;
            }
        }
    }

    if (target < 0) {
        throw "Couldn't find requested tier";
    }

    var targetTier = this.tiers[target];
    this.tiers.splice(target, 1);

    var nst = [];
    for (var sti = 0; sti < this.selectedTiers.length; ++sti) {
        var st = this.selectedTiers[sti];
        if (st < target) {
            nst.push(st);
        } else if (st > target) {
            nst.push(st - 1);
        }
    }
    this.selectedTiers = nst;
    this.markSelectedTiers();

    targetTier.destroy();
    if (this.knownSpace) {
        this.knownSpace.featureCache[targetTier] = null;
    }

    this.reorderTiers();
    this.notifyTier("removed", targetTier);
};

Browser.prototype.removeAllTiers = function () {
    var thisB = this;
    this.selectedTiers = [];
    this.markSelectedTiers();
    this.tiers.forEach(function (targetTier) {
        targetTier.destroy();
        if (thisB.knownSpace) {
            thisB.knownSpace.featureCache[targetTier] = null;
        }
    });
    this.tiers.length = 0;
    this.reorderTiers();
    this.notifyTier("removedAll", null);
};

Browser.prototype.getSequenceSource = function () {
    if (this._sequenceSource === undefined) this._sequenceSource = this._getSequenceSource();
    return this._sequenceSource;
};

Browser.prototype._getSequenceSource = function () {
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        if (this.tiers[ti].sequenceSource) {
            return this.tiers[ti].sequenceSource;
        }
    }

    for (var si = 0; si < this.defaultSources.length; ++si) {
        var s = this.defaultSources[si];
        if (s.provides_entrypoints || s.tier_type == 'sequence' || s.twoBitURI || s.twoBitBlob) {
            if (s.twoBitURI || s.twoBitBlob) {
                return new TwoBitSequenceSource(s);
            } else if (s.ensemblURI) {
                return new EnsemblSequenceSource(s);
            } else {
                return new DASSequenceSource(s);
            }
        }
    }
};

Browser.prototype.setLocation = function (newChr, newMin, newMax, callback, soft, noRefresh) {
    if (typeof newMin !== 'number') {
        throw Error('minimum must be a number (got ' + JSON.stringify(newMin) + ')');
    }
    if (typeof newMax !== 'number') {
        throw Error('maximum must be a number (got ' + JSON.stringify(newMax) + ')');
    }

    if (newMin > newMax) {
        var oldNewMin = newMin;
        newMin = newMax;
        newMax = oldNewMin;
    } else if (newMin === newMax) {
        newMax += 1;
    }

    if (!callback) {
        callback = function callback(err) {
            if (err) {
                throw err;
            }
        };
    }
    var thisB = this;

    if ((!newChr || newChr == this.chr) && this.currentSeqMax > 0) {
        return this._setLocation(null, newMin, newMax, null, callback, soft, noRefresh);
    } else {
        var ss = this.getSequenceSource();
        if (!ss) {
            return callback('Need a sequence source');
        }

        var findChr = newChr || this.chr;
        ss.getSeqInfo(findChr, function (si) {
            if (!si) {
                var altChr;
                if (findChr.indexOf('chr') == 0) {
                    altChr = findChr.substr(3);
                } else {
                    altChr = 'chr' + findChr;
                }
                ss.getSeqInfo(altChr, function (si2) {
                    if (!si2 && newChr) {
                        return callback("Couldn't find sequence '" + newChr + "'");
                    } else if (!si2) {
                        return thisB._setLocation(null, newMin, newMax, null, callback, soft, noRefresh);
                    } else {
                        return thisB._setLocation(altChr, newMin, newMax, si2, callback, soft, noRefresh);
                    }
                });
            } else {
                return thisB._setLocation(newChr, newMin, newMax, si, callback, soft, noRefresh);
            }
        });
    }
};

Browser.prototype._setLocation = function (newChr, newMin, newMax, newChrInfo, callback, soft, noRefresh) {
    var chrChanged = false;
    if (newChr) {
        if (newChr.indexOf('chr') == 0) newChr = newChr.substring(3);

        if (this.chr != newChr) chrChanged = true;
        this.chr = newChr;
        this.currentSeqMax = newChrInfo.length;
    }

    newMin = parseFloat(newMin);newMax = parseFloat(newMax);

    var newWidth = Math.max(10, newMax - newMin + 1);

    if (!soft) {
        var csm = this.currentSeqMax;
        if (csm <= 0) csm = 1000000000000;
        if (newMin < 1) {
            newMin = 1;newMax = newMin + newWidth - 1;
        }
        if (newMax > csm) {
            newMax = csm;
            newMin = Math.max(1, newMax - newWidth + 1);
        }
    }

    this.viewStart = newMin;
    this.viewEnd = newMax;
    var newScale = Math.max(this.featurePanelWidth || this.offscreenInitWidth, 50) / (this.viewEnd - this.viewStart);
    var oldScale = this.scale;
    var scaleChanged = Math.abs(newScale - oldScale) > 0.000001;
    this.scale = newScale;

    var newZS, oldZS;
    oldZS = this.zoomSliderValue;
    this.zoomSliderValue = newZS = this.zoomExpt * Math.log((this.viewEnd - this.viewStart + 1) / this.zoomBase);

    if (scaleChanged || chrChanged) {
        for (var i = 0; i < this.tiers.length; ++i) {
            this.tiers[i].viewportHolder.style.left = '5000px';
            this.tiers[i].overlay.style.left = '5000px';
        }

        if (!noRefresh) this.refresh(noRefresh);

        if (this.savedZoom) {
            newZS -= this.zoomMin;
            oldZS -= this.zoomMin;
            var difToActive = newZS - oldZS;
            var difToSaved = newZS - this.savedZoom;
            if (Math.abs(difToActive) > Math.abs(difToSaved)) {
                this.isSnapZooming = !this.isSnapZooming;
                this.savedZoom = oldZS;
            }
        } else {
            this.isSnapZooming = false;
            this.savedZoom = null;
        }
    } else {
        var viewCenter = (this.viewStart + this.viewEnd) / 2;

        for (var i = 0; i < this.tiers.length; ++i) {
            var offset = (this.viewStart - this.tiers[i].norigin) * this.scale;
            this.tiers[i].viewportHolder.style.left = '' + ((-offset | 0) - 1000) + 'px';
            this.tiers[i].drawOverlay();
        }
    }

    this.notifyLocation();

    this.spaceCheck(noRefresh);
    if (this.instrumentActivity) this.activityStartTime = Date.now() | 0;
    return callback();
};

Browser.prototype.setCenterLocation = function (newChr, newCenterLoc) {
    var halfWidth = (this.viewEnd - this.viewStart) / 2,
        newMin = newCenterLoc - halfWidth,
        newMax = newCenterLoc + halfWidth;
    this.setLocation(newChr, newMin, newMax);
};

Browser.prototype.pingActivity = function () {
    if (!this.instrumentActivity || !this.activityStartTime) return;

    var activity = 0;
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        if (this.tiers[ti].loaderButton.style.display !== 'none') ++activity;
    }

    if (activity == 0) {
        var now = Date.now() | 0;
        console.log('Loading took ' + (now - this.activityStartTime) + 'ms');
        this.activityStartTime = null;
    }
};

Browser.prototype.addInitListener = function (handler) {
    this.initListeners.push(handler);
};

Browser.prototype.addFeatureListener = function (handler, opts) {
    opts = opts || {};
    this.featureListeners.push(handler);
};

Browser.prototype.removeFeatureListener = function (handler, opts) {
    var idx = arrayIndexOf(this.featureListeners, handler);
    if (idx >= 0) {
        this.featureListeners.splice(idx, 1);
    }
};

Browser.prototype.notifyFeature = function (ev, feature, hit, tier) {
    for (var fli = 0; fli < this.featureListeners.length; ++fli) {
        try {
            if (this.featureListeners[fli](ev, feature, hit, tier)) return;
        } catch (ex) {
            console.log(ex.stack);
        }
    }
};

Browser.prototype.addFeatureHoverListener = function (handler, opts) {
    opts = opts || {};
    this.featureHoverListeners.push(Object.assign({ handler: handler }, opts));
};

Browser.prototype.removeFeatureHoverListener = function (handler, opts) {
    for (var i = 0; i < this.featureHoverListeners.length; ++i) {
        if (this.featureHoverListeners[i].handler == handler) {
            this.featureHoverListeners.splice(idx, 1);
            return;
        }
    }
};

Browser.prototype.notifyImmediateFeatureHover = function (ev, feature, hit, tier) {
    for (var fli = 0; fli < this.featureHoverListeners.length; ++fli) {
        if (this.featureHoverListeners[fli].immediate) {
            try {
                this.featureHoverListeners[fli].handler(ev, feature, hit, tier);
            } catch (ex) {
                console.log(ex.stack);
            }
        }
    }
};

Browser.prototype.notifyDeferredFeatureHover = function (ev, feature, hit, tier) {
    for (var fli = 0; fli < this.featureHoverListeners.length; ++fli) {
        if (!this.featureHoverListeners[fli].immediate) {
            try {
                this.featureHoverListeners[fli].handler(ev, feature, hit, tier);
            } catch (ex) {
                console.log(ex.stack);
            }
        }
    }
};

Browser.prototype.addViewListener = function (handler, opts) {
    opts = opts || {};
    this.viewListeners.push(handler);
};

Browser.prototype.removeViewListener = function (handler, opts) {
    var idx = arrayIndexOf(this.viewListeners, handler);
    if (idx >= 0) {
        this.viewListeners.splice(idx, 1);
    }
};

Browser.prototype.notifyLocation = function () {
    var nvs = Math.max(1, this.viewStart | 0);
    var nve = this.viewEnd | 0;
    if (this.currentSeqMax > 0 && nve > this.currentSeqMax) nve = this.currentSeqMax;

    for (var lli = 0; lli < this.viewListeners.length; ++lli) {
        try {
            this.viewListeners[lli](this.chr, nvs, nve, this.zoomSliderValue, { current: this.zoomSliderValue,
                alternate: this.savedZoom + this.zoomMin || this.zoomMin,
                isSnapZooming: this.isSnapZooming,
                min: this.zoomMin,
                max: this.zoomMax }, this.viewStart, this.viewEnd);
        } catch (ex) {
            console.log(ex.stack);
        }
    }
};

Browser.prototype.addTierListener = function (handler) {
    this.tierListeners.push(handler);
};

Browser.prototype.removeTierListener = function (handler) {
    var idx = arrayIndexOf(this.tierListeners, handler);
    if (idx >= 0) {
        this.tierListeners.splice(idx, 1);
    }
};

Browser.prototype.notifyTier = function (status, tier) {
    for (var tli = 0; tli < this.tierListeners.length; ++tli) {
        try {
            this.tierListeners[tli](status, tier);
        } catch (ex) {
            console.log(ex.stack);
        }
    }
};

Browser.prototype.addRegionSelectListener = function (handler) {
    this.regionSelectListeners.push(handler);
};

Browser.prototype.removeRegionSelectListener = function (handler) {
    var idx = arrayIndexOf(this.regionSelectListeners, handler);
    if (idx >= 0) {
        this.regionSelectListeners.splice(idx, 1);
    }
};

Browser.prototype.notifyRegionSelect = function (chr, min, max) {
    for (var rli = 0; rli < this.regionSelectListeners.length; ++rli) {
        try {
            this.regionSelectListeners[rli](chr, min, max);
        } catch (ex) {
            console.log(ex.stack);
        }
    }
};

Browser.prototype.highlightRegion = function (chr, min, max) {
    var thisB = this;

    if (chr == this.chr) {
        return this._highlightRegion(chr, min, max);
    }

    var ss = this.getSequenceSource();
    if (!ss) {
        throw 'Need a sequence source';
    }

    ss.getSeqInfo(chr, function (si) {
        if (!si) {
            var altChr;
            if (chr.indexOf('chr') == 0) {
                altChr = chr.substr(3);
            } else {
                altChr = 'chr' + chr;
            }
            ss.getSeqInfo(altChr, function (si2) {
                if (!si2) {
                    // Fail silently.
                } else {
                    return thisB._highlightRegion(altChr, min, max);
                }
            });
        } else {
            return thisB._highlightRegion(chr, min, max);
        }
    });
};

Browser.prototype._highlightRegion = function (chr, min, max) {
    for (var hi = 0; hi < this.highlights.length; ++hi) {
        var h = this.highlights[hi];
        if (h.chr == chr && h.min == min && h.max == max) return;
    }

    this.highlights.push(new Region(chr, min, max));
    var visStart = this.viewStart - 1000 / this.scale;
    var visEnd = this.viewEnd + 1000 / this.scale;
    if ((chr == this.chr || chr == 'chr' + this.chr) && min < visEnd && max > visStart) {
        this.drawOverlays();
    }

    this.notifyLocation();
};

Browser.prototype.clearHighlights = function () {
    this.highlights = [];
    this.drawOverlays();
    this.notifyLocation();
};

Browser.prototype.drawOverlays = function () {
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        this.tiers[ti].drawOverlay();
    }
};

Browser.prototype.featuresInRegion = function (chr, min, max) {
    var features = [];
    if (chr !== this.chr) {
        return [];
    }

    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var fl = this.tiers[ti].currentFeatures || [];
        for (var fi = 0; fi < fl.length; ++fi) {
            var f = fl[fi];
            if (f.min <= max && f.max >= min) {
                features.push(f);
            }
        }
    }
    return features;
};

Browser.prototype.getSelectedTier = function () {
    if (this.selectedTiers.length > 0) return this.selectedTiers[0];else return -1;
};

Browser.prototype.setSelectedTier = function (t) {
    if (t == null) {
        this.selectedTiers = [];
    } else {
        this.selectedTiers = [t];
    }
    this.markSelectedTiers();
    this.notifyTierSelection();
};

Browser.prototype.markSelectedTiers = function () {
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var button = this.tiers[ti].nameButton;

        if (this.selectedTiers.indexOf(ti) >= 0) {
            button.classList.add('active');
        } else {
            button.classList.remove('active');
        }
    }
    if (this.selectedTiers.length > 0) {
        var browserMid = this.browserHolder.offsetTop + this.browserHolder.offsetHeight / 2;
        if (browserMid > document.body.scrollTop && browserMid + 100 < document.body.scrollTop + window.innerHeight) this.browserHolder.focus();
    }
};

Browser.prototype.addTierSelectionListener = function (handler) {
    this.tierSelectionListeners.push(handler);
};

Browser.prototype.removeTierSelectionListener = function (handler) {
    var idx = arrayIndexOf(this.tierSelectionListeners, handler);
    if (idx >= 0) {
        this.tierSelectionListeners.splice(idx, 1);
    }
};

Browser.prototype.notifyTierSelection = function () {
    for (var fli = 0; fli < this.tierSelectionListeners.length; ++fli) {
        try {
            this.tierSelectionListeners[fli](this.selectedTiers);
        } catch (ex) {
            console.log(ex.stack);
        }
    }
};

Browser.prototype.addTierSelectionWrapListener = function (f) {
    this.tierSelectionWrapListeners.push(f);
};

Browser.prototype.removeTierSelectionWrapListener = function (handler) {
    var idx = arrayIndexOf(this.tierSelectionWrapListeners, handler);
    if (idx >= 0) {
        this.tierSelectionWrapListeners.splice(idx, 1);
    }
};

Browser.prototype.notifyTierSelectionWrap = function (i) {
    for (var fli = 0; fli < this.tierSelectionWrapListeners.length; ++fli) {
        try {
            this.tierSelectionWrapListeners[fli](i);
        } catch (ex) {
            console.log(ex.stack);
        }
    }
};

Browser.prototype.positionRuler = function () {
    var display = 'none';
    var left = '';
    var right = '';

    if (this.rulerLocation == 'center') {
        display = 'block';
        left = '' + (this.featurePanelWidth / 2 | 0) + 'px';
    } else if (this.rulerLocation == 'left') {
        display = 'block';
        left = '0px';
    } else if (this.rulerLocation == 'right') {
        display = 'block';
        right = '0px';
    } else {
        display = 'none';
    }

    this.ruler.style.display = display;
    this.ruler.style.left = left;
    this.ruler.style.right = right;

    if (this.singleBaseHighlight) {
        this.ruler2.style.display = 'block';
        this.ruler2.style.borderWidth = '1px';
        if (this.scale < 1) {
            this.ruler2.style.width = '0px';
            this.ruler2.style.borderRightWidth = '0px';
        } else {
            this.ruler2.style.width = this.scale + 'px';
            this.ruler2.style.borderRightWidth = '1px';
        }
        // Position accompanying single base location text
        this.locSingleBase.style.visibility = 'visible';
        var centreOffset = this.featurePanelWidth / 2 - this.locSingleBase.offsetWidth / 2 + this.ruler2.offsetWidth / 2;
        this.locSingleBase.style.left = '' + (centreOffset | 0) + 'px';
    } else {
        this.locSingleBase.style.visibility = 'hidden';
        this.ruler2.style.width = '1px';
        this.ruler2.style.borderWidth = '0px';
        this.ruler2.style.display = this.rulerLocation == 'center' ? 'none' : 'block';
    }

    this.ruler2.style.left = '' + (this.featurePanelWidth / 2 | 0) + 'px';

    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var tier = this.tiers[ti];
        var q = tier.quantOverlay;

        var quant;
        if (tier.subtiers && tier.subtiers.length > 0) quant = tier.subtiers[0].quant;

        if (q) {
            q.style.display = quant ? display : 'none';
            q.style.left = left;
            q.style.right = right;
        }
    }
};

Browser.prototype.featureDoubleClick = function (hit, rx, ry) {
    if (!hit || hit.length == 0) return;

    var f = hit[hit.length - 1];

    if (!f.min || !f.max) {
        return;
    }

    var fstart = ((f.min | 0) - (this.viewStart | 0)) * this.scale;
    var fwidth = (f.max - f.min + 1) * this.scale;

    var newMid = ((f.min | 0) + (f.max | 0)) / 2;
    if (fwidth > 10) {
        var frac = 1.0 * (rx - fstart) / fwidth;
        if (frac < 0.3) {
            newMid = f.min | 0;
        } else if (frac > 0.7) {
            newMid = (f.max | 0) + 1;
        }
    }

    var width = this.viewEnd - this.viewStart;
    this.setLocation(null, newMid - width / 2, newMid + width / 2);
};

Browser.prototype.zoomForScale = function (scale) {
    var ssScale;
    if (scale > this.highZoomThreshold) {
        ssScale = 'high';
    } else if (scale > this.mediumZoomThreshold) {
        ssScale = 'medium';
    } else {
        ssScale = 'low';
    }
    return ssScale;
};

Browser.prototype.zoomForCurrentScale = function () {
    return this.zoomForScale(this.scale);
};

Browser.prototype.updateHeight = function () {
    var tierTotal = 0;
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        tierTotal += this.tiers[ti].currentHeight || 30;
    }this.ruler.style.height = '' + tierTotal + 'px';
    this.ruler2.style.height = '' + tierTotal + 'px';
    this.browserHolder.style.display = 'block';
    this.browserHolder.style.display = '-webkit-flex';
    this.browserHolder.style.display = 'flex';
    // this.svgHolder.style.maxHeight = '' + Math.max(tierTotal, 500) + 'px';
};

Browser.prototype.scrollArrowKey = function (ev, dir) {
    if (this.reverseKeyScrolling) dir = -dir;

    if (ev.ctrlKey || ev.metaKey) {
        var fedge = false;
        if (ev.shiftKey) {
            fedge = true;
        }

        this.leap(dir, fedge);
    } else if (this.scale > 1) {
        // per-base scrolling mode, tries to perfectly center.
        var mid = (this.viewStart + this.viewEnd) / 2;
        var err = mid - Math.round(mid);
        var n = 1;
        if (ev.shiftKey) n *= 10;
        if (dir > 0) {
            n = -n;
            n -= err;
            if (err > 0) n += 1;
        } else {
            n -= err;
            if (err < 0) n -= 1;
        }
        this.setLocation(null, this.viewStart + n, this.viewEnd + n);
    } else {
        this.move(ev.shiftKey ? 100 * dir : 25 * dir);
    }
};

Browser.prototype.leap = function (dir, fedge) {
    var thisB = this;
    var pos = (thisB.viewStart + thisB.viewEnd + 1) / 2 | 0;
    if (dir > 0 && thisB.viewStart <= 1) {
        pos -= 100000000;
    } else if (dir < 0 && thisB.viewEnd >= thisB.currentSeqMax) {
        pos += 100000000;
    }

    var st = thisB.getSelectedTier();
    if (st < 0) return;
    var tier = thisB.tiers[st];

    if (tier && (tier.featureSource && this.sourceAdapterIsCapable(tier.featureSource, 'quantLeap') && typeof tier.quantLeapThreshold == 'number' || tier.featureSource && this.sourceAdapterIsCapable(tier.featureSource, 'leap'))) {
        tier.findNextFeature(thisB.chr, pos, -dir, fedge, function (nxt) {
            if (nxt) {
                var nmin = nxt.min;
                var nmax = nxt.max;
                if (fedge) {
                    if (dir > 0) {
                        if (nmin > pos + 1) {
                            nmax = nmin;
                        } else {
                            nmax++;
                            nmin = nmax;
                        }
                    } else {
                        if (nmax < pos - 1) {
                            nmax++;
                            nmin = nmax;
                        } else {
                            nmax = nmin;
                        }
                    }
                }
                var wid = thisB.viewEnd - thisB.viewStart + 1;
                if (parseFloat(wid / 2) == parseInt(wid / 2)) {
                    wid--;
                }
                var newStart = (nmin + nmax - wid) / 2 + 1;
                var newEnd = newStart + wid - 1;
                var pos2 = pos;
                thisB.setLocation(nxt.segment, newStart, newEnd);
            } else {
                alert('no next feature'); // FIXME better reporting would be nice!
            }
        });
    } else {
        this.move(100 * dir);
    }
};

Browser.prototype.nameForCoordSystem = function (cs) {
    var primary = null,
        ucsc = null;
    if (this.assemblyNamePrimary) {
        primary = '' + cs.auth;
        if (typeof cs.version !== 'undefined') primary += cs.version;
    }
    if (this.assemblyNameUcsc) {
        ucsc = cs.ucscName;
    }
    if (primary != null && ucsc != null) return primary + '/' + ucsc;else return primary || ucsc || 'unknown';
};

Browser.prototype.makeLoader = function (size) {
    size = size || 16;
    var retina = window.devicePixelRatio > 1;
    if (size < 20) {
        return makeElement('img', null, { src: this.resolveURL('$$img/spinner_' + (retina ? 16 : 32) + '.gif'), width: '16', height: '16' });
    } else {
        return makeElement('img', null, { src: this.resolveURL('$$img/spinner_' + (retina ? 24 : 48) + '.gif'), width: '24', height: '24' });
    }
};

Browser.prototype.canFetchPlainHTTP = function () {
    var self = this;
    if (!this._plainHTTPPromise) {
        var worker = this.getWorker();
        if (worker) {
            this._plainHTTPPromise = new Promise(function (resolve, reject) {
                worker.postCommand({ command: 'textxhr',
                    uri: self.httpCanaryURL }, function (result, err) {
                    if (result) {
                        resolve(true);
                    } else {
                        resolve(false);
                    }
                });
            });
        } else {
            this._plainHTTPPromise = new Promise(function (resolve, reject) {
                textXHR(self.httpCanaryURL, function (result, err) {
                    if (result) {
                        resolve(true);
                    } else {
                        resolve(false);
                    }
                }, { timeout: 2000 });
            });
        }
    }
    return this._plainHTTPPromise;
};

Browser.prototype.getWorker = function () {
    if (!this.useFetchWorkers || !this.fetchWorkers || this.fetchWorkers.length == 0) return null;

    if (this.nextWorker >= this.fetchWorkers.length) this.nextWorker = 0;
    return this.fetchWorkers[this.nextWorker++];
};

Browser.prototype.registerResolver = function (resolver) {
    var id = 'res' + ++this.resolverSeed;
    this.resolvers[id] = resolver;
    return id;
};

function FetchWorker(browser, worker) {
    var thisB = this;
    this.tagSeed = 0;
    this.callbacks = {};
    this.browser = browser;
    this.worker = worker;

    this.worker.onmessage = function (ev) {
        var data = ev.data;

        if (!data.cmd) {
            var cb = thisB.callbacks[data.tag];
            if (cb) {
                cb(data.result, data.error);
                delete thisB.callbacks[data.tag];
            }
        } else if (data.cmd == 'resolve') {
            var resolver = thisB.browser.resolvers[data.resolver];
            if (resolver) {
                resolver(data.url).then(function (url) {
                    thisB.worker.postMessage({
                        tag: data.tag,
                        url: url
                    });
                }).catch(function (err) {
                    console.log(err);
                    thisB.worker.postMessage({
                        tag: data.tag,
                        err: err.toString()
                    });
                });
            } else {
                console.log('No resolver ' + data.resolver);
            }
        } else {
            console.log('Bad worker callback ' + data.cmd);
        }
    };
}

function makeFetchWorker(browser) {
    var wurl = browser.resolveURL(browser.workerPath);
    if (wurl.indexOf('//') == 0) {
        var proto = window.location.protocol;
        if (proto == 'https:') wurl = 'https:' + wurl;else wurl = 'http:' + wurl;
    }

    var wscript = 'importScripts("' + wurl + '?version=' + VERSION + '");';
    var wblob = new Blob([wscript], { type: 'application/javascript' });

    return new Promise(function (resolve, reject) {
        var worker = new Worker(URL.createObjectURL(wblob));

        worker.onmessage = function (ev) {
            if (ev.data.tag === 'init') {
                console.log('Worker initialized');
                resolve(new FetchWorker(browser, worker));
            }
        };

        worker.onerror = function (ev) {
            reject(ev.message);
        };
    });
}

FetchWorker.prototype.postCommand = function (cmd, callback, transfer) {
    var tag = 'x' + ++this.tagSeed;
    cmd.tag = tag;
    this.callbacks[tag] = callback;
    this.worker.postMessage(cmd, transfer);
};

FetchWorker.prototype.terminate = function () {
    this.worker.terminate();
};

if (typeof module !== 'undefined') {
    module.exports = {
        Browser: Browser
    };

    // Required because they add stuff to Browser.prototype
    require('./browser-ui');
    require('./track-adder');
    require('./feature-popup');
    require('./tier-actions');
    require('./domui');
    require('./search');

    var sa = require('./sourceadapters');
    var TwoBitSequenceSource = sa.TwoBitSequenceSource;
    var EnsemblSequenceSource = sa.EnsemblSequenceSource;
    var DASSequenceSource = sa.DASSequenceSource;

    var KnownSpace = require('./kspace').KnownSpace;

    var DASRegistry = require('./das').DASRegistry;
}

function SourceCache() {
    this.sourcesByURI = {};
}

SourceCache.prototype.get = function (conf) {
    var scb = this.sourcesByURI[sourceDataURI(conf)];
    if (scb) {
        for (var si = 0; si < scb.configs.length; ++si) {
            if (sourcesAreEqualModuloStyle(scb.configs[si], conf)) {
                return scb.sources[si];
            }
        }
    }
};

SourceCache.prototype.put = function (conf, source) {
    var uri = sourceDataURI(conf);
    var scb = this.sourcesByURI[uri];
    if (!scb) {
        scb = { configs: [], sources: [] };
        this.sourcesByURI[uri] = scb;
    }
    scb.configs.push(conf);
    scb.sources.push(source);
};

},{"./browser-ui":5,"./chainset":7,"./das":10,"./default-renderer":11,"./domui":12,"./dummy-renderer":13,"./feature-popup":21,"./kspace":25,"./multi-renderer":28,"./numformats":29,"./search":34,"./sha1":37,"./sourceadapters":38,"./sourcecompare":39,"./sub-renderer":42,"./thub":48,"./tier":51,"./tier-actions":49,"./track-adder":52,"./utils":55,"./version":57,"es6-promise":59}],7:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// chainset.js: liftover support
//

"use strict";

if (typeof require !== 'undefined') {
    var das = require('./das');
    var DASSource = das.DASSource;
    var DASSegment = das.DASSegment;

    var utils = require('./utils');
    var pusho = utils.pusho;
    var shallowCopy = utils.shallowCopy;

    var parseCigar = require('./cigar').parseCigar;

    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;

    var bbi = require('./bigwig');
    var makeBwg = bbi.makeBwg;

    var Promise = require('es6-promise').Promise;
}

function Chainset(conf, srcTag, destTag, coords) {
    if (typeof conf == 'string') {
        this.uri = conf;
        this.srcTag = srcTag;
        this.destTag = destTag;
        this.coords = coords;
    } else {
        this.uri = conf.uri;
        this.srcTag = conf.srcTag;
        this.destTag = conf.destTag;
        this.coords = shallowCopy(conf.coords);
        this.type = conf.type;
        this.credentials = conf.credentials;
    }

    this.chainsBySrc = {};
    this.chainsByDest = {};
    this.postFetchQueues = {};
    this.fetchedTiles = {};
    this.granularity = 1000000; // size in bases of tile to fetch

    if (this.type == 'bigbed') {
        this.chainFetcher = new BBIChainFetcher(this.uri, this.credentials);
    } else if (this.type == 'alias') {
        this.chainFetcher = new AliasChainFetcher(conf);
    } else {
        this.chainFetcher = new DASChainFetcher(this.uri, this.srcTag, this.destTag);
    }
};

Chainset.prototype.exportConfig = function () {
    return {
        uri: this.uri,
        srcTag: this.srcTag,
        destTag: this.destTag,
        coords: this.coords,
        type: this.type,
        credentials: this.credentials
    };
};

Chainset.prototype.mapPoint = function (chr, pos) {
    var chains = this.chainsBySrc[chr] || [];
    for (var ci = 0; ci < chains.length; ++ci) {
        var c = chains[ci];
        if (pos >= c.srcMin && pos <= c.srcMax) {
            var cpos;
            if (c.srcOri == '-') {
                cpos = c.srcMax - pos;
            } else {
                cpos = pos - c.srcMin;
            }
            var blocks = c.blocks;
            for (var bi = 0; bi < blocks.length; ++bi) {
                var b = blocks[bi];
                var bSrc = b[0];
                var bDest = b[1];
                var bSize = b[2];
                if (cpos >= bSrc && cpos <= bSrc + bSize) {
                    var apos = cpos - bSrc;

                    var dpos;
                    if (c.destOri == '-') {
                        dpos = c.destMax - bDest - apos;
                    } else {
                        dpos = apos + bDest + c.destMin;
                    }
                    return { seq: c.destChr, pos: dpos, flipped: c.srcOri != c.destOri };
                }
            }
        }
    }
    return null;
};

Chainset.prototype.mapSegment = function (chr, min, max) {
    var chains = this.chainsBySrc[chr] || [];
    var mappings = [];
    for (var ci = 0; ci < chains.length; ++ci) {
        var c = chains[ci];
        if (max >= c.srcMin && min <= c.srcMax) {
            var cmin, cmax;
            if (c.srcOri == '-') {
                cmin = c.srcMax - max;
                cmax = c.srcMax - min;
            } else {
                cmin = min - c.srcMin;
                cmax = max - c.srcMin;
            }
            var blocks = c.blocks;
            for (var bi = 0; bi < blocks.length; ++bi) {
                var b = blocks[bi];
                var bSrc = b[0];
                var bDest = b[1];
                var bSize = b[2];
                if (cmax >= bSrc && cmin <= bSrc + bSize) {
                    var m = {
                        segment: c.destChr,
                        flipped: c.srcOri == '-' ^ c.destOri == '-' };

                    if (c.destOri == '-') {
                        if (cmin >= bSrc) {
                            m.max = c.destMax - bDest - cmin + bSrc;
                        } else {
                            m.max = c.destMax - bDest;
                            m.partialMax = bSrc - cmin;
                        }
                        if (cmax <= bSrc + bSize) {
                            m.min = c.destMax - bDest - cmax + bSrc;
                        } else {
                            m.min = c.destMax - bDest - bSize;
                            m.partialMin = cmax - bSrc - bSize;
                        }
                    } else {
                        if (cmin >= bSrc) {
                            m.min = c.destMin + bDest + cmin - bSrc;
                        } else {
                            m.min = c.destMin + bDest;
                            m.partialMin = bSrc - cmin;
                        }
                        if (cmax <= bSrc + bSize) {
                            m.max = c.destMin + bDest + cmax - bSrc;
                        } else {
                            m.max = c.destMin + bDest + bSize;
                            m.partialMax = cmax - bSrc - bSize;
                        }
                    }
                    mappings.push(m);
                }
            }
        }
    }
    return mappings;
};

Chainset.prototype.unmapPoint = function (chr, pos) {
    var chains = this.chainsByDest[chr] || [];
    for (var ci = 0; ci < chains.length; ++ci) {
        var c = chains[ci];
        if (pos >= c.destMin && pos <= c.destMax) {
            var cpos;
            if (c.srcOri == '-') {
                cpos = c.destMax - pos;
            } else {
                cpos = pos - c.destMin;
            }

            var blocks = c.blocks;
            for (var bi = 0; bi < blocks.length; ++bi) {
                var b = blocks[bi];
                var bSrc = b[0];
                var bDest = b[1];
                var bSize = b[2];

                if (cpos >= bDest && cpos <= bDest + bSize) {
                    var apos = cpos - bDest;

                    var dpos = apos + bSrc + c.srcMin;
                    var dpos;
                    if (c.destOri == '-') {
                        dpos = c.srcMax - bSrc - apos;
                    } else {
                        dpos = apos + bSrc + c.srcMin;
                    }
                    return { seq: c.srcChr, pos: dpos, flipped: c.srcOri != c.destOri };
                }
            }
            // return null;
        }
    }
    return null;
};

Chainset.prototype.sourceBlocksForRange = function (chr, min, max, callback) {
    var STATE_PENDING = 1;
    var STATE_FETCHED = 2;

    var thisCS = this;
    var minTile = min / this.granularity | 0;
    var maxTile = max / this.granularity | 0;

    var needsNewOrPending = false;
    var needsNewFetch = false;
    for (var t = minTile; t <= maxTile; ++t) {
        var tn = chr + '_' + t;
        if (this.fetchedTiles[tn] != STATE_FETCHED) {
            needsNewOrPending = true;
            if (this.fetchedTiles[tn] != STATE_PENDING) {
                this.fetchedTiles[tn] = STATE_PENDING;
                needsNewFetch = true;
            }
        }
    }

    if (needsNewOrPending) {
        if (!this.postFetchQueues[chr]) {
            this.chainFetcher.fetchChains(chr, minTile * this.granularity, (maxTile + 1) * this.granularity - 1).then(function (chains) {
                if (!thisCS.chainsByDest) thisCS.chainsByDest[chr] = [];
                for (var ci = 0; ci < chains.length; ++ci) {
                    var chain = chains[ci];

                    {
                        var cbs = thisCS.chainsBySrc[chain.srcChr];
                        if (!cbs) {
                            thisCS.chainsBySrc[chain.srcChr] = [chain];
                        } else {
                            var present = false;
                            for (var oci = 0; oci < cbs.length; ++oci) {
                                var oc = cbs[oci];
                                if (oc.srcMin == chain.srcMin && oc.srcMax == chain.srcMax) {
                                    present = true;
                                    break;
                                }
                            }
                            if (!present) cbs.push(chain);
                        }
                    }

                    {
                        var cbd = thisCS.chainsByDest[chain.destChr];
                        if (!cbd) {
                            thisCS.chainsByDest[chain.destChr] = [chain];
                        } else {
                            var present = false;
                            for (var oci = 0; oci < cbd.length; ++oci) {
                                var oc = cbd[oci];
                                if (oc.destMin == chain.destMin && oc.destMax == chain.destMax) {
                                    present = true;
                                    break;
                                }
                            }
                            if (!present) cbd.push(chain);
                        }
                    }
                }
                for (var t = minTile; t <= maxTile; ++t) {
                    var tn = chr + '_' + t;
                    thisCS.fetchedTiles[tn] = STATE_FETCHED;
                }
                if (thisCS.postFetchQueues[chr]) {
                    var pfq = thisCS.postFetchQueues[chr];
                    for (var i = 0; i < pfq.length; ++i) {
                        pfq[i]();
                    }
                    thisCS.postFetchQueues[chr] = null;
                }
            }).catch(function (err) {
                console.log(err);
            });
        }

        pusho(this.postFetchQueues, chr, function () {
            // Will either succeed if the tiles that are needed have already been fetched,
            // or queue up a new fetch.

            thisCS.sourceBlocksForRange(chr, min, max, callback);
        });
    } else {
        var srcBlocks = [];
        var chains = this.chainsByDest[chr] || [];
        for (var ci = 0; ci < chains.length; ++ci) {
            var c = chains[ci];
            if (min <= c.destMax && max >= c.destMin) {
                var cmin, cmax;
                if (c.srcOri == '-') {
                    cmin = c.destMax - max;
                    cmax = c.destMax - min;
                } else {
                    cmin = min - c.destMin;
                    cmax = max - c.destMin;
                }

                var blocks = c.blocks;
                for (var bi = 0; bi < blocks.length; ++bi) {
                    var b = blocks[bi];
                    var bSrc = b[0];
                    var bDest = b[1];
                    var bSize = b[2];

                    if (cmax >= bDest && cmin <= bDest + bSize) {
                        var amin = Math.max(cmin, bDest) - bDest;
                        var amax = Math.min(cmax, bDest + bSize) - bDest;

                        if (c.destOri == '-') {
                            srcBlocks.push(new DASSegment(c.srcChr, c.srcMax - bSrc - amax, c.srcMax - bSrc - amin));
                        } else {
                            srcBlocks.push(new DASSegment(c.srcChr, c.srcMin + amin + bSrc, c.srcMin + amax + bSrc));
                        }
                    }
                }
            }
        }
        callback(srcBlocks);
    }
};

function DASChainFetcher(uri, srcTag, destTag) {
    this.source = new DASSource(uri);
    this.srcTag = srcTag;
    this.destTag = destTag;
}

DASChainFetcher.prototype.fetchChains = function (chr, _min, _max) {
    var thisCS = this;

    return new Promise(function (resolve, reject) {
        thisCS.source.alignments(chr, {}, function (aligns) {
            var chains = [];

            for (var ai = 0; ai < aligns.length; ++ai) {
                var aln = aligns[ai];
                for (var bi = 0; bi < aln.blocks.length; ++bi) {
                    var block = aln.blocks[bi];
                    var srcSeg, destSeg;
                    for (var si = 0; si < block.segments.length; ++si) {
                        var seg = block.segments[si];
                        var obj = aln.objects[seg.object];
                        if (obj.dbSource === thisCS.srcTag) {
                            srcSeg = seg;
                        } else if (obj.dbSource === thisCS.destTag) {
                            destSeg = seg;
                        }
                    }
                    if (srcSeg && destSeg) {
                        var chain = {
                            srcChr: aln.objects[srcSeg.object].accession,
                            srcMin: srcSeg.min | 0,
                            srcMax: srcSeg.max | 0,
                            srcOri: srcSeg.strand,
                            destChr: aln.objects[destSeg.object].accession,
                            destMin: destSeg.min | 0,
                            destMax: destSeg.max | 0,
                            destOri: destSeg.strand,
                            blocks: []
                        };

                        var srcops = parseCigar(srcSeg.cigar),
                            destops = parseCigar(destSeg.cigar);

                        var srcOffset = 0,
                            destOffset = 0;
                        var srci = 0,
                            desti = 0;
                        while (srci < srcops.length && desti < destops.length) {
                            if (srcops[srci].op == 'M' && destops[desti].op == 'M') {
                                var blockLen = Math.min(srcops[srci].cnt, destops[desti].cnt);
                                chain.blocks.push([srcOffset, destOffset, blockLen]);
                                if (srcops[srci].cnt == blockLen) {
                                    ++srci;
                                } else {
                                    srcops[srci].cnt -= blockLen;
                                }
                                if (destops[desti].cnt == blockLen) {
                                    ++desti;
                                } else {
                                    destops[desti] -= blockLen;
                                }
                                srcOffset += blockLen;
                                destOffset += blockLen;
                            } else if (srcops[srci].op == 'I') {
                                destOffset += srcops[srci++].cnt;
                            } else if (destops[desti].op == 'I') {
                                srcOffset += destops[desti++].cnt;
                            }
                        }

                        chains.push(chain);
                    }
                }
            }
            resolve(chains);
        });
    });
};

function BBIChainFetcher(uri, credentials) {
    var self = this;
    this.uri = uri;
    this.credentials = credentials;

    this.bwg = new Promise(function (resolve, reject) {
        makeBwg(new URLFetchable(self.uri, { credentials: self.credentials,
            resolver: self.resolver }), function (bwg, err) {
            if (bwg) {
                resolve(bwg);
            } else {
                reject(err);
            }
        });
    });

    this.bwg.then(function (bwg, err) {
        if (err) console.log(err);
    });
}

function pi(x) {
    return parseInt(x);
}

function cleanChr(c) {
    if (c.indexOf('chr') == 0) return c.substr(3);else return c;
}

function bbiFeatureToChain(feature) {
    var chain = {
        srcChr: cleanChr(feature.srcChrom),
        srcMin: parseInt(feature.srcStart),
        srcMax: parseInt(feature.srcEnd),
        srcOri: feature.srcOri,
        destChr: cleanChr(feature.segment),
        destMin: feature.min - 1, // Convert back from bigbed parser
        destMax: feature.max,
        destOri: feature.ori,
        blocks: []
    };
    var srcStarts = feature.srcStarts.split(',').map(pi);
    var destStarts = feature.destStarts.split(',').map(pi);
    var blockLengths = feature.blockLens.split(',').map(pi);
    for (var bi = 0; bi < srcStarts.length; ++bi) {
        chain.blocks.push([srcStarts[bi], destStarts[bi], blockLengths[bi]]);
    }

    return chain;
}

BBIChainFetcher.prototype.fetchChains = function (chr, min, max) {
    return this.bwg.then(function (bwg, err) {
        if (!bwg) throw Error("No BWG");

        return new Promise(function (resolve, reject) {
            bwg.getUnzoomedView().readWigData(chr, min, max, function (feats) {
                resolve(feats.map(bbiFeatureToChain));
            });
        });
    });
};

function AliasChainFetcher(conf) {
    this.conf = conf;
    this.forwardAliases = {};
    var sa = conf.sequenceAliases || [];
    for (var ai = 0; ai < sa.length; ++ai) {
        var al = sa[ai];
        if (al.length < 2) continue;

        var fa = [];
        for (var i = 0; i < al.length - 1; ++i) {
            fa.push(al[i]);
        }this.forwardAliases[al[al.length - 1]] = fa;
    }
}

AliasChainFetcher.prototype.fetchChains = function (chr, min, max) {
    var resp = [];
    var fa = this.forwardAliases[chr] || [];
    for (var i = 0; i < fa.length; ++i) {
        resp.push({
            srcChr: fa[i],
            srcMin: 1,
            srcMax: 1000000000,
            srcOri: '+',
            destChr: chr,
            destMin: 1,
            destMax: 1000000000,
            destOri: '+',
            blocks: [[1, 1, 1000000000]]
        });
    }

    return Promise.resolve(resp);
};

if (typeof module !== 'undefined') {
    module.exports = {
        Chainset: Chainset
    };
}

},{"./bigwig":3,"./bin":4,"./cigar":8,"./das":10,"./utils":55,"es6-promise":59}],8:[function(require,module,exports){
'use strict';

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// cigar.js: liftover support
//

var CIGAR_REGEXP = new RegExp('([0-9]*)([MIDS])', 'g');

function parseCigar(cigar) {
    var cigops = [];
    var match;
    while ((match = CIGAR_REGEXP.exec(cigar)) != null) {
        var count = match[1];
        if (count.length == 0) {
            count = 1;
        }
        cigops.push({ cnt: count | 0, op: match[2] });
    }
    return cigops;
}

if (typeof module !== 'undefined') {
    module.exports = {
        parseCigar: parseCigar
    };
}

},{}],9:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// color.js
//

"use strict";

function DColour(red, green, blue, name) {
    this.red = red | 0;
    this.green = green | 0;
    this.blue = blue | 0;
    if (name) {
        this.name = name;
    }
}

DColour.prototype.toSvgString = function () {
    if (!this.name) {
        this.name = "rgb(" + this.red + "," + this.green + "," + this.blue + ")";
    }

    return this.name;
};

function hex2(x) {
    var y = '00' + x.toString(16);
    return y.substring(y.length - 2);
}

DColour.prototype.toHexString = function () {
    return '#' + hex2(this.red) + hex2(this.green) + hex2(this.blue);
};

var palette = {
    red: new DColour(255, 0, 0, 'red'),
    green: new DColour(0, 255, 0, 'green'),
    blue: new DColour(0, 0, 255, 'blue'),
    yellow: new DColour(255, 255, 0, 'yellow'),
    white: new DColour(255, 255, 255, 'white'),
    black: new DColour(0, 0, 0, 'black'),
    gray: new DColour(180, 180, 180, 'gray'),
    grey: new DColour(180, 180, 180, 'grey'),
    lightskyblue: new DColour(135, 206, 250, 'lightskyblue'),
    lightsalmon: new DColour(255, 160, 122, 'lightsalmon'),
    hotpink: new DColour(255, 105, 180, 'hotpink')
};

var COLOR_RE = new RegExp('^#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$');
var CSS_COLOR_RE = /rgb\(([0-9]+),([0-9]+),([0-9]+)\)/;

function dasColourForName(name) {
    var c = palette[name];
    if (!c) {
        var match = COLOR_RE.exec(name);
        if (match) {
            c = new DColour('0x' + match[1] | 0, '0x' + match[2] | 0, '0x' + match[3] | 0, name);
            palette[name] = c;
        } else {
            match = CSS_COLOR_RE.exec(name);
            if (match) {
                c = new DColour(match[1] | 0, match[2] | 0, match[3] | 0, name);
                palette[name] = c;
            } else {
                console.log("couldn't handle color: " + name);
                c = palette.black;
                palette[name] = c;
            }
        }
    }
    return c;
}

function makeColourSteps(steps, stops, colours) {
    var dcolours = [];
    for (var ci = 0; ci < colours.length; ++ci) {
        dcolours.push(dasColourForName(colours[ci]));
    }

    var grad = [];
    STEP_LOOP: for (var si = 0; si < steps; ++si) {
        var rs = 1.0 * si / (steps - 1);
        var score = stops[0] + (stops[stops.length - 1] - stops[0]) * rs;
        for (var i = 0; i < stops.length - 1; ++i) {
            if (score >= stops[i] && score <= stops[i + 1]) {
                var frac = (score - stops[i]) / (stops[i + 1] - stops[i]);
                var ca = dcolours[i];
                var cb = dcolours[i + 1];

                var fill = new DColour(ca.red * (1.0 - frac) + cb.red * frac | 0, ca.green * (1.0 - frac) + cb.green * frac | 0, ca.blue * (1.0 - frac) + cb.blue * frac | 0).toSvgString();
                grad.push(fill);

                continue STEP_LOOP;
            }
        }
        throw 'Bad step';
    }

    return grad;
}

function makeGradient(steps, color1, color2, color3) {
    if (color3) {
        return makeColourSteps(steps, [0, 0.5, 1], [color1, color2, color3]);
    } else {
        return makeColourSteps(steps, [0, 1], [color1, color2]);
    }
}

if (typeof module !== 'undefined') {
    module.exports = {
        makeColourSteps: makeColourSteps,
        makeGradient: makeGradient,
        dasColourForName: dasColourForName
    };
}

},{}],10:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// das.js: queries and low-level data model.
//

"use strict";

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;
    var pusho = utils.pusho;

    var color = require('./color');
    var makeColourSteps = color.makeColourSteps;
}

var dasLibErrorHandler = function dasLibErrorHandler(errMsg) {
    alert(errMsg);
};
var dasLibRequestQueue = new Array();

function DASSegment(name, start, end, description) {
    this.name = name;
    this.start = start;
    this.end = end;
    this.description = description;
}
DASSegment.prototype.toString = function () {
    return this.name + ':' + this.start + '..' + this.end;
};
DASSegment.prototype.isBounded = function () {
    return this.start && this.end;
};
DASSegment.prototype.toDASQuery = function () {
    var q = 'segment=' + this.name;
    if (this.start && this.end) {
        q += ':' + this.start + ',' + this.end;
    }
    return q;
};

function DASSource(a1, a2) {
    var options;
    if (typeof a1 == 'string') {
        this.uri = a1;
        options = a2 || {};
    } else {
        options = a1 || {};
    }
    for (var k in options) {
        this[k] = options[k];
    }

    if (!this.coords) {
        this.coords = [];
    }
    if (!this.props) {
        this.props = {};
    }

    this.dasBaseURI = this.uri;
    if (this.dasBaseURI && this.dasBaseURI.substr(this.uri.length - 1) != '/') {
        this.dasBaseURI = this.dasBaseURI + '/';
    }
}

DASSource.prototype.getURI = function (uri) {
    if (this.resolver) {
        return this.resolver(uri).then(function (urlOrObj) {
            if (typeof urlOrObj === 'string') {
                return urlOrObj;
            } else {
                return urlOrObj.url;
            }
        });
    } else {
        return Promise.resolve(uri);
    }
};

function DASCoords() {}

function coordsMatch(c1, c2) {
    return c1.taxon == c2.taxon && c1.auth == c2.auth && c1.version == c2.version;
}

//
// DAS 1.6 entry_points command
//

DASSource.prototype.entryPoints = function (callback) {
    var dasURI = this.dasBaseURI + 'entry_points';
    this.doCrossDomainRequest(dasURI, function (responseXML) {
        if (!responseXML) {
            return callback([]);
        }

        var entryPoints = new Array();

        var segs = responseXML.getElementsByTagName('SEGMENT');
        for (var i = 0; i < segs.length; ++i) {
            var seg = segs[i];
            var segId = seg.getAttribute('id');

            var segSize = seg.getAttribute('size');
            var segMin, segMax;
            if (segSize) {
                segMin = 1;segMax = segSize | 0;
            } else {
                segMin = seg.getAttribute('start');
                if (segMin) {
                    segMin |= 0;
                }
                segMax = seg.getAttribute('stop');
                if (segMax) {
                    segMax |= 0;
                }
            }
            var segDesc = null;
            if (seg.firstChild) {
                segDesc = seg.firstChild.nodeValue;
            }
            entryPoints.push(new DASSegment(segId, segMin, segMax, segDesc));
        }
        callback(entryPoints);
    });
};

//
// DAS 1.6 sequence command
// Do we need an option to fall back to the dna command?
//

function DASSequence(name, start, end, alpha, seq) {
    this.name = name;
    this.start = start;
    this.end = end;
    this.alphabet = alpha;
    this.seq = seq;
}

DASSource.prototype.sequence = function (segment, callback) {
    var dasURI = this.dasBaseURI + 'sequence?' + segment.toDASQuery();
    this.doCrossDomainRequest(dasURI, function (responseXML) {
        if (!responseXML) {
            callback([]);
            return;
        } else {
            var seqs = new Array();

            var segs = responseXML.getElementsByTagName('SEQUENCE');
            for (var i = 0; i < segs.length; ++i) {
                var seg = segs[i];
                var segId = seg.getAttribute('id');
                var segMin = seg.getAttribute('start');
                var segMax = seg.getAttribute('stop');
                var segAlpha = 'DNA';
                var segSeq = null;
                if (seg.firstChild) {
                    var rawSeq = seg.firstChild.nodeValue;
                    segSeq = '';
                    var idx = 0;
                    while (true) {
                        var space = rawSeq.indexOf('\n', idx);
                        if (space >= 0) {
                            segSeq += rawSeq.substring(idx, space).toUpperCase();
                            idx = space + 1;
                        } else {
                            segSeq += rawSeq.substring(idx).toUpperCase();
                            break;
                        }
                    }
                }
                seqs.push(new DASSequence(segId, segMin, segMax, segAlpha, segSeq));
            }

            callback(seqs);
        }
    });
};

//
// DAS 1.6 features command
//

function DASFeature() {}

function DASGroup(id) {
    if (id) this.id = id;
}

function DASLink(desc, uri) {
    this.desc = desc;
    this.uri = uri;
}

DASSource.prototype.features = function (segment, options, callback) {
    options = options || {};
    var thisB = this;

    var dasURI;
    if (this.features_uri) {
        dasURI = this.features_uri;
    } else {
        var filters = [];

        if (segment) {
            filters.push(segment.toDASQuery());
        } else if (options.group) {
            var g = options.group;
            if (typeof g == 'string') {
                filters.push('group_id=' + g);
            } else {
                for (var gi = 0; gi < g.length; ++gi) {
                    filters.push('group_id=' + g[gi]);
                }
            }
        }

        if (options.adjacent) {
            var adj = options.adjacent;
            if (typeof adj == 'string') {
                adj = [adj];
            }
            for (var ai = 0; ai < adj.length; ++ai) {
                filters.push('adjacent=' + adj[ai]);
            }
        }

        if (options.type) {
            if (typeof options.type == 'string') {
                filters.push('type=' + options.type);
            } else {
                for (var ti = 0; ti < options.type.length; ++ti) {
                    filters.push('type=' + options.type[ti]);
                }
            }
        }

        if (options.maxbins) {
            filters.push('maxbins=' + options.maxbins);
        }

        if (filters.length > 0) {
            dasURI = this.dasBaseURI + 'features?' + filters.join(';');
        } else {
            callback([], 'No filters specified');
        }
    }

    this.doCrossDomainRequest(dasURI, function (responseXML, req) {
        if (!responseXML) {
            var msg;
            if (req.status == 0) {
                msg = 'server may not support CORS';
            } else {
                msg = 'status=' + req.status;
            }
            callback([], 'Failed request: ' + msg);
            return;
        }
        /*      if (req) {
                    var caps = req.getResponseHeader('X-DAS-Capabilties');
                    if (caps) {
                        alert(caps);
                    }
                } */

        var features = new Array();
        var segmentMap = {};

        var segs = responseXML.getElementsByTagName('SEGMENT');
        for (var si = 0; si < segs.length; ++si) {
            var segmentXML = segs[si];
            var segmentID = segmentXML.getAttribute('id');
            segmentMap[segmentID] = {
                min: segmentXML.getAttribute('start'),
                max: segmentXML.getAttribute('stop')
            };

            var featureXMLs = segmentXML.getElementsByTagName('FEATURE');
            for (var i = 0; i < featureXMLs.length; ++i) {
                var feature = featureXMLs[i];
                var dasFeature = new DASFeature();

                dasFeature.segment = segmentID;
                dasFeature.id = feature.getAttribute('id');
                dasFeature.label = feature.getAttribute('label');

                /*
                                var childNodes = feature.childNodes;
                                for (var c = 0; c < childNodes.length; ++c) {
                                    var cn = childNodes[c];
                                    if (cn.nodeType == Node.ELEMENT_NODE) {
                                        var key = cn.tagName;
                                        //var val = null;
                                        //if (cn.firstChild) {
                                        //   val = cn.firstChild.nodeValue;
                                        //}
                                        dasFeature[key] = 'x';
                                    }
                                } */

                var spos = elementValue(feature, "START");
                var epos = elementValue(feature, "END");
                if ((spos | 0) > (epos | 0)) {
                    dasFeature.min = epos | 0;
                    dasFeature.max = spos | 0;
                } else {
                    dasFeature.min = spos | 0;
                    dasFeature.max = epos | 0;
                }
                {
                    var tec = feature.getElementsByTagName('TYPE');
                    if (tec.length > 0) {
                        var te = tec[0];
                        if (te.firstChild) {
                            dasFeature.type = te.firstChild.nodeValue;
                        }
                        dasFeature.typeId = te.getAttribute('id');
                        dasFeature.typeCv = te.getAttribute('cvId');
                    }
                }
                dasFeature.type = elementValue(feature, "TYPE");
                if (!dasFeature.type && dasFeature.typeId) {
                    dasFeature.type = dasFeature.typeId; // FIXME?
                }

                dasFeature.method = elementValue(feature, "METHOD");
                {
                    var ori = elementValue(feature, "ORIENTATION");
                    if (!ori) {
                        ori = '0';
                    }
                    dasFeature.orientation = ori;
                }
                dasFeature.score = elementValue(feature, "SCORE");
                dasFeature.links = dasLinksOf(feature);
                dasFeature.notes = dasNotesOf(feature);

                var groups = feature.getElementsByTagName("GROUP");
                for (var gi = 0; gi < groups.length; ++gi) {
                    var groupXML = groups[gi];
                    var dasGroup = new DASGroup();
                    dasGroup.type = groupXML.getAttribute('type');
                    dasGroup.id = groupXML.getAttribute('id');
                    dasGroup.links = dasLinksOf(groupXML);
                    dasGroup.notes = dasNotesOf(groupXML);
                    if (!dasFeature.groups) {
                        dasFeature.groups = new Array(dasGroup);
                    } else {
                        dasFeature.groups.push(dasGroup);
                    }
                }

                // Magic notes.  Check with TAD before changing this.
                if (dasFeature.notes) {
                    for (var ni = 0; ni < dasFeature.notes.length; ++ni) {
                        var n = dasFeature.notes[ni];
                        if (n.indexOf('Genename=') == 0) {
                            var gg = new DASGroup();
                            gg.type = 'gene';
                            gg.id = n.substring(9);
                            if (!dasFeature.groups) {
                                dasFeature.groups = new Array(gg);
                            } else {
                                dasFeature.groups.push(gg);
                            }
                        }
                    }
                }

                {
                    var pec = feature.getElementsByTagName('PART');
                    if (pec.length > 0) {
                        var parts = [];
                        for (var pi = 0; pi < pec.length; ++pi) {
                            parts.push(pec[pi].getAttribute('id'));
                        }
                        dasFeature.parts = parts;
                    }
                }
                {
                    var pec = feature.getElementsByTagName('PARENT');
                    if (pec.length > 0) {
                        var parents = [];
                        for (var pi = 0; pi < pec.length; ++pi) {
                            parents.push(pec[pi].getAttribute('id'));
                        }
                        dasFeature.parents = parents;
                    }
                }

                features.push(dasFeature);
            }
        }

        callback(features, undefined, segmentMap);
    }, function (err) {
        callback([], err);
    });
};

function DASAlignment(type) {
    this.type = type;
    this.objects = {};
    this.blocks = [];
}

DASSource.prototype.alignments = function (segment, options, callback) {
    var dasURI = this.dasBaseURI + 'alignment?query=' + segment;
    this.doCrossDomainRequest(dasURI, function (responseXML) {
        if (!responseXML) {
            callback([], 'Failed request ' + dasURI);
            return;
        }

        var alignments = [];
        var aliXMLs = responseXML.getElementsByTagName('alignment');
        for (var ai = 0; ai < aliXMLs.length; ++ai) {
            var aliXML = aliXMLs[ai];
            var ali = new DASAlignment(aliXML.getAttribute('alignType'));
            var objXMLs = aliXML.getElementsByTagName('alignObject');
            for (var oi = 0; oi < objXMLs.length; ++oi) {
                var objXML = objXMLs[oi];
                var obj = {
                    id: objXML.getAttribute('intObjectId'),
                    accession: objXML.getAttribute('dbAccessionId'),
                    version: objXML.getAttribute('objectVersion'),
                    dbSource: objXML.getAttribute('dbSource'),
                    dbVersion: objXML.getAttribute('dbVersion')
                };
                ali.objects[obj.id] = obj;
            }

            var blockXMLs = aliXML.getElementsByTagName('block');
            for (var bi = 0; bi < blockXMLs.length; ++bi) {
                var blockXML = blockXMLs[bi];
                var block = {
                    order: blockXML.getAttribute('blockOrder'),
                    segments: []
                };
                var segXMLs = blockXML.getElementsByTagName('segment');
                for (var si = 0; si < segXMLs.length; ++si) {
                    var segXML = segXMLs[si];
                    var seg = {
                        object: segXML.getAttribute('intObjectId'),
                        min: segXML.getAttribute('start'),
                        max: segXML.getAttribute('end'),
                        strand: segXML.getAttribute('strand'),
                        cigar: elementValue(segXML, 'cigar')
                    };
                    block.segments.push(seg);
                }
                ali.blocks.push(block);
            }

            alignments.push(ali);
        }
        callback(alignments);
    });
};

function DASStylesheet() {
    this.styles = [];
}

DASStylesheet.prototype.pushStyle = function (filters, zoom, style) {
    if (!filters) {
        filters = { type: 'default' };
    }
    var styleHolder = shallowCopy(filters);
    if (zoom) {
        styleHolder.zoom = zoom;
    }
    styleHolder.style = style;
    this.styles.push(styleHolder);
};

function DASStyle() {}

function parseGradient(grad) {
    var steps = grad.getAttribute('steps');
    if (steps) {
        steps = steps | 0;
    } else {
        steps = 50;
    }

    var stops = [];
    var colors = [];
    var se = grad.getElementsByTagName('STOP');
    for (var si = 0; si < se.length; ++si) {
        var stop = se[si];
        stops.push(1.0 * stop.getAttribute('score'));
        colors.push(stop.firstChild.nodeValue);
    }

    return makeColourSteps(steps, stops, colors);
}

DASSource.prototype.stylesheet = function (successCB, failureCB) {
    var dasURI,
        creds = this.credentials;
    if (this.stylesheet_uri) {
        dasURI = this.stylesheet_uri;
        creds = false;
    } else {
        dasURI = this.dasBaseURI + 'stylesheet';
    }

    this.getURI(dasURI).then(function (dasURI) {
        doCrossDomainRequest(dasURI, function (responseXML) {
            if (!responseXML) {
                if (failureCB) {
                    failureCB();
                }
                return;
            }
            var stylesheet = new DASStylesheet();
            var typeXMLs = responseXML.getElementsByTagName('TYPE');
            for (var i = 0; i < typeXMLs.length; ++i) {
                var typeStyle = typeXMLs[i];

                var filter = {};
                filter.type = typeStyle.getAttribute('id'); // Am I right in thinking that this makes DASSTYLE XML invalid?  Ugh.
                filter.label = typeStyle.getAttribute('label');
                filter.method = typeStyle.getAttribute('method');
                var glyphXMLs = typeStyle.getElementsByTagName('GLYPH');
                for (var gi = 0; gi < glyphXMLs.length; ++gi) {
                    var glyphXML = glyphXMLs[gi];
                    var zoom = glyphXML.getAttribute('zoom');
                    var glyph = childElementOf(glyphXML);
                    var style = new DASStyle();
                    style.glyph = glyph.localName;
                    var child = glyph.firstChild;

                    while (child) {
                        if (child.nodeType == Node.ELEMENT_NODE) {
                            if (child.localName == 'BGGRAD') {
                                style[child.localName] = parseGradient(child);
                            } else {
                                style[child.localName] = child.firstChild.nodeValue;
                            }
                        }
                        child = child.nextSibling;
                    }
                    stylesheet.pushStyle(filter, zoom, style);
                }
            }
            successCB(stylesheet);
        }, creds);
    }).catch(function (err) {
        console.log(err);
        failureCB();
    });
};

//
// sources command
// 

function DASRegistry(uri, opts) {
    opts = opts || {};
    this.uri = uri;
    this.opts = opts;
}

DASRegistry.prototype.sources = function (callback, failure, opts) {
    if (!opts) {
        opts = {};
    }

    var filters = [];
    if (opts.taxon) {
        filters.push('organism=' + opts.taxon);
    }
    if (opts.auth) {
        filters.push('authority=' + opts.auth);
    }
    if (opts.version) {
        filters.push('version=' + opts.version);
    }
    var quri = this.uri;
    if (filters.length > 0) {
        quri = quri + '?' + filters.join('&'); // '&' as a separator to hack around dasregistry.org bug.
    }

    doCrossDomainRequest(quri, function (responseXML) {
        if (!responseXML && failure) {
            failure();
            return;
        }

        var sources = [];
        var sourceXMLs = responseXML.getElementsByTagName('SOURCE');
        for (var si = 0; si < sourceXMLs.length; ++si) {
            var sourceXML = sourceXMLs[si];
            var versionXMLs = sourceXML.getElementsByTagName('VERSION');
            if (versionXMLs.length < 1) {
                continue;
            }
            var versionXML = versionXMLs[0];

            var coordXMLs = versionXML.getElementsByTagName('COORDINATES');
            var coords = [];
            for (var ci = 0; ci < coordXMLs.length; ++ci) {
                var coordXML = coordXMLs[ci];
                var coord = new DASCoords();
                coord.auth = coordXML.getAttribute('authority');
                coord.taxon = coordXML.getAttribute('taxid');
                coord.version = coordXML.getAttribute('version');
                coords.push(coord);
            }

            var caps = [];
            var capXMLs = versionXML.getElementsByTagName('CAPABILITY');
            var uri;
            for (var ci = 0; ci < capXMLs.length; ++ci) {
                var capXML = capXMLs[ci];

                caps.push(capXML.getAttribute('type'));

                if (capXML.getAttribute('type') == 'das1:features') {
                    var fep = capXML.getAttribute('query_uri');
                    uri = fep.substring(0, fep.length - 'features'.length);
                }
            }

            var props = {};
            var propXMLs = versionXML.getElementsByTagName('PROP');
            for (var pi = 0; pi < propXMLs.length; ++pi) {
                pusho(props, propXMLs[pi].getAttribute('name'), propXMLs[pi].getAttribute('value'));
            }

            if (uri) {
                var source = new DASSource(uri, {
                    source_uri: sourceXML.getAttribute('uri'),
                    name: sourceXML.getAttribute('title'),
                    desc: sourceXML.getAttribute('description'),
                    coords: coords,
                    props: props,
                    capabilities: caps
                });
                sources.push(source);
            }
        }

        callback(sources);
    });
};

//
// Utility functions
//

function elementValue(element, tag) {
    var children = element.getElementsByTagName(tag);
    if (children.length > 0 && children[0].firstChild) {
        var c = children[0];
        if (c.childNodes.length == 1) {
            return c.firstChild.nodeValue;
        } else {
            var s = '';
            for (var ni = 0; ni < c.childNodes.length; ++ni) {
                s += c.childNodes[ni].nodeValue;
            }
            return s;
        }
    } else {
        return null;
    }
}

function childElementOf(element) {
    if (element.hasChildNodes()) {
        var child = element.firstChild;
        do {
            if (child.nodeType == Node.ELEMENT_NODE) {
                return child;
            }
            child = child.nextSibling;
        } while (child != null);
    }
    return null;
}

function dasLinksOf(element) {
    var links = new Array();
    var maybeLinkChilden = element.getElementsByTagName('LINK');
    for (var ci = 0; ci < maybeLinkChilden.length; ++ci) {
        var linkXML = maybeLinkChilden[ci];
        if (linkXML.parentNode == element) {
            links.push(new DASLink(linkXML.firstChild ? linkXML.firstChild.nodeValue : 'Unknown', linkXML.getAttribute('href')));
        }
    }

    return links;
}

function dasNotesOf(element) {
    var notes = [];
    var maybeNotes = element.getElementsByTagName('NOTE');
    for (var ni = 0; ni < maybeNotes.length; ++ni) {
        if (maybeNotes[ni].firstChild) {
            notes.push(maybeNotes[ni].firstChild.nodeValue);
        }
    }
    return notes;
}

function doCrossDomainRequest(url, handler, credentials, custAuth) {
    // TODO: explicit error handlers?

    if (window.XDomainRequest) {
        var req = new XDomainRequest();
        req.onload = function () {
            var dom = new ActiveXObject("Microsoft.XMLDOM");
            dom.async = false;
            dom.loadXML(req.responseText);
            handler(dom);
        };
        req.open("get", url);
        req.send();
    } else {
        try {
            var req = new XMLHttpRequest();
            var timeout = setTimeout(function () {
                console.log('timing out ' + url);
                req.abort();
                handler(null, req);
            }, 5000);

            req.ontimeout = function () {
                console.log('timeout on ' + url);
            };

            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    clearTimeout(timeout);
                    if (req.status >= 200 || req.status == 0) {
                        handler(req.responseXML, req);
                    }
                }
            };
            req.open("get", url, true);
            // IE10/11 fix: The timeout property may be set only in the time interval between a call to the open method
            //              and the first call to the send method.
            req.timeout = 5000;
            if (credentials) {
                req.withCredentials = true;
            }
            if (custAuth) {
                req.setRequestHeader('X-DAS-Authorisation', custAuth);
            }
            req.overrideMimeType('text/xml');
            req.setRequestHeader('Accept', 'application/xml,*/*');
            req.send();
        } catch (e) {
            handler(null, req, e);
        }
    }
}

DASSource.prototype.doCrossDomainRequest = function (url, handler, errHandler) {
    var custAuth;
    if (this.xUser) {
        custAuth = 'Basic ' + btoa(this.xUser + ':' + this.xPass);
    }

    try {
        return doCrossDomainRequest(url, handler, this.credentials, custAuth);
    } catch (err) {
        if (errHandler) {
            errHandler(err);
        } else {
            throw err;
        }
    }
};

function isDasBooleanTrue(s) {
    s = ('' + s).toLowerCase();
    return s === 'yes' || s === 'true';
}

function isDasBooleanNotFalse(s) {
    if (!s) return false;

    s = ('' + s).toLowerCase();
    return s !== 'no' || s !== 'false';
}

function copyStylesheet(ss) {
    var nss = shallowCopy(ss);
    nss.styles = [];
    for (var si = 0; si < ss.styles.length; ++si) {
        var sh = nss.styles[si] = shallowCopy(ss.styles[si]);
        sh._methodRE = sh._labelRE = sh._typeRE = undefined;
        sh.style = shallowCopy(sh.style);
        sh.style.id = undefined;
        sh.style._gradient = undefined;
    }
    return nss;
}

if (typeof module !== 'undefined') {
    module.exports = {
        DASGroup: DASGroup,
        DASFeature: DASFeature,
        DASStylesheet: DASStylesheet,
        DASStyle: DASStyle,
        DASSource: DASSource,
        DASSegment: DASSegment,
        DASRegistry: DASRegistry,
        DASSequence: DASSequence,
        DASLink: DASLink,

        isDasBooleanTrue: isDasBooleanTrue,
        isDasBooleanNotFalse: isDasBooleanNotFalse,
        copyStylesheet: copyStylesheet,
        coordsMatch: coordsMatch
    };
}

},{"./color":9,"./utils":55}],11:[function(require,module,exports){
/* jshint esversion: 6 */
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.featureLookup = exports.paintQuant = exports.createQuantOverlay = exports.clearViewport = exports.drawUnmapped = exports.paint = exports.prepareViewport = exports.prepareSubtiers = exports.drawTier = exports.renderTier = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _featureDraw = require("./feature-draw.js");

var _sequenceDraw = require("./sequence-draw.js");

var _spans = require("./spans.js");

var _utils = require("./utils.js");

var _glyphs = require("./glyphs.js");

var Glyphs = _interopRequireWildcard(_glyphs);

var _das = require("./das.js");

var _color = require("./color.js");

var _cigar = require("./cigar.js");

var _numformats = require("./numformats");

var _ramda = require("ramda");

var R = _interopRequireWildcard(_ramda);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// The only functions that must be exported by a renderer are renderTier
// and drawTier, the rest are exported for use in other renderers.
exports.renderTier = renderTier;
exports.drawTier = drawTier;
exports.prepareSubtiers = prepareSubtiers;
exports.prepareViewport = prepareViewport;
exports.paint = paint;
exports.drawUnmapped = drawUnmapped;
exports.clearViewport = clearViewport;
exports.createQuantOverlay = createQuantOverlay;
exports.paintQuant = paintQuant;
exports.featureLookup = featureLookup;


function renderTier(status, tier) {
    drawTier(tier);
    tier.updateStatus(status);
}

function drawTier(tier) {
    var canvas = tier.viewport.getContext("2d");
    var retina = tier.browser.retina && window.devicePixelRatio > 1;

    if (tier.sequenceSource) {
        var sequence = tier.currentSequence;
        (0, _sequenceDraw.drawSeqTier)(tier, sequence);
    } else if (tier.currentFeatures) {
        prepareSubtiers(tier, canvas);
    } else {
        console.log("No sequence or features in tier!");
    }

    if (tier.subtiers) {
        var vOffset = R.defaultTo(0, tier.dasSource.vOffset);

        prepareViewport(tier, canvas, retina, true, vOffset); // NB calls canvas.save
        paint(tier, canvas, vOffset);
        canvas.restore();
    }

    tier.drawOverlay();
    tier.paintQuant();

    if (typeof tier.dasSource.drawCallback === "function") {
        tier.dasSource.drawCallback(canvas, tier);
    }

    tier.originHaxx = 0;
    tier.browser.arrangeTiers();
}

function glyphsForGroup(canvas, features, y, groupElement, tier) {
    var gstyle = tier.styleForFeature(groupElement);
    var label = void 0;
    var labelWanted = false;

    var glyphs = [];
    var strand = null;

    features.forEach(function (f) {
        if (f.orientation && strand === null) {
            strand = f.orientation;
        }

        if (!label && f.label) {
            label = f.label;
        }

        var style = tier.styleForFeature(f);
        if (style && !f.parts) {
            if ((0, _das.isDasBooleanTrue)(style.LABEL)) labelWanted = true;

            var glyph = glyphForFeature(canvas, f, y, style, tier, null, true);
            if (glyph) glyphs.push(glyph);
        }
    });

    if (glyphs.length === 0) return null;

    var connector = 'flat';
    if (gstyle && gstyle.glyph === 'LINE') {
        // Stick with flat...
    } else {
        if (tier.dasSource.collapseSuperGroups && !tier.bumped) {
            if (strand === '+' || strand === '-') {
                connector = 'collapsed' + strand;
            }
        } else {
            if (strand === '+' || strand === '-') {
                connector = 'hat' + strand;
            }
        }
    }

    var labelText = null;
    if (label && labelWanted || gstyle && ((0, _das.isDasBooleanTrue)(gstyle.LABEL) || (0, _das.isDasBooleanTrue)(gstyle.LABELS))) {
        // HACK, LABELS should work.
        labelText = groupElement.label || label;
    }

    glyphs.sort(function (g1, g2) {
        return (g1.zindex || 0) - (g2.zindex || 0);
    });

    var groupGlyph = new Glyphs.GroupGlyph(glyphs, connector);
    if (labelText) {
        if (strand === '+') {
            labelText = '>' + labelText;
        } else if (strand === '-') {
            labelText = '<' + labelText;
        }
        groupGlyph = new Glyphs.LabelledGlyph(canvas, groupGlyph, labelText, false);
    }
    groupGlyph.bump = true;
    return groupGlyph;
}

function glyphForFeature(canvas, feature, y, style, tier, forceHeight, noLabel) {
    var scale = tier.browser.scale;
    var origin = tier.browser.viewStart;
    var glyphType = style.glyph || 'BOX';

    var min = feature.min;
    var max = feature.max;
    var strand = feature.orientation;
    var score = feature.score;
    var label = feature.label || feature.id;

    // Hide glyphs that are smaller than a pixel in width.
    if (tier.dasSource.hideSubpixelGlyphs && (max - min) * scale < 1) return null;

    var minPos = (min - origin) * scale;
    var rawMaxPos = (max - origin + 1) * scale;
    var maxPos = Math.max(rawMaxPos, minPos + 1);

    forceHeight = forceHeight * 1.0;
    var height = (tier.forceHeight || style.HEIGHT || forceHeight || 12) * 1.0;
    height = height * 1.0;
    var bump = style.BUMP && (0, _das.isDasBooleanTrue)(style.BUMP);

    var glyph = void 0;
    var quant = void 0;

    // Create the glyph
    if (glyphType === 'CROSS' || glyphType === 'EX' || glyphType === 'TRIANGLE' || glyphType === 'DOT' || glyphType === 'SQUARE' || glyphType === 'STAR' || glyphType === 'PLIMSOLL') {
        var glyphHolder = featureToCrossLikeGlyph(canvas, tier, feature, y, glyphType, style, forceHeight, noLabel);
        if (glyphHolder) {
            var _glyphHolder = _slicedToArray(glyphHolder, 2);

            glyph = _glyphHolder[0];
            quant = _glyphHolder[1];
        }
    } else if (glyphType === 'HISTOGRAM' || glyphType === 'GRADIENT' && score !== 'undefined') {
        var _featureToGradientLik = featureToGradientLikeGlyph(canvas, tier, feature, y, glyphType, style, forceHeight);

        var _featureToGradientLik2 = _slicedToArray(_featureToGradientLik, 2);

        glyph = _featureToGradientLik2[0];
        quant = _featureToGradientLik2[1];
    } else if (glyphType === 'HIDDEN') {
        glyph = new Glyphs.PaddedGlyph(null, minPos, maxPos);
        noLabel = true;
    } else if (glyphType === 'ARROW') {
        var color = style.FGCOLOR || 'purple';
        var parallel = (0, _das.isDasBooleanTrue)(style.PARALLEL);
        var sw = (0, _das.isDasBooleanTrue)(style.SOUTHWEST);
        var ne = (0, _das.isDasBooleanTrue)(style.NORTHEAST);
        glyph = new Glyphs.ArrowGlyph(minPos, maxPos, height, color, parallel, sw, ne);
    } else if (glyphType === 'ANCHORED_ARROW') {
        var stroke = style.FGCOLOR || 'none';
        var fill = style.BGCOLOR || 'green';
        glyph = new Glyphs.AArrowGlyph(minPos, maxPos, height, fill, stroke, strand);
        glyph.bump = true;
    } else if (glyphType === 'SPAN') {
        var _stroke = style.FGCOLOR || 'black';
        glyph = new Glyphs.SpanGlyph(minPos, maxPos, height, _stroke);
    } else if (glyphType === 'LINE') {
        var _stroke2 = style.FGCOLOR || 'black';
        var lineStyle = style.STYLE || 'solid';
        glyph = new Glyphs.LineGlyph(minPos, maxPos, height, lineStyle, strand, _stroke2);
    } else if (glyphType === 'PRIMERS') {
        var _stroke3 = style.FGCOLOR || 'black';
        var _fill = style.BGCOLOR || 'red';
        glyph = new Glyphs.PrimersGlyph(minPos, maxPos, height, _fill, _stroke3);
    } else if (glyphType === 'TEXT') {
        var string = style.STRING || 'text';
        var _fill2 = style.FGCOLOR || 'black';
        glyph = new Glyphs.TextGlyph(canvas, minPos, maxPos, height, _fill2, string);
    } else if (glyphType === 'TOOMANY') {
        var _stroke4 = style.FGCOLOR || 'gray';
        var _fill3 = style.BGCOLOR || 'orange';
        glyph = new Glyphs.TooManyGlyph(minPos, maxPos, height, _fill3, _stroke4);
    } else if (glyphType === 'POINT') {
        var _featureToPointGlyph = featureToPointGlyph(tier, feature, style);

        var _featureToPointGlyph2 = _slicedToArray(_featureToPointGlyph, 2);

        glyph = _featureToPointGlyph2[0];
        quant = _featureToPointGlyph2[1];
    } else if (glyphType === '__SEQUENCE') {
        glyph = sequenceGlyph(canvas, tier, feature, style, forceHeight);
    } else if (glyphType === '__INSERTION') {
        var insertionLabels = true;
        if (style.__INSERTIONS !== undefined) insertionLabels = (0, _das.isDasBooleanNotFalse)(style.__INSERTIONS);
        glyph = new Glyphs.TriangleGlyph(minPos, 5, 'S', 5, tier.browser.baseColors['I']);
        if (insertionLabels) glyph = new Glyphs.LabelledGlyph(canvas, glyph, feature.insertion || feature.altAlleles[0], false, 'center', 'above', '7px sans-serif');

        if (maxPos - minPos > 1) {
            var _stroke5 = style.FGCOLOR || 'red';
            var _fill4 = style.BGCOLOR || style.COLOR1 || 'green';
            var bg = new Glyphs.BoxGlyph(minPos, 5, maxPos - minPos, height, _fill4, _stroke5);
            glyph = new Glyphs.GroupGlyph([bg, glyph]);
        }
    } else if (glyphType === '__NONE') {
        return null;
    } else if (glyphType === 'BOX') {
        var _stroke6 = style.FGCOLOR || null;
        var _fill5 = style.BGCOLOR || style.COLOR1 || 'green';
        if (style.BGITEM && feature.itemRgb) _fill5 = feature.itemRgb;
        var _scale = (maxPos - minPos) / (max - min);
        if (feature.type == 'translation' && (feature.method == 'protein_coding' || feature.readframeExplicit) && (!feature.tags || feature.tags.indexOf('cds_start_NF') < 0 || feature.readframeExplicit) && (!tier.dasSource.collapseSuperGroups || tier.bumped) && _scale >= 0.5) {
            var refSeq = getRefSeq(tier, min, max);
            glyph = new Glyphs.AminoAcidGlyph(minPos, maxPos, height, _fill5, refSeq, feature.orientation, feature.readframe);
        } else {
            glyph = new Glyphs.BoxGlyph(minPos, 0, maxPos - minPos, height, _fill5, _stroke6);
        }
    }

    if (!glyph) return;

    if (((0, _das.isDasBooleanTrue)(style.LABEL) || feature.forceLabel) && label && !noLabel) {
        glyph = new Glyphs.LabelledGlyph(canvas, glyph, label, false);
    }

    if (bump) {
        glyph.bump = true;
    }

    glyph.feature = feature;

    if ((0, _das.isDasBooleanTrue)(style["HIDEAXISLABEL"])) quant = null;

    if (quant) {
        glyph.quant = quant;
    }

    if (style.ZINDEX) {
        glyph.zindex = style.ZINDEX | 0;
    }

    return glyph;
}

function groupFeatures(tier, canvas, y) {
    var glyphs = [];
    var gbsFeatures = {};
    var gbsStyles = {};
    var stackedFeatures = [];

    R.map(function (features) {
        features.forEach(function (feature) {
            var style = tier.styleForFeature(feature);

            if (feature.parts || !style) return;

            if (style.glyph === 'LINEPLOT') {
                (0, _utils.pusho)(gbsFeatures, style.id, feature);
                gbsStyles[style.id] = style;
            } else if (style.glyph === 'STACKED') {
                stackedFeatures.push(feature);
            } else {
                var glyph = glyphForFeature(canvas, feature, y, style, tier);
                if (glyph) glyphs.push(glyph);
            }
        });
    }, tier.ungroupedFeatures);

    if (stackedFeatures.length > 0) {
        glyphs = glyphs.concat(makeStackedBars(stackedFeatures, tier));
    }

    for (var gbs in gbsFeatures) {
        var gf = gbsFeatures[gbs];
        var style = gbsStyles[gbs];
        if (style.glyph === 'LINEPLOT') {
            var lineGraphGlyphs = makeLinePlot(gf, style, tier, y);
            lineGraphGlyphs.forEach(function (g) {
                return glyphs.push(g);
            });
        }
    }

    return glyphs;
}

function glyphifyGroups(tier, canvas, glyphs, y) {
    var groupIds = Object.keys(tier.groupedFeatures);
    var groupGlyphs = {};

    groupIds.sort(function (g1, g2) {
        return tier.groupedFeatures[g2][0].score - tier.groupedFeatures[g1][0].score;
    });

    groupIds.forEach(function (gId) {
        var glyphs = glyphsForGroup(canvas, tier.groupedFeatures[gId], y, tier.groups[gId], tier, tier.dasSource.collapseSuperGroups && !tier.bumped ? 'collapsed_gene' : 'tent');

        if (glyphs) {
            glyphs.group = tier.groups[gId];
            groupGlyphs[gId] = glyphs;
        }
    });

    return groupGlyphs;
}

function bumpSubtiers(tier, glyphs, grid, gridOffset, gridSpacing) {
    var subtierMax = tier.subtierMax || tier.dasSource.subtierMax || tier.browser.defaultSubtierMax;

    var subtiersExceeded = false;

    var unbumpedST = new _featureDraw.SubTier(true);
    var bumpedSTs = [];

    // We want to add each glyph to either the subtier
    // containing unbumped subtiers, or to the first bumped subtier.
    glyphs.forEach(function (glyph) {
        // if the glyph is to be bumped...
        if (glyph.bump && (tier.bumped || tier.dasSource.collapseSuperGroups)) {

            var glyphTier = bumpedSTs.find(function (st) {
                return st.hasSpaceFor(glyph);
            });

            if (glyphTier) {
                glyphTier.add(glyph);
            } else if (bumpedSTs.length >= subtierMax) {
                subtiersExceeded = true;
            } else {
                var subtier = new _featureDraw.SubTier();
                subtier.add(glyph);
                bumpedSTs.push(subtier);
            }
        } else {
            unbumpedST.add(glyph);
        }
    });

    unbumpedST.glyphs.sort(function (g1, g2) {
        return g1.min() - g2.min();
    });

    if (unbumpedST.glyphs.length > 0) {
        bumpedSTs = [unbumpedST].concat(bumpedSTs);
    }

    // Simple hack to make the horizontal grid in bumped subtiers (e.g. lineplots)
    // optional and configurable.
    if (grid) {
        bumpedSTs.forEach(function (subtier) {
            if (subtier.quant) {
                subtier.glyphs.unshift(new Glyphs.GridGlyph(subtier.height, gridOffset, gridSpacing));
            }
        });
    }

    bumpedSTs.forEach(function (subtier) {
        subtier.glyphs.sort(function (g1, g2) {
            return (g1.zindex || 0) - (g2.zindex || 0);
        });
    });

    return [bumpedSTs, subtiersExceeded];
}

// The whole tier is translated downward on its canvas by y pixels
function prepareSubtiers(tier, canvas) {
    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var grid = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;


    var MIN_PADDING = 3;
    tier.padding = typeof tier.dasSource.padding === 'number' ? tier.dasSource.padding : MIN_PADDING;

    tier.scaleVertical = typeof tier.dasSource.scaleVertical === 'boolean' ? tier.dasSource.scaleVertical : false;

    var glyphs = groupFeatures(tier, canvas, y);

    // Merge supergroups
    if (tier.dasSource.collapseSuperGroups && !tier.bumped) {
        var _loop = function _loop(sgId) {
            var sgGroup = tier.superGroups[sgId];
            tier.groups[sgId] = (0, _utils.shallowCopy)(tier.groups[sgId]);
            var group = tier.groups[sgId];
            group.isSuperGroup = true;
            var featuresByType = {};

            var sgMin = 10000000000,
                sgMax = -10000000000;
            var sgSeg = null;

            sgGroup.forEach(function (g, i) {
                var groupedFeature = tier.groupedFeatures[sgGroup[i]];
                if (!groupedFeature) return;

                groupedFeature.forEach(function (feature) {
                    (0, _utils.pusho)(featuresByType, feature.type, feature);
                    sgMin = Math.min(feature.min, sgMin);
                    sgMax = Math.max(feature.max, sgMax);
                    if (feature.segment && !sgSeg) sgSeg = feature.segment;
                });

                if (group && !group.links || group.links.length === 0) {
                    group.links = tier.groups[sgGroup[0]].links;
                }

                delete tier.groupedFeatures[sgGroup[i]];
            });

            tier.groups[sgId].max = sgMax;
            tier.groups[sgId].min = sgMin;
            tier.groups[sgId].segment = sgSeg;

            R.map(function (features) {

                var template = features[0];
                var loc = null;

                features.forEach(function (feature) {
                    var fl = new _spans.Range(feature.min, feature.max);
                    loc = loc ? (0, _spans.union)(loc, fl) : fl;
                });

                var mergedRanges = loc.ranges();

                mergedRanges.forEach(function (range) {
                    var posCoverage = ((range.max() | 0) - (range.min() | 0) + 1) * sgGroup.length;
                    var actCoverage = 0;

                    features.forEach(function (feature) {
                        var fmin = feature.min || 0;
                        var fmax = feature.max || 0;
                        if (fmin <= range.max() && fmax >= range.min()) {

                            actCoverage += Math.min(fmax, range.max()) - Math.max(fmin, range.min()) + 1;
                        }
                    });

                    var newFeature = new _das.DASFeature();
                    for (var key in template) {
                        newFeature[key] = template[key];
                    }

                    newFeature.min = range.min();
                    newFeature.max = range.max();
                    if (newFeature.label && sgGroup.length > 1) {
                        newFeature.label += ' (' + sgGroup.length + ' vars)';
                    }

                    newFeature.visualWeight = 1.0 * actCoverage / posCoverage;

                    (0, _utils.pusho)(tier.groupedFeatures, sgId, newFeature);
                });
            }, featuresByType);

            delete tier.superGroups[sgId]; // Do we want this?
        };

        for (var sgId in tier.superGroups) {
            _loop(sgId);
        }
    }

    // Glyphify groups.
    var groupGlyphs = glyphifyGroups(tier, canvas, glyphs, y);

    R.map(function (superGroup) {
        var sgGlyphs = [];
        var sgMin = 10000000000;
        var sgMax = -10000000000;

        superGroup.forEach(function (glyphs) {
            var gGlyphs = groupGlyphs[glyphs];
            groupGlyphs[glyphs] = null;
            if (gGlyphs) {
                sgGlyphs.push(gGlyphs);
                sgMin = Math.min(sgMin, gGlyphs.min());
                sgMax = Math.max(sgMax, gGlyphs.max());
            }
        });

        sgGlyphs.forEach(function (glyph) {
            glyphs.push(new Glyphs.PaddedGlyph(glyph, sgMin, sgMax));
        });
    }, tier.superGroups);

    R.map(function (glyph) {
        if (glyph) {
            glyphs.push(glyph);
        }
    }, groupGlyphs);

    var _bumpSubtiers = bumpSubtiers(tier, glyphs, grid, y),
        _bumpSubtiers2 = _slicedToArray(_bumpSubtiers, 2),
        subtiers = _bumpSubtiers2[0],
        subtiersExceeded = _bumpSubtiers2[1];

    tier.glyphCacheOrigin = tier.browser.viewStart;

    if (subtiersExceeded) tier.updateStatus('Bumping limit exceeded, use the track editor to see more features');else tier.updateStatus();

    tier.subtiers = subtiers;
}

// Fills out areas that haven't been fetched as gray blocks
function drawUnmapped(tier, canvas, padding) {
    var drawStart = tier.browser.viewStart - 1000.0 / tier.browser.scale;
    var drawEnd = tier.browser.viewEnd + 1000.0 / tier.browser.scale;
    var unmappedBlocks = [];
    if (tier.knownCoverage) {
        var knownRanges = tier.knownCoverage.ranges();
        knownRanges.forEach(function (range, index) {
            if (index === 0) {
                if (range.min() > drawStart) unmappedBlocks.push({ min: drawStart, max: range.min() - 1 });
            } else {
                unmappedBlocks.push({ min: knownRanges[index - 1].max() + 1, max: range.min() - 1 });
            }

            if (index == knownRanges.length - 1 && range.max() < drawEnd) {
                unmappedBlocks.push({ min: range.max() + 1, max: drawEnd });
            }
        });
    }
    if (unmappedBlocks.length > 0) {
        canvas.fillStyle = 'gray';
        unmappedBlocks.forEach(function (block) {
            var min = (block.min - tier.browser.viewStart) * tier.browser.scale + 1000;
            var max = (block.max - tier.browser.viewStart) * tier.browser.scale + 1000;
            canvas.fillRect(min, 0, max - min, padding);
        });
    }
}

function clearViewport(canvas, width, height) {
    canvas.clearRect(0, 0, width, height);
}

// Make the viewport & canvas the correct size for the tier
function prepareViewport(tier, canvas, retina) {
    var clear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var vOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

    var desiredWidth = tier.browser.featurePanelWidth + 2000;
    if (retina) {
        desiredWidth *= 2;
    }

    var fpw = tier.viewport.width | 0;
    if (fpw < desiredWidth - 50) {
        tier.viewport.width = fpw = desiredWidth;
    }

    var lh = tier.padding + vOffset;

    tier.subtiers.forEach(function (s) {
        return lh += s.height + tier.padding;
    });

    lh += 6;
    lh = Math.max(lh, tier.browser.minTierHeight);

    var canvasHeight = lh;
    if (retina) {
        canvasHeight *= 2;
    }

    if (canvasHeight != tier.viewport.height) {
        tier.viewport.height = canvasHeight;
    }

    tier.viewportHolder.style.left = '-1000px';
    tier.viewport.style.width = retina ? '' + fpw / 2 + 'px' : '' + fpw + 'px';
    tier.viewport.style.height = '' + lh + 'px';
    tier.layoutHeight = Math.max(lh, tier.browser.minTierHeight);

    tier.updateHeight();
    tier.norigin = tier.browser.viewStart;

    canvas.save();
    if (retina) {
        canvas.scale(2, 2);
    }

    if (clear) {
        clearViewport(canvas, fpw, canvasHeight);
    }

    drawUnmapped(tier, canvas, lh);
}

function paint(tier, canvas) {
    var vOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    var overlayLabelCanvas = new Glyphs.OverlayLabelCanvas();
    var offset = (tier.glyphCacheOrigin - tier.browser.viewStart) * tier.browser.scale + 1000;
    canvas.translate(offset, vOffset + tier.padding);
    overlayLabelCanvas.translate(0, tier.padding);

    tier.paintToContext(canvas, overlayLabelCanvas, offset);

    if (overlayLabelCanvas.glyphs.length > 0) tier.overlayLabelCanvas = overlayLabelCanvas;else tier.overlayLabelCanvas = null;

    canvas.restore();
}

function getScoreMinMax(tier, style) {
    var smin = tier.quantMin(style);
    var smax = tier.quantMax(style);

    if (!smax) {
        if (smin < 0) {
            smax = 0;
        } else {
            smax = 10;
        }
    }
    if (!smin) {
        smin = 0;
    }
    return [smin, smax];
}

function relScoreOrigin(score, smin, smax) {
    var relScore = (1.0 * score - smin) / (smax - smin);
    var relOrigin = -1.0 * smin / (smax - smin);

    return [relScore, relOrigin];
}

function getRefSeq(tier, min, max) {
    var refSeq = null;
    if (tier.currentSequence) {
        var csStart = tier.currentSequence.start | 0;
        var csEnd = tier.currentSequence.end | 0;
        if (csStart <= max && csEnd >= min) {
            var sfMin = Math.max(min, csStart);
            var sfMax = Math.min(max, csEnd);

            refSeq = tier.currentSequence.seq.substr(sfMin - csStart, sfMax - sfMin + 1);
            while (min < sfMin) {
                refSeq = 'N' + refSeq;
                sfMin--;
            }
            while (max > sfMax) {
                refSeq = refSeq + 'N';
                sfMax++;
            }
        }
    }
    return refSeq;
}

function featureToCrossLikeGlyph(canvas, tier, feature, y, glyphType, style, forceHeight, noLabel) {
    var scale = tier.browser.scale;
    var origin = tier.browser.viewStart;

    var score = feature.score;
    var label = feature.label || feature.id;

    var minPos = (feature.min - origin) * scale;
    var maxPos = Math.max((feature.max - origin + 1) * scale, minPos + 1);

    var height = (tier.forceHeight || style.HEIGHT || forceHeight || 12) * 1.0;
    var requiredHeight = height;

    var glyph = null;
    var quant = null;

    var stroke = style.FGCOLOR || 'black';
    var fill = style.BGCOLOR || 'none';
    var outline = style.STROKECOLOR;

    if (style.BGITEM && feature.itemRgb) {
        stroke = feature.itemRgb;
    } else if ((0, _das.isDasBooleanTrue)(style.COLOR_BY_SCORE2)) {
        var grad = style.BGGRAD || style._gradient;
        if (!grad) {
            grad = (0, _color.makeGradient)(50, style.COLOR1, style.COLOR2, style.COLOR3);
            style._gradient = grad;
        }

        var score2 = feature.score2;
        if (score2 !== undefined || !stroke) {
            score2 = score2 || 0;

            var smin2 = style.MIN2 ? 1.0 * style.MIN2 : 0.0;
            var smax2 = style.MAX2 ? 1.0 * style.MAX2 : 1.0;
            var relScore2 = (1.0 * score2 - smin2) / (smax2 - smin2);

            var step = relScore2 * grad.length | 0;
            R.clamp(0, step, grad.length - 1);
            stroke = grad[step];
        }
    }

    var size = style.SIZE || height;
    if (style.RSIZE) {
        size = 1.0 * style.RSIZE * height;
    }

    if (style.STROKETHRESHOLD) {
        if (size < 1.0 * style.STROKETHRESHOLD) outline = null;
    }

    var mid = (minPos + maxPos) / 2;

    if (glyphType === 'EX') {
        glyph = new Glyphs.ExGlyph(mid, size, stroke);
    } else if (glyphType === 'TRIANGLE') {
        var dir = style.DIRECTION || 'N';
        var width = style.LINEWIDTH || size;
        glyph = new Glyphs.TriangleGlyph(mid, size, dir, width, stroke, outline);
    } else if (glyphType === 'DOT') {
        glyph = new Glyphs.DotGlyph(mid, size, stroke, outline);
    } else if (glyphType === 'PLIMSOLL') {
        glyph = new Glyphs.PlimsollGlyph(mid, size, 0.2 * size, stroke, outline);
    } else if (glyphType === 'SQUARE') {
        glyph = new Glyphs.BoxGlyph(mid - size / 2, 0, size, size, stroke, outline);
    } else if (glyphType === 'STAR') {
        var points = style.POINTS || 5;
        glyph = new Glyphs.StarGlyph(mid, size / 2, points, stroke, outline);
    } else {
        glyph = new Glyphs.CrossGlyph(mid, size, stroke);
    }

    if (fill && fill !== 'none' && maxPos - minPos > 5) {
        var boxGlyph = new Glyphs.BoxGlyph(minPos, 0, maxPos - minPos, size, fill);
        glyph = new Glyphs.GroupGlyph([boxGlyph, glyph]);
    }

    if ((0, _das.isDasBooleanTrue)(style.SCATTER)) {
        var _getScoreMinMax = getScoreMinMax(tier, style),
            _getScoreMinMax2 = _slicedToArray(_getScoreMinMax, 2),
            smin = _getScoreMinMax2[0],
            smax = _getScoreMinMax2[1];

        var _relScoreOrigin = relScoreOrigin(score, smin, smax),
            _relScoreOrigin2 = _slicedToArray(_relScoreOrigin, 2),
            relScore = _relScoreOrigin2[0],
            relOrigin = _relScoreOrigin2[1];
        // console.log(score, relScore, relOrigin);

        if (relScore < 0.0 || relScore > 1.0) {
            // Glyph is out of bounds.
            // Should we allow for "partially showing" glyphs?

            return null;
        } else {
            y = (1.0 - relScore) * requiredHeight;

            quant = { min: smin, max: smax };

            var heightFudge = 0;
            var featureLabel = R.defaultTo(style.LABEL, feature.forceLabel);

            if ((0, _das.isDasBooleanNotFalse)(featureLabel) && label && !noLabel) {
                glyph = new Glyphs.LabelledGlyph(canvas, glyph, label, true, null, featureLabel == 'above' ? 'above' : 'below');
                if (featureLabel === 'above') {
                    heightFudge = glyph.textHeight + 2;
                }
                noLabel = true;
            }
            glyph = new Glyphs.TranslatedGlyph(glyph, 0, y - size / 2 - heightFudge, requiredHeight);
        }
    }

    return [glyph, quant];
}

function featureToGradientLikeGlyph(canvas, tier, feature, y, glyphType, style, forceHeight) {
    var scale = tier.browser.scale;
    var origin = tier.browser.viewStart;

    var score = feature.score;

    var minPos = (feature.min - origin) * scale;
    var maxPos = Math.max((feature.max - origin + 1) * scale, minPos + 1);

    var height = (tier.forceHeight || style.HEIGHT || forceHeight || 12) * 1.0;
    var requiredHeight = height * 1.0;

    var glyph = null;
    var quant = null;

    var centerOnAxis = (0, _das.isDasBooleanTrue)(style["AXISCENTER"]);

    var _getScoreMinMax3 = getScoreMinMax(tier, style),
        _getScoreMinMax4 = _slicedToArray(_getScoreMinMax3, 2),
        smin = _getScoreMinMax4[0],
        smax = _getScoreMinMax4[1];

    // AUTOMIN & AUTOMAX respectively set the lower and upper bounds


    if ((0, _das.isDasBooleanTrue)(style.AUTOMIN)) {
        smin = tier.currentFeaturesMinScore * 0.95;
        console.log("smin:\t" + smin);
    }
    if ((0, _das.isDasBooleanTrue)(style.AUTOMAX)) {
        smax = tier.currentFeaturesMaxScore * 1.05;
        console.log("smax:\t" + smax);
    }

    if (1.0 * score < 1.0 * smin) {
        score = smin;
    }
    if (1.0 * score > 1.0 * smax) {
        score = smax;
    }

    // Shift smin/smax in case we want to center the histogram
    // on the horizontal axis
    if (centerOnAxis) {
        var tmin = tier.quantMin(style);
        var tmax = tier.quantMax(style);

        if ((0, _das.isDasBooleanTrue)(style.AUTOMIN)) {
            tmin = tier.currentFeaturesMinScore * 0.95;
        }
        if ((0, _das.isDasBooleanTrue)(style.AUTOMAX)) {
            tmax = tier.currentFeaturesMaxScore * 1.05;
        }

        smin = tmin - (tmax - tmin) / 2;
        smax = tmax - (tmax - tmin) / 2;
    }

    var _relScoreOrigin3 = relScoreOrigin(score, smin, smax),
        _relScoreOrigin4 = _slicedToArray(_relScoreOrigin3, 2),
        relScore = _relScoreOrigin4[0],
        relOrigin = _relScoreOrigin4[1];

    if (glyphType === 'HISTOGRAM') {
        var originShift = function originShift(x) {
            return x - Math.max(0, relOrigin);
        };
        height = Math.abs(originShift(relScore)) * requiredHeight;
        y = y + originShift(1.0) * requiredHeight;

        if (relScore >= relOrigin) y -= height;

        if (centerOnAxis) y += height / 2;

        if ((0, _das.isDasBooleanTrue)(style["HIDEAXISLABEL"])) quant = null;else quant = { min: smin, max: smax };
    }

    var stroke = style.FGCOLOR || null;
    var fill = style.BGCOLOR || style.COLOR1 || 'green';
    if (style.BGITEM && feature.itemRgb) fill = feature.itemRgb;
    var alpha = style.ALPHA ? 1.0 * style.ALPHA : null;

    if (style.BGGRAD) {
        var grad = style.BGGRAD;
        var step = relScore * grad.length | 0;
        step = R.clamp(0, step, grad.length - 1);
        fill = grad[step];
    }

    if (style.COLOR2) {
        var _grad = style._gradient;
        if (!_grad) {
            _grad = (0, _color.makeGradient)(50, style.COLOR1, style.COLOR2, style.COLOR3);
            style._gradient = _grad;
        }

        var _step = relScore * _grad.length | 0;
        _step = R.clamp(0, _step, _grad.length - 1);
        fill = _grad[_step];
    }

    var tempGlyph = new Glyphs.BoxGlyph(minPos, y, maxPos - minPos, height, fill, stroke, alpha);
    glyph = new Glyphs.TranslatedGlyph(tempGlyph, 0, 0, requiredHeight);

    return [glyph, quant];
}

function featureToPointGlyph(tier, feature, style) {
    var scale = tier.browser.scale;
    var origin = tier.browser.viewStart;

    var score = feature.score;

    var minPos = (feature.min - origin) * scale;
    var maxPos = Math.max((feature.max - origin + 1) * scale, minPos + 1);

    var height = tier.forceHeight || style.HEIGHT || 30;

    var glyph = null;
    var quant = null;

    var _getScoreMinMax5 = getScoreMinMax(tier, style),
        _getScoreMinMax6 = _slicedToArray(_getScoreMinMax5, 2),
        smin = _getScoreMinMax6[0],
        smax = _getScoreMinMax6[1];

    var yscale = 1.0 * height / (smax - smin);
    var relScore = (1.0 * score - smin) / (smax - smin);
    var sc = (score - 1.0 * smin) * yscale | 0;
    quant = { min: smin, max: smax };

    var fill = style.FGCOLOR || style.COLOR1 || 'black';
    if (style.COLOR2) {
        var grad = style._gradient;
        if (!grad) {
            grad = (0, _color.makeGradient)(50, style.COLOR1, style.COLOR2, style.COLOR3);
            style._gradient = grad;
        }

        var step = relScore * grad.length | 0;
        step = R.clamp(0, step, grad.length - 1);
        fill = grad[step];
    }

    glyph = new Glyphs.PointGlyph((minPos + maxPos) / 2, height - sc, height, fill);

    return [glyph, quant];
}

function sequenceGlyph(canvas, tier, feature, style, forceHeight) {
    var scale = tier.browser.scale;
    var origin = tier.browser.viewStart;

    var min = feature.min;
    var max = feature.max;
    var minPos = (feature.min - origin) * scale;
    var maxPos = Math.max((feature.max - origin + 1) * scale, minPos + 1);

    var height = (tier.forceHeight || style.HEIGHT || forceHeight || 12) * 1.0;

    var glyph = null;

    var rawseq = feature.seq;
    var seq = rawseq;
    var rawquals = feature.quals;
    var quals = rawquals;
    var insertionLabels = (0, _das.isDasBooleanTrue)(style.__INSERTIONS);

    var indels = [];
    if (feature.cigar) {
        var ops = (0, _cigar.parseCigar)(feature.cigar);
        seq = '';
        quals = '';
        var cursor = 0;

        ops.forEach(function (co) {
            if (co.op === 'M') {
                seq += rawseq.substr(cursor, co.cnt);
                quals += rawquals.substr(cursor, co.cnt);
                cursor += co.cnt;
            } else if (co.op === 'D') {
                seq += "-".repeat(co.cnt);
                quals += "Z".repeat(co.cnt);
            } else if (co.op === 'I') {
                var inseq = rawseq.substr(cursor, co.cnt);
                var ig = new Glyphs.TranslatedGlyph(new Glyphs.TriangleGlyph(minPos + seq.length * scale, 6, 'S', 5, tier.browser.baseColors['I']), 0, -2, 0);
                if (insertionLabels) ig = new Glyphs.LabelledGlyph(canvas, ig, inseq, false, 'center', 'above', '7px sans-serif');
                ig.feature = { label: 'Insertion: ' + inseq, type: 'insertion', method: 'insertion' };
                indels.push(ig);

                cursor += co.cnt;
            } else if (co.op === 'S') {
                cursor += co.cnt;
            } else {
                console.log('unknown cigop' + co.op);
            }
        });
    }

    var refSeq = getRefSeq(tier, min, max);
    if (seq && refSeq && (style.__SEQCOLOR === 'mismatch' || style.__SEQCOLOR === 'mismatch-all')) {
        var mismatchSeq = [];
        var match = feature.orientation === '-' ? ',' : '.';
        for (var i = 0; i < seq.length; ++i) {
            mismatchSeq.push(seq[i] == refSeq[i] ? match : seq[i]);
        }
        seq = mismatchSeq.join('');
    }

    var strandColor = feature.orientation === '-' ? style._minusColor || 'lightskyblue' : style._plusColor || 'lightsalmon';

    if (style.__disableQuals) quals = false;

    glyph = new Glyphs.SequenceGlyph(tier.browser.baseColors, strandColor, minPos, maxPos, height, seq, refSeq, style.__SEQCOLOR, quals, !(0, _das.isDasBooleanTrue)(style.__CLEARBG), tier.scaleVertical);

    if (insertionLabels) glyph = new Glyphs.TranslatedGlyph(glyph, 0, 7);

    if (indels.length > 0) {
        indels.splice(0, 0, glyph);
        glyph = new Glyphs.GroupGlyph(indels);
    }

    return glyph;
}

function makeLinePlot(features, style, tier, yshift) {
    yshift = yshift || 0;

    var origin = tier.browser.viewStart,
        scale = tier.browser.scale;
    var height = tier.forceHeight || style.HEIGHT || 30;
    var min = tier.quantMin(style);
    var max = tier.quantMax(style);

    // AUTOMIN & AUTOMAX respectively set the lower and upper bounds
    if ((0, _das.isDasBooleanTrue)(style.AUTOMIN)) {
        // add some basically arbitrary padding
        min = tier.currentFeaturesMinScore * 0.95;
    }
    if ((0, _das.isDasBooleanTrue)(style.AUTOMAX)) {
        max = tier.currentFeaturesMaxScore * 1.05;
    }

    var yscale = 1.0 * height / (max - min);
    var color = style.FGCOLOR || style.COLOR1 || 'black';

    var prevSign = 1;
    var curSign = null;

    var curGlyphPoints = [];
    var glyphSequences = [];

    var prevPoint = null;

    features.forEach(function (f) {
        var px = (((f.min | 0) + (f.max | 0)) / 2 - origin) * scale;
        var sc = (f.score - 1.0 * min) * yscale | 0;

        // Additive tracks are always above the x-axis, and are colored
        // depending on whether the score is positive or negative.
        if ((0, _das.isDasBooleanTrue)(style.ADDITIVE)) {
            curSign = f.score < 0 ? -1 : 1;

            if (curSign !== prevSign) {
                glyphSequences.push({
                    points: curGlyphPoints,
                    color: prevSign === 1 ? style.POSCOLOR : style.NEGCOLOR
                });
                curGlyphPoints = [];
                // Need to add the previous point to this sequence,
                // otherwise there is a gap in the resulting plot
                curGlyphPoints.push(prevPoint);
            }
            prevSign = curSign;
        } else {
            curSign = 1;
        }

        var py = height - sc * curSign + yshift;
        prevPoint = { x: px, y: py };
        curGlyphPoints.push(prevPoint);
    });

    // Need to add the final sequence of points as well.
    if ((0, _das.isDasBooleanTrue)(style.ADDITIVE)) {
        color = curSign === 1 ? style.POSCOLOR : style.NEGCOLOR;
    }
    glyphSequences.push({
        points: curGlyphPoints,
        color: color
    });

    var lggs = glyphSequences.map(function (gs) {
        var lgg = new Glyphs.LineGraphGlyph(gs.points, gs.color, height);
        lgg.quant = { min: min, max: max };

        if (style.ZINDEX) lgg.zindex = style.ZINDEX | 0;

        return lgg;
    });

    return lggs;
}

function makeStackedBars(features, tier) {
    var glyphs = [];

    var posStacks = [],
        negStacks = [];

    var scale = tier.browser.scale,
        origin = tier.browser.viewStart;
    for (var fi = 0; fi < features.length; ++fi) {
        var feature = features[fi];
        var style = tier.styleForFeature(feature);
        var score = feature.score * 1.0;

        var height = tier.forceHeight || style.HEIGHT || 12;
        var requiredHeight = height = 1.0 * height;

        var min = feature.min;
        var max = feature.max;

        var minPos = (min - origin) * scale;
        var rawMaxPos = (max - origin + 1) * scale;
        var maxPos = Math.max(rawMaxPos, minPos + 1);

        // This should somewhat match the 'HISTOGRAM' path.

        var smin = tier.quantMin(style);
        var smax = tier.quantMax(style);

        if (!smax) {
            if (smin < 0) {
                smax = 0;
            } else {
                smax = 10;
            }
        } else {
            smax = smax * 1.0;
        }

        if (!smin) {
            smin = 0;
        } else {
            smin = smin * 1.0;
        }

        var stackOrigin;
        if (score >= 0) {
            stackOrigin = posStacks[min] || 0;
            posStacks[min] = stackOrigin + score;
        } else {
            stackOrigin = negStacks[min] || 0;
            negStacks[min] = stackOrigin + score;
        }

        if (stackOrigin > smax || stackOrigin < smin) {
            // Stack has extended outside of range.
            continue;
        }

        if (stackOrigin + score < smin) {
            score = smin - stackOrigin;
        }
        if (stackOrigin + score > smax) {
            score = smax - stackOrigin;
        }

        var relScoreEnd = (score + stackOrigin - smin) / (smax - smin);
        var relScoreStart = (stackOrigin - smin) / (smax - smin);
        var relScoreMax = Math.max(relScoreStart, relScoreEnd);
        var relScoreMin = Math.min(relScoreStart, relScoreEnd);

        height = (relScoreMax - relScoreMin) * requiredHeight;
        var y = (1.0 - relScoreMax) * requiredHeight;

        var stroke = style.FGCOLOR || null;
        var fill = style.BGCOLOR || style.COLOR1 || 'green';
        if (style.BGITEM && feature.itemRgb) fill = feature.itemRgb;
        var alpha = style.ALPHA ? 1.0 * style.ALPHA : null;

        var gg = new Glyphs.BoxGlyph(minPos, y, maxPos - minPos, height, fill, stroke, alpha);
        gg = new Glyphs.TranslatedGlyph(gg, 0, 0, requiredHeight);
        gg.feature = feature;
        gg.quant = {
            min: smin, max: smax
        };
        if (style.ZINDEX) {
            gg.zindex = style.ZINDEX | 0;
        }
        glyphs.push(gg);
    }
    return glyphs;
}

// height is subtier height
function createQuantOverlay(tier, height) {
    var retina = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var width = 50;

    tier.quantOverlay.height = height;
    tier.quantOverlay.width = retina ? width * 2 : width;
    tier.quantOverlay.style.height = '' + (retina ? height / 2 : height) + 'px';
    tier.quantOverlay.style.width = '' + width + 'px';
    tier.quantOverlay.style.display = 'block';

    var canvas = tier.quantOverlay.getContext('2d');

    if (retina) {
        canvas.scale(2, 2);
    }

    return canvas;
}

function paintQuant(canvas, tier, quant, tics) {
    canvas.save();

    var h = tier.quantOverlay.height;
    var w = 100;

    var ticSpacing = (h + tier.padding * 2) / tics;
    var ticInterval = (quant.max - quant.min) / tics;

    canvas.fillStyle = 'white';
    canvas.globalAlpha = 0.6;
    if (tier.browser.rulerLocation == 'right') {
        canvas.fillRect(w - 30, 0, 30, h + tier.padding * 2);
    } else {
        canvas.fillRect(0, 0, 30, h + tier.padding * 2);
    }
    canvas.globalAlpha = 1.0;

    canvas.strokeStyle = 'black';
    canvas.lineWidth = 1;
    canvas.beginPath();
    if (tier.browser.rulerLocation == 'right') {
        canvas.moveTo(w - 8, tier.padding);
        canvas.lineTo(w, tier.padding);
        canvas.lineTo(w, h + tier.padding);
        canvas.lineTo(w - 8, h + tier.padding);

        for (var t = 1; t < tics - 1; t++) {
            var ty = t * ticSpacing;
            canvas.moveTo(w, ty);
            canvas.lineTo(w - 5, ty);
        }
    } else {
        canvas.moveTo(8, tier.padding);
        canvas.lineTo(0, tier.padding);
        canvas.lineTo(0, h + tier.padding);
        canvas.lineTo(8, h + tier.padding);

        for (var _t = 1; _t < tics - 1; _t++) {
            var _ty = _t * ticSpacing;
            canvas.moveTo(0, _ty);
            canvas.lineTo(5, _ty);
        }
    }
    canvas.stroke();

    canvas.fillStyle = 'black';

    if (tier.browser.rulerLocation == 'right') {
        canvas.textAlign = 'right';
        canvas.fillText((0, _numformats.formatQuantLabel)(quant.max), w - 9, 8);
        canvas.fillText((0, _numformats.formatQuantLabel)(quant.min), w - 9, h + tier.padding);

        for (var _t2 = 1; _t2 < tics - 1; _t2++) {
            var _ty2 = _t2 * ticSpacing;
            canvas.fillText((0, _numformats.formatQuantLabel)(1.0 * quant.max - _t2 * ticInterval), w - 9, _ty2 + 3);
        }
    } else {
        canvas.textAlign = 'left';
        canvas.fillText((0, _numformats.formatQuantLabel)(quant.max), 9, 8);
        canvas.fillText((0, _numformats.formatQuantLabel)(quant.min), 9, h + tier.padding);

        for (var _t3 = 1; _t3 < tics - 1; _t3++) {
            var _ty3 = _t3 * ticSpacing;
            canvas.fillText((0, _numformats.formatQuantLabel)(1.0 * quant.max - _t3 * ticInterval), 9, _ty3 + 3);
        }
    }

    canvas.restore();
}

function featureLookup(tier, rx, ry) {
    var st = tier.subtiers;
    if (!st) {
        return;
    }

    var sti = 0;
    ry -= tier.padding;
    while (sti < st.length && ry > st[sti].height && sti < st.length - 1) {
        ry = ry - st[sti].height - tier.padding;
        ++sti;
    }
    if (sti >= st.length) {
        return;
    }

    var glyphs = st[sti].glyphs;
    var viewCenter = (tier.browser.viewStart + tier.browser.viewEnd) / 2;
    var offset = (tier.glyphCacheOrigin - tier.browser.viewStart) * tier.browser.scale;
    rx -= offset;

    return glyphLookup(glyphs, rx, ry);
}

function glyphLookup(glyphs, rx, ry, matches) {
    matches = matches || [];

    for (var gi = glyphs.length - 1; gi >= 0; --gi) {
        var g = glyphs[gi];
        if (!g.notSelectable && g.min() <= rx && g.max() >= rx) {
            if (g.minY) {
                if (ry < g.minY() || ry > g.maxY()) continue;
            }

            if (g.feature) {
                matches.push(g.feature);
            } else if (g.group) {
                matches.push(g.group);
            }

            if (g.glyphs) {
                return glyphLookup(g.glyphs, rx, ry, matches);
            } else if (g.glyph) {
                return glyphLookup([g.glyph], rx, ry, matches);
            } else {
                return matches;
            }
        }
    }
    return matches;
}

},{"./cigar.js":8,"./color.js":9,"./das.js":10,"./feature-draw.js":20,"./glyphs.js":23,"./numformats":29,"./sequence-draw.js":35,"./spans.js":40,"./utils.js":55,"ramda":62}],12:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// domui.js: SVG UI components
//

"use strict";

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;
}

Browser.prototype.removeAllPopups = function () {
    for (var pi = 0; pi < this.popups.length; ++pi) {
        var popup = this.popups[pi];
        if (popup.onClose) {
            try {
                popup.onClose();
            } catch (ex) {
                console.log(ex);
            }
        }
        this.hPopupHolder.removeChild(popup.component);
    }
    this.popups = [];
};

Browser.prototype.makeTooltip = function (ele, text) {
    ele.title = text;
};

Browser.prototype.popit = function (ev, name, ele, opts) {
    var thisB = this;
    if (!opts) opts = {};
    if (!ev) ev = {};

    var width = opts.width || 200;

    var mx, my;

    if (ev.clientX) {
        var mx = ev.clientX,
            my = ev.clientY;
    } else {
        mx = 500;my = 50;
    }
    mx += document.documentElement.scrollLeft || document.body.scrollLeft;
    my += document.documentElement.scrollTop || document.body.scrollTop;
    var winWidth = window.innerWidth;

    var top = my;
    var left = Math.min(mx - width / 2 - 4, winWidth - width - 30);

    var popup = makeElement('div');
    popup.className = 'popover fade ' + (ev.clientX ? 'bottom ' : '') + 'in';
    popup.style.display = 'block';
    popup.style.position = 'absolute';
    popup.style.top = '' + top + 'px';
    popup.style.left = '' + left + 'px';
    popup.style.width = width + 'px';
    if (width > 276) {
        // HACK Bootstrappification...
        popup.style.maxWidth = width + 'px';
    }

    popup.appendChild(makeElement('div', null, { className: 'arrow' }));

    if (name) {
        var closeButton = makeElement('button', '', { className: 'close' });
        closeButton.innerHTML = '&times;';

        closeButton.addEventListener('mouseover', function (ev) {
            closeButton.style.color = 'red';
        }, false);
        closeButton.addEventListener('mouseout', function (ev) {
            closeButton.style.color = 'black';
        }, false);
        closeButton.addEventListener('click', function (ev) {
            ev.preventDefault();ev.stopPropagation();
            thisB.removeAllPopups();
        }, false);
        var tbar = makeElement('h4', [makeElement('span', name, null, { maxWidth: '200px' }), closeButton], {/*className: 'popover-title' */}, { paddingLeft: '10px', paddingRight: '10px' });

        if (!opts.disableDrag) {
            var dragOX, dragOY;
            var moveHandler, _upHandler;
            moveHandler = function moveHandler(ev) {
                ev.stopPropagation();ev.preventDefault();
                left = left + (ev.clientX - dragOX);
                if (left < 8) {
                    left = 8;
                }if (left > winWidth - width - 32) {
                    left = winWidth - width - 26;
                }
                top = top + (ev.clientY - dragOY);
                top = Math.max(10, top);
                popup.style.top = '' + top + 'px';
                popup.style.left = '' + Math.min(left, winWidth - width - 10) + 'px';
                dragOX = ev.clientX;dragOY = ev.clientY;
            };
            _upHandler = function upHandler(ev) {
                ev.stopPropagation();ev.preventDefault();
                window.removeEventListener('mousemove', moveHandler, false);
                window.removeEventListener('mouseup', _upHandler, false);
            };
            tbar.addEventListener('mousedown', function (ev) {
                ev.preventDefault();ev.stopPropagation();
                dragOX = ev.clientX;dragOY = ev.clientY;
                window.addEventListener('mousemove', moveHandler, false);
                window.addEventListener('mouseup', _upHandler, false);
            }, false);
        }

        popup.appendChild(tbar);
    }

    popup.appendChild(makeElement('div', ele, { className: 'popover-content' }, {
        padding: '0px'
    }));
    this.hPopupHolder.appendChild(popup);

    this.popups.push({
        component: popup,
        onClose: opts.onClose
    });
};

function makeTreeTableSection(title, content, visible) {

    var ttButton = makeElement('i');
    function update() {
        if (visible) {
            ttButton.className = 'fa fa-caret-down';
            content.style.display = 'table';
        } else {
            ttButton.className = 'fa fa-caret-right';
            content.style.display = 'none';
        }
    }
    update();

    var showHide = function showHide(ev) {
        ev.preventDefault();ev.stopPropagation();
        visible = !visible;
        update();
    };

    ttButton.addEventListener('click', showHide, false);

    var heading = makeElement('h6', [ttButton, ' ', title], {}, { display: 'block', background: 'gray', color: 'white', width: '100%', padding: '5px 2px', margin: '0px', cursor: 'pointer' });
    heading.addEventListener('click', showHide, false);

    return makeElement('div', [heading, content], {});
}

if (typeof module !== 'undefined') {
    module.exports = {
        makeTreeTableSection: makeTreeTableSection
    };
}

},{"./cbrowser":6,"./utils":55}],13:[function(require,module,exports){
/* jshint esversion: 6 */
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.drawTier = exports.renderTier = undefined;

var _defaultRenderer = require("./default-renderer");

var DefaultRenderer = _interopRequireWildcard(_defaultRenderer);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.renderTier = renderTier;
exports.drawTier = drawTier;


function renderTier(status, tier) {
    drawTier(tier);
    tier.updateStatus(status);
}

function drawTier(tier) {
    var canvas = tier.viewport.getContext("2d");
    var retina = tier.browser.retina && window.devicePixelRatio > 1;
    if (retina) {
        canvas.scale(2, 2);
    }

    var features = tier.currentFeatures;
    var sequence = tier.currentSequence;
    if (tier.sequenceSource) {
        DefaultRenderer.drawSeqTier(tier, sequence);
    } else if (features) {
        DefaultRenderer.prepareSubtiers(tier, canvas);
    } else {
        console.log("No sequence or features in tier!");
    }

    if (tier.subtiers) {
        DefaultRenderer.prepareViewport(tier, canvas, retina, true);
    }

    tier.drawOverlay();
    tier.paintQuant();

    if (typeof tier.dasSource.drawCallback === "function") {
        tier.dasSource.drawCallback(canvas, tier);
    }

    tier.originHaxx = 0;
    tier.browser.arrangeTiers();
}

},{"./default-renderer":11}],14:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// encode.js: interface for ENCODE DCC services
//

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (typeof require !== 'undefined') {
    var Promise = require('es6-promise').Promise;
}

function lookupEncodeURI(uri, json) {
    if (uri.indexOf('?') < 0) uri = uri + '?soft=true';

    return new Promise(function (accept, reject) {
        var req = new XMLHttpRequest();
        req.onreadystatechange = function () {
            if (req.readyState == 4) {
                if (req.status >= 300) {
                    reject('Error code ' + req.status);
                } else {
                    var resp = JSON.parse(req.response);
                    accept(json ? resp : resp.location);
                }
            }
        };

        req.open('GET', uri, true);
        req.setRequestHeader('Accept', 'application/json');
        req.responseType = 'text';
        req.send();
    });
}

function EncodeURLHolder(url) {
    this.rawurl = url;
}

EncodeURLHolder.prototype.getURLPromise = function () {
    if (this.urlPromise && this.urlPromiseValidity > Date.now()) {
        return this.urlPromise;
    } else {
        this.urlPromise = lookupEncodeURI(this.rawurl, true).then(function (resp) {
            return resp.location;
        });
        this.urlPromiseValidity = Date.now() + 12 * 3600 * 1000;
        return this.urlPromise;
    }
};

function EncodeFetchable(url, start, end, opts) {
    if (!opts) {
        if ((typeof start === 'undefined' ? 'undefined' : _typeof(start)) === 'object') {
            opts = start;
            start = undefined;
        } else {
            opts = {};
        }
    }

    this.url = typeof url === 'string' ? new EncodeURLHolder(url) : url;
    this.start = start || 0;
    if (end) {
        this.end = end;
    }
    this.opts = opts;
}

EncodeFetchable.prototype.slice = function (s, l) {
    if (s < 0) {
        throw 'Bad slice ' + s;
    }

    var ns = this.start,
        ne = this.end;
    if (ns && s) {
        ns = ns + s;
    } else {
        ns = s || ns;
    }
    if (l && ns) {
        ne = ns + l - 1;
    } else {
        ne = ne || l - 1;
    }
    return new EncodeFetchable(this.url, ns, ne, this.opts);
};

EncodeFetchable.prototype.fetchAsText = function (callback) {
    var self = this;
    var req = new XMLHttpRequest();
    var length;
    self.url.getURLPromise().then(function (url) {
        req.open('GET', url, true);

        if (self.end) {
            if (self.end - self.start > 100000000) {
                throw 'Monster fetch!';
            }
            req.setRequestHeader('Range', 'bytes=' + self.start + '-' + self.end);
            length = self.end - self.start + 1;
        }

        req.onreadystatechange = function () {
            if (req.readyState == 4) {
                if (req.status == 200 || req.status == 206) {
                    return callback(req.responseText);
                } else {
                    return callback(null);
                }
            }
        };
        if (self.opts.credentials) {
            req.withCredentials = true;
        }
        req.send();
    }).catch(function (err) {
        console.log(err);
        return callback(null);
    });
};

EncodeFetchable.prototype.salted = function () {
    return this;
};

EncodeFetchable.prototype.fetch = function (callback, attempt, truncatedLength) {
    var self = this;

    attempt = attempt || 1;
    if (attempt > 3) {
        return callback(null);
    }

    self.url.getURLPromise().then(function (url) {
        var req = new XMLHttpRequest();
        var length;
        req.open('GET', url, true);
        req.overrideMimeType('text/plain; charset=x-user-defined');
        if (self.end) {
            if (self.end - self.start > 100000000) {
                throw 'Monster fetch!';
            }
            req.setRequestHeader('Range', 'bytes=' + self.start + '-' + self.end);
            length = self.end - self.start + 1;
        }
        req.responseType = 'arraybuffer';
        req.onreadystatechange = function () {
            if (req.readyState == 4) {
                if (req.status == 200 || req.status == 206) {
                    if (req.response) {
                        var bl = req.response.byteLength;
                        if (length && length != bl && (!truncatedLength || bl != truncatedLength)) {
                            return self.fetch(callback, attempt + 1, bl);
                        } else {
                            return callback(req.response);
                        }
                    } else if (req.mozResponseArrayBuffer) {
                        return callback(req.mozResponseArrayBuffer);
                    } else {
                        var r = req.responseText;
                        if (length && length != r.length && (!truncatedLength || r.length != truncatedLength)) {
                            return self.fetch(callback, attempt + 1, r.length);
                        } else {
                            return callback(bstringToBuffer(req.responseText));
                        }
                    }
                } else {
                    return self.fetch(callback, attempt + 1);
                }
            }
        };
        if (self.opts.credentials) {
            req.withCredentials = true;
        }
        req.send();
    }).catch(function (err) {
        console.log(err);
    });
};

function bstringToBuffer(result) {
    if (!result) {
        return null;
    }

    var ba = new Uint8Array(result.length);
    for (var i = 0; i < ba.length; ++i) {
        ba[i] = result.charCodeAt(i);
    }
    return ba.buffer;
}

if (typeof module !== 'undefined') {
    module.exports = {
        lookupEncodeURI: lookupEncodeURI,
        EncodeFetchable: EncodeFetchable
    };
}

},{"es6-promise":59}],15:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// ensembljson.js -- query the Ensembl REST API.
//

"use strict";

if (typeof require !== 'undefined') {
    var sa = require('./sourceadapters');
    var dalliance_registerSourceAdapterFactory = sa.registerSourceAdapterFactory;
    var FeatureSourceBase = sa.FeatureSourceBase;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;
}

function EnsemblFeatureSource(source) {
    FeatureSourceBase.call(this);
    this.source = source;
    this.base = source.uri || '//rest.ensembl.org';
    if (this.base.indexOf('//') === 0) {
        var proto = window.location.protocol;
        if (proto == 'http:' || proto == 'https:') {
            // Protocol-relative URLs okay.
        } else {
            this.base = 'http:' + this.base;
        }
    }
    this.species = source.species || 'human';

    if (typeof source.type === 'string') {
        this.type = [source.type];
    } else {
        this.type = source.type || ['regulatory'];
    }
}

EnsemblFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);
EnsemblFeatureSource.prototype.constructor = EnsemblFeatureSource;

EnsemblFeatureSource.prototype.getStyleSheet = function (callback) {
    var stylesheet = new DASStylesheet();

    var tsStyle = new DASStyle();
    tsStyle.glyph = '__NONE';
    if (this.type.indexOf('exon') >= 0) stylesheet.pushStyle({ type: 'transcript' }, null, tsStyle);
    if (this.type.indexOf('exon') >= 0 || this.type.indexOf('transcript') >= 0) stylesheet.pushStyle({ type: 'gene' }, null, tsStyle);

    var cdsStyle = new DASStyle();
    cdsStyle.glyph = 'BOX';
    cdsStyle.FGCOLOR = 'black';
    cdsStyle.BGCOLOR = 'red';
    cdsStyle.HEIGHT = 8;
    cdsStyle.BUMP = true;
    cdsStyle.LABEL = true;
    cdsStyle.ZINDEX = 10;
    stylesheet.pushStyle({ type: 'cds' }, null, cdsStyle);

    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'SQUARE';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        // varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'blue';
        stylesheet.pushStyle({ type: 'variation', method: '.+_UTR_variant' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'TRIANGLE';
        varStyle.DIRECTION = 'S';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        // varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'blue';
        stylesheet.pushStyle({ type: 'variation', method: 'missense_variant' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'TRIANGLE';
        varStyle.DIRECTION = 'N';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        // varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'blue';
        stylesheet.pushStyle({ type: 'variation', method: 'splice_.+_variant' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'STAR';
        varStyle.POINTS = 6;
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        // varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'blue';
        stylesheet.pushStyle({ type: 'variation', method: 'regulatory_region_variant' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'PLIMSOLL';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        // varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'rgb(50,80,255)';
        varStyle.STROKECOLOR = 'black';
        stylesheet.pushStyle({ type: 'variation' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'SQUARE';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'red';
        stylesheet.pushStyle({ type: 'indel', method: '.+_UTR_variant' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'TRIANGLE';
        varStyle.DIRECTION = 'S';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'red';
        stylesheet.pushStyle({ type: 'indel', method: 'missense_variant' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'TRIANGLE';
        varStyle.DIRECTION = 'N';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'red';
        stylesheet.pushStyle({ type: 'indel', method: 'splice_.+_variant' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'STAR';
        varStyle.POINTS = 6;
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'red';
        stylesheet.pushStyle({ type: 'indel', method: 'regulatory_region_variant' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'PLIMSOLL';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'red';
        varStyle.STROKECOLOR = 'black';
        stylesheet.pushStyle({ type: 'indel' }, null, varStyle);
    }

    var wigStyle = new DASStyle();
    wigStyle.glyph = 'BOX';
    wigStyle.FGCOLOR = 'black';
    wigStyle.BGCOLOR = 'orange';
    wigStyle.HEIGHT = 8;
    wigStyle.BUMP = true;
    wigStyle.LABEL = true;
    wigStyle.ZINDEX = 20;
    stylesheet.pushStyle({ type: 'default' }, null, wigStyle);
    return callback(stylesheet);
};

EnsemblFeatureSource.prototype.getScales = function () {
    return [];
};

EnsemblFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback) {
    var thisB = this;
    var url = this.base + '/overlap/region/' + this.species + '/' + chr + ':' + min + '-' + max;

    var filters = [];
    for (var ti = 0; ti < this.type.length; ++ti) {
        filters.push('feature=' + this.type[ti]);
    }
    filters.push('content-type=application/json');
    url = url + '?' + filters.join(';');

    var req = new XMLHttpRequest();
    req.onreadystatechange = function () {
        if (req.readyState == 4) {
            thisB.busy--;
            thisB.notifyActivity();

            if (req.status >= 300) {
                var err = 'Error code ' + req.status;
                try {
                    var jr = JSON.parse(req.response);
                    if (jr.error) {
                        err = jr.error;
                    }
                } catch (ex) {};

                callback(err, null);
            } else {
                var jf = JSON.parse(req.response);
                var features = [];
                for (var fi = 0; fi < jf.length; ++fi) {
                    var j = jf[fi];

                    var notes = [];
                    var f = new DASFeature();
                    f.segment = chr;
                    f.min = j['start'] | 0;
                    f.max = j['end'] | 0;
                    f.type = j.feature_type || 'unknown';
                    f.id = j.ID;

                    if (j.Parent) {
                        var grp = new DASGroup();
                        grp.id = j.Parent;
                        f.groups = [grp];
                    }

                    if (j.strand) {
                        if (j.strand < 0) f.orientation = '-';else if (j.strand > 0) f.orientation = '+';
                    }

                    if (j.consequence_type) f.method = j.consequence_type;

                    if (j.alt_alleles) {
                        notes.push('Alleles=' + j.alt_alleles.join('/'));
                        if (j.alt_alleles.length > 1) {
                            if (j.alt_alleles[1].length != j.alt_alleles[0].length || j.alt_alleles[1] == '-') {
                                f.type = 'indel';
                            }
                        }
                    }

                    if (notes.length > 0) {
                        f.notes = notes;
                    }
                    features.push(f);
                }
                callback(null, features);
            }
        }
    };

    thisB.busy++;
    thisB.notifyActivity();

    req.open('GET', url, true);
    req.responseType = 'text';
    req.send();
};

EnsemblFeatureSource.prototype.capabilities = function () {
    var caps = {};
    if (this.type && this.type.indexOf('transcript') >= 0) {
        caps.search = ['gene'];
    }
    return caps;
};

EnsemblFeatureSource.prototype.search = function (query, callback) {
    var url = this.base + '/lookup/symbol/' + this.species + '/' + query + '?content-type=application/json';
    var req = new XMLHttpRequest();
    req.onreadystatechange = function () {
        if (req.readyState == 4) if (req.status >= 300 || req.status < 200) {
            var err = 'Error code ' + req.status;
            try {
                var jr = JSON.parse(req.response);
                if (jr.error) {
                    err = jr.error;
                }
            } catch (ex) {};

            if (req.status == 400) // E! returns an error if the lookup fails.  Who knows?
                return callback([]);else return callback(null, err);
        } else {
            var resp = JSON.parse(req.response);
            var result = [];

            if (resp && resp.seq_region_name) {
                result.push({
                    segment: resp.seq_region_name,
                    min: resp.start,
                    max: resp.end
                });
            }

            return callback(result);
        }
    };

    req.open('GET', url, true);
    req.responseType = 'text';
    req.send();
};

dalliance_registerSourceAdapterFactory('ensembl', function (source) {
    return { features: new EnsemblFeatureSource(source) };
});

},{"./das":10,"./sourceadapters":38}],16:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// export-config.js
//

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;

    var sha1 = require('./sha1');
    var hex_sha1 = sha1.hex_sha1;

    var das = require('./das');
    var copyStylesheet = das.copyStylesheet;
}

Browser.prototype.exportFullConfig = function (opts) {
    opts = opts || {};

    var config = {
        chr: this.chr,
        viewStart: this.viewStart | 0,
        viewEnd: this.viewEnd | 0,
        cookieKey: 'dalliance_' + hex_sha1(Date.now()),

        coordSystem: this.coordSystem,

        sources: this.exportSourceConfig(),

        chains: this.exportChains()
    };

    if (this.prefix) config.prefix = this.prefix;

    return config;
};

Browser.prototype.exportChains = function () {
    var cc = {};
    var cs = this.chains || {};
    for (var k in cs) {
        cc[k] = cs[k].exportConfig();
    }
    return cc;
};

Browser.prototype.exportSourceConfig = function (opts) {
    opts = opts || {};

    var sourceConfig = [];
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var tier = this.tiers[ti];
        var source = shallowCopy(tier.dasSource);

        if (source.noPersist) continue;

        source.coords = undefined;
        source.props = undefined;
        if (!source.disabled) source.disabled = undefined;

        if (tier.config.stylesheet) {
            source.style = copyStylesheet(tier.config.stylesheet).styles;
            source.stylesheet_uri = undefined;
        } else if (source.style) {
            source.style = copyStylesheet({ styles: source.style }).styles;
        }

        if (typeof tier.config.name === 'string') {
            source.name = tier.config.name;
        }

        if (tier.config.height !== undefined) {
            source.forceHeight = tier.config.height;
        }
        if (tier.config.forceMin !== undefined) {
            source.forceMin = tier.config.forceMin;
        }
        if (tier.config.forceMinDynamic) source.forceMinDynamic = tier.config.forceMinDynamic;
        if (tier.config.forceMax !== undefined) {
            source.forceMax = tier.config.forceMax;
        }
        if (tier.config.bumped !== undefined) {
            source.bumped = tier.config.bumped;
        }
        if (tier.config.forceMaxDynamic) source.forceMaxDynamic = tier.config.forceMaxDynamic;

        sourceConfig.push(source);
    }

    return sourceConfig;
};

Browser.prototype.exportPageTemplate = function (opts) {
    opts = opts || {};
    var template = '<html>\n' + '  <head>\n' + '    <script language="javascript" src="' + this.resolveURL('$$dalliance-compiled.js') + '"></script>\n' + '    <script language="javascript">\n' + '      var dalliance_browser = new Browser(' + JSON.stringify(this.exportFullConfig(opts), null, 2) + ');\n' + '    </script>\n' + '  </head>\n' + '  <body>\n' + '    <div id="svgHolder">Dalliance goes here</div>\n' + '  </body>\n' + '<html>\n';

    return template;
};

},{"./cbrowser":6,"./das":10,"./sha1":37,"./utils":55}],17:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// export-image.js
//

"use strict";

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var g = require('./glyphs');
    var OverlayLabelCanvas = g.OverlayLabelCanvas;

    var nf = require('./numformats');
    var formatQuantLabel = nf.formatQuantLabel;
    var formatLongInt = nf.formatLongInt;

    var makeElement = require('./utils').makeElement;

    var VERSION = require('./version');

    var drawSeqTierGC = require('./sequence-draw').drawSeqTierGC;
}

function fillTextRightJustified(g, text, x, y) {
    g.fillText(text, x - g.measureText(text).width, y);
}

Browser.prototype.exportImage = function (opts) {
    opts = opts || {};

    var fpw = opts.width || this.featurePanelWidth;
    var padding = 3;
    var ypos = 0;
    if (opts.banner || opts.region) {
        ypos = 40;
    }

    var backupFPW = this.featurePanelWidth;
    var backupScale = this.scale;
    this.featurePanelWidth = fpw;
    this.scale = this.featurePanelWidth / (this.viewEnd - this.viewStart);

    var totHeight = ypos;
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        if (ti > 0) totHeight += padding;
        var tier = this.tiers[ti];

        tier.backupSubtiers = tier.subtiers;
        tier.backupOriginHaxx = tier.originHaxx;
        tier.backupLayoutHeight = tier.layoutHeight;

        if (tier.subtiers) {
            var renderer = this.getTierRenderer(tier);
            if (renderer && renderer.prepareSubtiers) {
                renderer.prepareSubtiers(tier, tier.viewport.getContext('2d'));
            }

            if (tier.subtiers) {
                var lh = tier.padding;
                for (var s = 0; s < tier.subtiers.length; ++s) {
                    lh = lh + tier.subtiers[s].height + tier.padding;
                }
                lh += 6;
                tier.layoutHeight = Math.max(lh, this.minTierHeight);
            }
        }

        if (tier.layoutHeight !== undefined) totHeight += tier.layoutHeight;
    }
    var mult = opts.resolutionMultiplier || 1.0;
    var font = '10px sans-serif';
    var margin = 200;

    {
        var tmpCanvas = makeElement('canvas', null, 1, 1);
        var tmpG = tmpCanvas.getContext('2d');
        tmpG.font = font;
        for (var ti = 0; ti < this.tiers.length; ++ti) {
            var tier = this.tiers[ti];
            var labelName;
            if (typeof tier.config.name === 'string') labelName = tier.config.name;else labelName = tier.dasSource.name;
            var labelWidth = tmpG.measureText(labelName).width;
            labelWidth += 32;
            if (labelWidth > margin) margin = labelWidth;
        }
    }

    var cw = (fpw + margin) * mult | 0;
    var ch = totHeight * mult | 0;
    var c = makeElement('canvas', null, { width: cw, height: ch });
    var g = c.getContext('2d');
    g.fillStyle = 'white';
    g.fillRect(0, 0, cw, ch);

    g.scale(mult, mult);

    if (opts.region) {
        g.save();
        g.fillStyle = 'black';
        g.font = '12pt sans-serif';
        g.fillText(this.chr + ':' + formatLongInt(this.viewStart) + '..' + formatLongInt(this.viewEnd), margin + 100, 28);
        g.restore();
    }

    if (opts.banner) {
        g.save();
        g.fillStyle = 'black';
        g.font = '12pt sans-serif';
        fillTextRightJustified(g, 'Graphics from Biodalliance ' + VERSION, margin + fpw - 100, 28);
        g.restore();
    }

    g.font = font;

    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var tier = this.tiers[ti];
        var offset = (tier.glyphCacheOrigin - this.viewStart) * this.scale;

        var oc = new OverlayLabelCanvas();
        g.save(); // 1
        g.translate(0, ypos);

        g.save(); // 2
        g.beginPath();
        g.moveTo(margin, 0);
        g.lineTo(margin + fpw, 0);
        g.lineTo(margin + fpw, tier.layoutHeight);
        g.lineTo(margin, tier.layoutHeight);
        g.closePath();
        g.clip();
        g.translate(margin, 0);

        g.save(); // 3
        g.translate(offset, 0);
        if (tier.subtiers) {
            tier.paintToContext(g, oc, offset + 1000);
        } else {
            drawSeqTierGC(tier, tier.currentSequence, g);
        }
        g.restore(); // 2

        g.save(); // 3
        g.translate(offset, 0);
        oc.draw(g, -offset, fpw - offset);
        g.restore(); // 2
        g.restore(); // 1

        var hasQuant = false;
        var pos = 0;
        var subtiers = tier.subtiers || [];
        for (var sti = 0; sti < subtiers.length; ++sti) {
            var subtier = subtiers[sti];

            if (subtier.quant) {
                hasQuant = true;
                var q = subtier.quant;
                var h = subtier.height;

                var numTics = 2;
                if (h > 40) {
                    numTics = 1 + (h / 20 | 0);
                }
                var ticSpacing = h / (numTics - 1);
                var ticInterval = (q.max - q.min) / (numTics - 1);

                g.beginPath();
                g.moveTo(margin + 5, pos);
                g.lineTo(margin, pos);
                g.lineTo(margin, pos + subtier.height);
                g.lineTo(margin + 5, pos + subtier.height);
                for (var t = 1; t < numTics - 1; ++t) {
                    var ty = t * ticSpacing;
                    g.moveTo(margin, pos + ty);
                    g.lineTo(margin + 3, pos + ty);
                }
                g.strokeStyle = 'black';
                g.strokeWidth = 2;
                g.stroke();

                g.fillStyle = 'black';
                fillTextRightJustified(g, formatQuantLabel(q.max), margin - 3, pos + 7);
                fillTextRightJustified(g, formatQuantLabel(q.min), margin - 3, pos + subtier.height);
                for (var t = 1; t < numTics - 1; ++t) {
                    var ty = t * ticSpacing;
                    fillTextRightJustified(g, formatQuantLabel(1.0 * q.max - t * ticInterval), margin - 3, pos + ty + 3);
                }
            }

            pos += subtier.height + padding;
        }

        var labelName;
        if (typeof tier.config.name === 'string') labelName = tier.config.name;else labelName = tier.dasSource.name;
        var labelWidth = g.measureText(labelName).width;
        g.fillStyle = 'black';
        g.fillText(labelName, margin - (hasQuant ? 28 : 12) - labelWidth, (tier.layoutHeight + 3) / 2);

        g.restore(); // 0

        ypos += tier.layoutHeight + padding;

        tier.subtiers = tier.backupSubtiers;
        tier.originHaxx = tier.backupOriginHaxx;
        tier.layoutHeight = tier.backupLayoutHeight;
    }

    if (opts.highlights) {
        g.save();

        g.beginPath();
        g.moveTo(margin, 0);
        g.lineTo(margin + fpw, 0);
        g.lineTo(margin + fpw, ypos);
        g.lineTo(margin, ypos);
        g.closePath();
        g.clip();

        g.translate(margin + offset, 0);
        var origin = this.viewStart;
        var visStart = this.viewStart;
        var visEnd = this.viewEnd;

        for (var hi = 0; hi < this.highlights.length; ++hi) {
            var h = this.highlights[hi];
            if ((h.chr === this.chr || h.chr === 'chr' + this.chr) && h.min < visEnd && h.max > visStart) {
                g.globalAlpha = this.defaultHighlightAlpha;
                g.fillStyle = this.defaultHighlightFill;
                g.fillRect((h.min - origin) * this.scale, 0, (h.max - h.min) * this.scale, ypos);
            }
        }
        g.restore();
    }

    var rulerPos = -1;
    if (opts.ruler == 'center') {
        rulerPos = margin + (this.viewEnd - this.viewStart + 1) * this.scale / 2;
    } else if (opts.ruler == 'left') {
        rulerPos = margin;
    } else if (opts.ruler == 'right') {
        rulerPos = margin + (this.viewEnd - this.viewStart + 1) * this.scale;
    }
    if (rulerPos >= 0) {
        g.strokeStyle = 'blue';
        g.beginPath();
        g.moveTo(rulerPos, 0);
        g.lineTo(rulerPos, ypos);
        g.stroke();
    }

    this.featurePanelWidth = backupFPW;
    this.scale = backupScale;

    if (opts.blobCallback) {
        return c.toBlob(opts.blobCallback, 'image/png');
    } else {
        return c.toDataURL('image/png');
    }
};

},{"./cbrowser":6,"./glyphs":23,"./numformats":29,"./sequence-draw":35,"./utils":55,"./version":57}],18:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// export-ui.js
//

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;
}

Browser.prototype.openExportPanel = function () {
    var b = this;
    if (this.uiMode === 'export') {
        this.hideToolPanel();
        this.setUiMode('none');
    } else {
        var exportForm = makeElement('div', null, { className: 'export-form' });
        var exportSelect = makeElement('select');
        exportSelect.appendChild(makeElement('option', 'SVG', { value: 'svg' }));
        exportSelect.appendChild(makeElement('option', 'Image', { value: 'png' }));
        exportSelect.appendChild(makeElement('option', 'Dalliance config', { value: 'config' }));
        exportSelect.appendChild(makeElement('option', 'Dalliance sources', { value: 'sources' }));
        exportSelect.appendChild(makeElement('option', 'Dalliance page', { value: 'page' }));
        exportSelect.value = 'svg';

        exportSelect.addEventListener('change', function (ev) {
            removeChildren(exportContent);
            setupEOT();
        }, false);
        exportForm.appendChild(makeElement('p', ['Export as: ', exportSelect]));

        var exportHighlightsToggle = makeElement('input', null, { type: 'checkbox', checked: this.exportHighlights });
        exportHighlightsToggle.addEventListener('change', function (ev) {
            b.exportHighlights = exportHighlightsToggle.checked;
            b.storeStatus();
        }, false);
        var exportRulerToggle = makeElement('input', null, { type: 'checkbox', checked: this.exportRuler });
        exportRulerToggle.addEventListener('change', function (ev) {
            b.exportRuler = exportRulerToggle.checked;
            b.storeStatus();
        }, false);
        var exportRegionToggle = makeElement('input', null, { type: 'checkbox', checked: this.exportRegion });
        exportRegionToggle.addEventListener('change', function (ev) {
            b.exportRegion = exportRegionToggle.checked;
            b.storeStatus();
        }, false);
        var exportBannerToggle = makeElement('input', null, { type: 'checkbox', checked: this.exportBanner });
        exportBannerToggle.addEventListener('change', function (ev) {
            b.exportBanner = exportBannerToggle.checked;
            b.storeStatus();
        }, false);
        var exportScale = makeElement('input', null, { type: 'text', value: '1.0' });
        var exportWidth = makeElement('input', null, { type: 'text', value: '800' });

        var exportButton = makeElement('button', 'Export', { className: 'btn btn-primary' });

        var exportDone = function exportDone(blobURL, note, type, name) {
            if (blobURL) {
                var downloadLink = makeElement('a', '[Download]', {
                    href: blobURL,
                    download: name,
                    type: type
                });

                var previewLink = makeElement('a', '[Preview in browser]', {
                    href: blobURL,
                    type: type,
                    target: '_new'
                });

                exportContent.appendChild(makeElement('p', ['' + note + ' created: ', downloadLink, previewLink]));
            }
        };

        exportButton.addEventListener('click', function (ev) {
            removeChildren(exportContent);

            var blobURL;
            if (exportSelect.value === 'svg') {
                blobURL = URL.createObjectURL(b.makeSVG({ highlights: exportHighlightsToggle.checked,
                    banner: b.exportBanner,
                    region: b.exportRegion,
                    ruler: exportRulerToggle.checked ? b.rulerLocation : 'none',
                    width: parseInt(exportWidth.value) || 800 }));
                exportDone(blobURL, 'SVG', 'image/svg', 'dalliance-view.svg');
            } else if (exportSelect.value === 'png') {
                var mult = parseFloat(exportScale.value);
                if (mult < 0.1 || mult > 10) {
                    alert('bad scale ' + mult);
                    return;
                }

                b.exportImage({
                    highlights: exportHighlightsToggle.checked,
                    banner: b.exportBanner,
                    region: b.exportRegion,
                    ruler: exportRulerToggle.checked ? b.rulerLocation : 'none',
                    resolutionMultiplier: mult,
                    width: parseInt(exportWidth.value) || 800,
                    blobCallback: function blobCallback(blob) {
                        exportDone(URL.createObjectURL(blob), 'Image', 'image/png', 'dalliance-view.png');
                    }
                });
            } else if (exportSelect.value === 'config') {
                var config = JSON.stringify(b.exportFullConfig(), null, 2);
                var blob = new Blob([config], { type: 'text/plain' });
                exportDone(URL.createObjectURL(blob), 'Configuration', 'text/plain', 'dalliance-config.json');
            } else if (exportSelect.value === 'sources') {
                var config = JSON.stringify(b.exportSourceConfig(), null, 2);
                var blob = new Blob([config], { type: 'text/plain' });
                exportDone(blobURL = URL.createObjectURL(blob), 'Source array', 'text/plain', 'dalliance-sources.json');
            } else if (exportSelect.value === 'page') {
                var page = b.exportPageTemplate();
                var type = 'text/html';
                var blob = new Blob([page], { type: type });
                exportDone(URL.createObjectURL(blob), 'Page template', 'text/html', 'dalliance-view.html');
            }
        }, false);

        b.addViewListener(function () {
            removeChildren(exportContent);
        });
        b.addTierListener(function () {
            removeChildren(exportContent);
        });

        var exportContent = makeElement('p', '');

        var eotHighlights = makeElement('tr', [makeElement('th', 'Include highlights', {}, { width: '400px', textAlign: 'right' }), makeElement('td', exportHighlightsToggle)]);
        var eotGuideline = makeElement('tr', [makeElement('th', 'Include vertical guideline', {}, { textAlign: 'right' }), makeElement('td', exportRulerToggle)]);
        var eotScale = makeElement('tr', [makeElement('th', 'Scale multiplier', {}, { textAlign: 'right' }), makeElement('td', exportScale)]);
        var eotWidth = makeElement('tr', [makeElement('th', 'Width (logical px)', {}, { textAlign: 'right' }), makeElement('td', exportWidth)]);
        var eotRegion = makeElement('tr', [makeElement('th', 'Label with genomic coordinates', {}, { textAlign: 'right' }), makeElement('td', exportRegionToggle)]);
        var eotBanner = makeElement('tr', [makeElement('th', 'Include banner', {}, { textAlign: 'right' }), makeElement('td', exportBannerToggle)]);

        var exportOptsTable = makeElement('table', [eotHighlights, eotGuideline, eotWidth, eotScale, eotRegion], null, { width: '500px' });
        var setupEOT = function setupEOT() {
            var es = exportSelect.value;
            eotHighlights.style.display = es == 'svg' || es == 'png' ? 'table-row' : 'none';
            eotGuideline.style.display = es == 'svg' || es == 'png' ? 'table-row' : 'none';
            eotScale.style.display = es == 'png' ? 'table-row' : 'none';
            eotWidth.style.display = es == 'svg' || es == 'png' ? 'table-row' : 'none';
            eotRegion.style.display = es == 'svg' || es == 'png' ? 'table-row' : 'none';
            eotBanner.style.display = es == 'svg' || es == 'png' ? 'table-row' : 'none';
        };
        setupEOT();

        exportForm.appendChild(exportOptsTable);
        exportForm.appendChild(exportButton);
        exportForm.appendChild(exportContent);

        if (this.uiMode !== 'none') this.hideToolPanel();
        this.browserHolder.insertBefore(exportForm, this.svgHolder);
        this.activeToolPanel = exportForm;

        this.setUiMode('export');
    }
};

},{"./cbrowser":6,"./utils":55}],19:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// exports.js: shim to export symbols into global namespace for ease of embedding
//

var browser = require('./cbrowser');
var chainset = require('./chainset');
var sa = require('./sourceadapters');
var utils = require('./utils');
var das = require('./das');
var sc = require('./sourcecompare');

window.Browser = browser.Browser;
window.sourcesAreEqual = sc.sourcesAreEqual;
window.Chainset = chainset.Chainset; // Pre-0.12 configurations need this.

// Useful for info plugins.  Should be reconsidered in the future.
window.makeElement = utils.makeElement;

// Allow source plugins to be loaded separately.
window.dalliance_registerSourceAdapterFactory = sa.registerSourceAdapterFactory;
window.dalliance_registerParserFactory = sa.registerParserFactory;
window.dalliance_makeParser = sa.makeParser;

// DAS* objects for some plugins -- remove when plugin API changes...

window.DASSequence = das.DASSequence;
window.DASFeature = das.DASFeature;
window.DASGroup = das.DASGroup;
window.DASStylesheet = das.DASStylesheet;
window.DASStyle = das.DASStyle;
window.DASSource = das.DASSource; // Pre-0.8 configurations used this.  Still some around...

var ruler = require("./rulers");
window.Ruler = ruler.Ruler;
window.rulerDrawCallback = ruler.rulerDrawCallback;

},{"./cbrowser":6,"./chainset":7,"./das":10,"./rulers":32,"./sourceadapters":38,"./sourcecompare":39,"./utils":55}],20:[function(require,module,exports){
//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// feature-draw.js: new feature-tier renderer
//

"use strict";

if (typeof require !== 'undefined') {
    var tier = require('./tier');
    var DasTier = tier.DasTier;

    var nf = require('./numformats');
    var formatQuantLabel = nf.formatQuantLabel;
}

function SubTier(direct) {
    this.glyphs = [];
    this.height = 0;
    this.quant = null;
    this.direct = direct;
}

SubTier.prototype.indexFor = function (glyph) {
    var gmin = glyph.min();
    var lb = 0,
        ub = this.glyphs.length;
    while (ub > lb) {
        var mid = (lb + ub) / 2 | 0;
        if (mid >= this.glyphs.length) return this.glyphs.length;
        var mg = this.glyphs[mid];
        if (gmin < mg.min()) {
            ub = mid;
        } else {
            lb = mid + 1;
        }
    }
    return ub;
};

SubTier.prototype.add = function (glyph) {
    if (this.direct) {
        this.glyphs.push(glyph);
    } else {
        var ind = this.indexFor(glyph);
        this.glyphs.splice(ind, 0, glyph);
    }
    this.height = Math.max(this.height, glyph.height());
    if (glyph.quant && this.quant == null) {
        this.quant = glyph.quant;
    }
};

SubTier.prototype.hasSpaceFor = function (glyph) {
    if (this.direct) throw Error('Probing in direct-addition subtier');

    var ind = this.indexFor(glyph);
    if (ind > 0 && this.glyphs[ind - 1].max() >= glyph.min()) return false;
    if (ind < this.glyphs.length && this.glyphs[ind].min() <= glyph.max()) return false;

    return true;
};

DasTier.prototype.paintToContext = function (gc, oc, offset) {
    var subtiers = this.subtiers;
    var fpw = this.viewport.width | 0;

    gc.save();
    for (var s = 0; s < subtiers.length; ++s) {
        var quant = null;
        var glyphs = subtiers[s].glyphs;
        for (var i = 0; i < glyphs.length; ++i) {
            var glyph = glyphs[i];
            if (glyph.min() < fpw - offset && glyph.max() > -offset) {
                var glyph = glyphs[i];
                glyph.draw(gc, oc);
                if (glyph.quant) {
                    quant = glyph.quant;
                }
            }
        }

        if (quant && quant.min < 0 && quant.max > 0 && this.dasSource.zeroLine) {
            var ry = subtiers[0].height * (quant.max / (quant.max - quant.min));
            gc.save();
            gc.strokeStyle = this.dasSource.zeroLine;
            gc.lineWidth = 0.5;
            gc.beginPath();
            gc.moveTo(-1000, ry);
            gc.lineTo(fpw + 1000, ry);
            gc.stroke();
            gc.restore();
        }

        if (this.scaleVertical) {
            var scale = this.browser.scale;
            gc.translate(0, scale + this.padding);
            oc.translate(0, scale + this.padding);
        } else {
            gc.translate(0, subtiers[s].height + this.padding);
            oc.translate(0, subtiers[s].height + this.padding);
        }
    }
    gc.restore();

    if (quant && this.quantLeapThreshold && this.featureSource && this.browser.sourceAdapterIsCapable(this.featureSource, 'quantLeap')) {
        var ry = subtiers[0].height * (1.0 - (this.quantLeapThreshold - quant.min) / (quant.max - quant.min));

        gc.save();
        gc.strokeStyle = 'red';
        gc.lineWidth = 0.3;
        gc.beginPath();
        gc.moveTo(-1000, ry);
        gc.lineTo(fpw + 1000, ry);
        gc.stroke();
        gc.restore();
    }
};

DasTier.prototype.paintQuant = function () {
    if (!this.quantOverlay) return;

    var retina = this.browser.retina && window.devicePixelRatio > 1;

    var quant;
    if (this.subtiers && this.subtiers.length > 0) quant = this.subtiers[0].quant;

    if (quant) {
        var h = this.subtiers[0].height;
        var w = 50;
        this.quantOverlay.height = this.viewport.height;
        this.quantOverlay.width = retina ? w * 2 : w;
        this.quantOverlay.style.height = '' + (retina ? this.quantOverlay.height / 2 : this.quantOverlay.height) + 'px';
        this.quantOverlay.style.width = '' + w + 'px';
        this.quantOverlay.style.display = 'block';
        var ctx = this.quantOverlay.getContext('2d');
        if (retina) ctx.scale(2, 2);

        var numTics = 2;
        if (h > 40) {
            numTics = 1 + (h / 20 | 0);
        }
        var ticSpacing = (h + this.padding * 2) / (numTics - 1);
        var ticInterval = (quant.max - quant.min) / (numTics - 1);

        ctx.fillStyle = 'white';
        ctx.globalAlpha = 0.6;
        if (this.browser.rulerLocation == 'right') {
            ctx.fillRect(w - 30, 0, 30, h + this.padding * 2);
        } else {
            ctx.fillRect(0, 0, 30, h + this.padding * 2);
        }
        ctx.globalAlpha = 1.0;

        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.beginPath();

        if (this.browser.rulerLocation == 'right') {
            ctx.moveTo(w - 8, this.padding);
            ctx.lineTo(w, this.padding);
            ctx.lineTo(w, h + this.padding);
            ctx.lineTo(w - 8, h + this.padding);
            for (var t = 1; t < numTics - 1; ++t) {
                var ty = t * ticSpacing;
                ctx.moveTo(w, ty);
                ctx.lineTo(w - 5, ty);
            }
        } else {
            ctx.moveTo(8, this.padding);
            ctx.lineTo(0, this.padding);
            ctx.lineTo(0, h + this.padding);
            ctx.lineTo(8, h + this.padding);
            for (var t = 1; t < numTics - 1; ++t) {
                var ty = t * ticSpacing;
                ctx.moveTo(0, ty);
                ctx.lineTo(5, ty);
            }
        }
        ctx.stroke();

        ctx.fillStyle = 'black';

        if (this.browser.rulerLocation == 'right') {
            ctx.textAlign = 'right';
            ctx.fillText(formatQuantLabel(quant.max), w - 9, 8);
            ctx.fillText(formatQuantLabel(quant.min), w - 9, h + this.padding);
            for (var t = 1; t < numTics - 1; ++t) {
                var ty = t * ticSpacing;
                ctx.fillText(formatQuantLabel(1.0 * quant.max - t * ticInterval), w - 9, ty + 3);
            }
        } else {
            ctx.textAlign = 'left';
            ctx.fillText(formatQuantLabel(quant.max), 9, 8);
            ctx.fillText(formatQuantLabel(quant.min), 9, h + this.padding);
            for (var t = 1; t < numTics - 1; ++t) {
                var ty = t * ticSpacing;
                ctx.fillText(formatQuantLabel(1.0 * quant.max - t * ticInterval), 9, ty + 3);
            }
        }
    } else {
        this.quantOverlay.style.display = 'none';
    }
};

DasTier.prototype.styleForFeature = function (f) {
    var ssScale = this.browser.zoomForCurrentScale();

    if (!this.stylesheet) {
        return null;
    }

    var maybe = null;
    var ss = this.stylesheet.styles;
    for (var si = 0; si < ss.length; ++si) {
        var sh = ss[si];
        if (sh.zoom && sh.zoom != ssScale) {
            continue;
        }

        if (sh.orientation) {
            if (sh.orientation != f.orientation) {
                continue;
            }
        }

        var labelRE = sh._labelRE;
        if (!labelRE || !labelRE.test) {
            labelRE = new RegExp('^' + sh.label + '$');
            sh._labelRE = labelRE;
        }
        if (sh.label && !labelRE.test(f.label)) {
            continue;
        }
        var methodRE = sh._methodRE;
        if (!methodRE || !methodRE.test) {
            methodRE = new RegExp('^' + sh.method + '$');
            sh._methodRE = methodRE;
        }
        if (sh.method && !methodRE.test(f.method)) {
            continue;
        }
        if (sh.type) {
            if (sh.type == 'default') {
                if (!maybe) {
                    maybe = sh.style;
                }
                continue;
            } else {
                var typeRE = sh._typeRE;
                if (!typeRE || !typeRE.test) {
                    typeRE = new RegExp('^' + sh.type + '$');
                    sh._typeRE = typeRE;
                }
                if (!typeRE.test(f.type)) continue;
            }
        }
        return sh.style;
    }
    return maybe;
};

DasTier.prototype.quantMin = function (style) {
    if (this.forceMinDynamic) {
        return this.currentFeaturesMinScore || 0;
    } else if (typeof this.forceMin === 'number') {
        return this.forceMin;
    } else {
        var softMin = typeof style.SOFTMIN !== 'undefined' ? style.SOFTMIN : Number.MAX_VALUE;
        return style.MIN || Math.min(softMin, this.currentFeaturesMinScore || 0);
    }
};

DasTier.prototype.quantMax = function (style) {
    if (this.forceMaxDynamic) {
        return this.currentFeaturesMaxScore || 0;
    } else if (typeof this.forceMax === 'number') {
        return this.forceMax;
    } else {
        var softMax = typeof style.SOFTMAX !== 'undefined' ? style.SOFTMAX : Number.MIN_VALUE;
        return style.MAX || Math.max(softMax, this.currentFeaturesMaxScore || 0);
    }
};

if (typeof module !== 'undefined') {
    module.exports = {
        SubTier: SubTier
    };
}

},{"./numformats":29,"./tier":51}],21:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// feature-popup.js
//

"use strict";

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var pick = utils.pick;
    var pushnew = utils.pushnew;
    var makeElement = utils.makeElement;
}

var TAGVAL_NOTE_RE = new RegExp('^([A-Za-z_-]+)=(.+)');

Browser.prototype.addFeatureInfoPlugin = function (handler) {
    if (!this.featureInfoPlugins) {
        this.featureInfoPlugins = [];
    }
    this.featureInfoPlugins.push(handler);
};

function FeatureInfo(hit, feature, group) {
    var name = pick(group.type, feature.type);
    var fid = pick(group.label, feature.label, group.id, feature.id);
    if (fid && fid.indexOf('__dazzle') != 0) {
        name = name + ': ' + fid;
    }

    this.hit = hit;
    this.feature = feature;
    this.group = group;
    this.title = name;
    this.sections = [];
    this.closeListeners = [];
    this._inhibitPopup = false;
}

FeatureInfo.prototype.setTitle = function (t) {
    this.title = t;
};

FeatureInfo.prototype.add = function (label, info) {
    if (typeof info === 'string') {
        info = makeElement('span', info);
    }
    this.sections.push({ label: label, info: info });
};

FeatureInfo.prototype.inhibitPopup = function () {
    this._inhibitPopup = true;
};

FeatureInfo.prototype.addCloseListener = function (f) {
    this.closeListeners.push(f);
};

FeatureInfo.prototype._notifyClose = function () {
    for (var cli = 0; cli < this.closeListeners.length; ++cli) {
        try {
            this.closeListeners[cli]();
        } catch (ex) {
            console.log(ex);
        }
    }
};

Browser.prototype.featurePopup = function (ev, __ignored_feature, hit, tier, opts) {
    if (!opts) {
        opts = {};
    }

    var hi = hit.length;
    var feature = --hi >= 0 ? hit[hi] : {};
    var group = --hi >= 0 ? hit[hi] : {};

    var featureInfo = new FeatureInfo(hit, feature, group);
    featureInfo.tier = tier;
    var fips = this.featureInfoPlugins || [];
    for (var fipi = 0; fipi < fips.length; ++fipi) {
        try {
            fips[fipi](feature, featureInfo);
        } catch (e) {
            console.log(e.stack || e);
        }
    }
    fips = tier.featureInfoPlugins || [];
    for (fipi = 0; fipi < fips.length; ++fipi) {
        try {
            fips[fipi](feature, featureInfo);
        } catch (e) {
            console.log(e.stack || e);
        }
    }

    if (featureInfo._inhibitPopup) {
        // This is effectively an "instant close", so notify any FIPs that care.
        featureInfo._notifyClose();
        return;
    }

    this.removeAllPopups();

    var table = makeElement('table', null, { className: 'table table-striped table-condensed' });
    table.style.width = '100%';
    table.style.margin = '0px';

    var idx = 0;
    if (feature.method && !tier.dasSource.suppressMethod) {
        var row = makeElement('tr', [makeElement('th', 'Method'), makeElement('td', feature.method)]);
        table.appendChild(row);
        ++idx;
    }
    {
        var loc;
        if (group.segment) {
            loc = group;
        } else {
            loc = feature;
        }
        var row = makeElement('tr', [makeElement('th', 'Location'), makeElement('td', loc.segment + ':' + loc.min + '-' + loc.max, {}, { minWidth: '200px' })]);
        table.appendChild(row);
        ++idx;
    }
    if (feature.score !== undefined && feature.score !== null && feature.score != '-' && !feature.suppressScore && !tier.dasSource.suppressScore) {
        var row = makeElement('tr', [makeElement('th', 'Score'), makeElement('td', '' + feature.score)]);
        table.appendChild(row);
        ++idx;
    }
    {
        var links = maybeConcat(group.links, feature.links);
        if (links && links.length > 0) {
            var row = makeElement('tr', [makeElement('th', 'Links'), makeElement('td', links.map(function (l) {
                return makeElement('div', makeElement('a', l.desc, { href: l.uri, target: '_new' }));
            }))]);
            table.appendChild(row);
            ++idx;
        }
    }
    {
        var notes = maybeConcat(group.notes, feature.notes);
        for (var ni = 0; ni < notes.length; ++ni) {
            var k = 'Note';
            var v = notes[ni];
            var m = v.match(TAGVAL_NOTE_RE);
            if (m) {
                k = m[1];
                v = m[2];
            }

            var row = makeElement('tr', [makeElement('th', k), makeElement('td', v)]);
            table.appendChild(row);
            ++idx;
        }
    }

    for (var fisi = 0; fisi < featureInfo.sections.length; ++fisi) {
        var section = featureInfo.sections[fisi];
        table.appendChild(makeElement('tr', [makeElement('th', section.label), makeElement('td', section.info)]));
    }

    this.popit(ev, featureInfo.title || 'Feature', table, {
        width: 450,
        onClose: featureInfo._notifyClose.bind(featureInfo),
        disableDrag: opts.disableDrag
    });
};

function maybeConcat(a, b) {
    var l = [];
    if (a) {
        for (var i = 0; i < a.length; ++i) {
            pushnew(l, a[i]);
        }
    }
    if (b) {
        for (var i = 0; i < b.length; ++i) {
            pushnew(l, b[i]);
        }
    }
    return l;
}

},{"./cbrowser":6,"./utils":55}],22:[function(require,module,exports){
"use strict";

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var pusho = utils.pusho;
    var pushnewo = utils.pushnewo;
}

function sortFeatures(tier) {
    var dmin = tier.browser.drawnStart,
        dmax = tier.browser.drawnEnd;
    var ungroupedFeatures = {};
    var groupedFeatures = {};
    var drawnGroupedFeatures = {};
    var groupMins = {},
        groupMaxes = {};
    var groups = {};
    var superGroups = {};
    var groupsToSupers = {};
    var nonPositional = [];
    var minScore, maxScore;
    var fbid;

    var init_fbid = function init_fbid() {
        fbid = {};
        for (var fi = 0; fi < tier.currentFeatures.length; ++fi) {
            var f = tier.currentFeatures[fi];
            if (f.id) {
                fbid[f.id] = f;
            }
        }
    };

    var superParentsOf = function superParentsOf(f) {
        // FIXME: should recur.
        var spids = [];
        if (f.parents) {
            for (var pi = 0; pi < f.parents.length; ++pi) {
                var pid = f.parents[pi];
                var p = fbid[pid];
                if (!p) {
                    continue;
                }
                // alert(p.type + ':' + p.typeCv);
                if (p.typeCv == 'SO:0000704') {
                    pushnew(spids, pid);
                }
            }
        }
        return spids;
    };

    for (var fi = 0; fi < tier.currentFeatures.length; ++fi) {
        var f = tier.currentFeatures[fi];
        if (f.parts) {
            continue;
        }

        var drawn = f.min <= dmax && f.max >= dmin;

        if (!f.min || !f.max) {
            nonPositional.push(f);
            continue;
        }

        if (f.score && f.score != '.' && f.score != '-') {
            var sc = 1.0 * f.score;
            if (!minScore || sc < minScore) {
                minScore = sc;
            }
            if (!maxScore || sc > maxScore) {
                maxScore = sc;
            }
        }

        var fGroups = [];
        var fSuperGroup = null;
        if (f.groups) {
            for (var gi = 0; gi < f.groups.length; ++gi) {
                var g = f.groups[gi];
                var gid = g.id;
                if (g.type == 'gene') {
                    // Like a super-grouper...
                    fSuperGroup = gid;
                    groups[gid] = g;
                } else if (g.type == 'translation') {
                    // have to ignore this to get sensible results from bj-e :-(.
                } else {
                    pusho(groupedFeatures, gid, f);
                    groups[gid] = g;
                    fGroups.push(gid);

                    var ogm = groupMins[gid];
                    if (!ogm || f.min < ogm) groupMins[gid] = f.min;

                    ogm = groupMaxes[gid];
                    if (!ogm || f.max > ogm) groupMaxes[gid] = f.max;
                }
            }
        }

        if (f.parents) {
            if (!fbid) {
                init_fbid();
            }
            for (var pi = 0; pi < f.parents.length; ++pi) {
                var pid = f.parents[pi];
                var p = fbid[pid];
                if (!p) {
                    // alert("couldn't find " + pid);
                    continue;
                }
                if (!p.parts) {
                    p.parts = [f];
                }
                pushnewo(groupedFeatures, pid, p);
                pusho(groupedFeatures, pid, f);

                if (!groups[pid]) {
                    groups[pid] = {
                        type: p.type,
                        id: p.id,
                        label: p.label || p.id
                    };
                }
                fGroups.push(pid);

                var ogm = groupMins[pid];
                if (!ogm || f.min < ogm) groupMins[pid] = f.min;

                ogm = groupMaxes[pid];
                if (!ogm || f.max > ogm) groupMaxes[pid] = f.max;

                var sgs = superParentsOf(p);
                if (sgs.length > 0) {
                    fSuperGroup = sgs[0];
                    var sp = fbid[sgs[0]];
                    groups[sgs[0]] = {
                        type: sp.type,
                        id: sp.id,
                        label: sp.label || sp.id
                    };
                    if (!tier.dasSource.collapseSuperGroups) {
                        tier.dasSource.collapseSuperGroups = true;
                    }
                }
            }
        }

        if (fGroups.length == 0) {
            if (drawn) pusho(ungroupedFeatures, f.type, f);
        } else if (fSuperGroup) {
            for (var g = 0; g < fGroups.length; ++g) {
                var gid = fGroups[g];
                pushnewo(superGroups, fSuperGroup, gid);
                groupsToSupers[gid] = fSuperGroup;
            }
        }
    }

    for (var gid in groupedFeatures) {
        var group = groups[gid];
        if (typeof group.min !== 'number') group.min = groupMins[gid];
        if (typeof group.max !== 'number') group.max = groupMaxes[gid];

        if (groupMaxes[gid] >= dmin && groupMins[gid] <= dmax) drawnGroupedFeatures[gid] = groupedFeatures[gid];
    }

    tier.ungroupedFeatures = ungroupedFeatures;
    tier.groupedFeatures = drawnGroupedFeatures;
    tier.groups = groups;
    tier.superGroups = superGroups;
    tier.groupsToSupers = groupsToSupers;

    if (minScore) {
        if (minScore > 0) {
            minScore = 0;
        } else if (maxScore < 0) {
            maxScore = 0;
        }
        tier.currentFeaturesMinScore = minScore;
        tier.currentFeaturesMaxScore = maxScore;
    }
}

if (typeof module !== 'undefined') {
    module.exports = {
        sortFeatures: sortFeatures
    };
}

},{"./utils":55}],23:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// glyphs.js: components which know how to draw themselves
//

"use strict";

if (typeof require !== 'undefined') {
    var spans = require('./spans');
    var union = spans.union;
    var Range = spans.Range;

    var utils = require('./utils');
    var makeElementNS = utils.makeElementNS;
    var AMINO_ACID_TRANSLATION = utils.AMINO_ACID_TRANSLATION;

    var svgu = require('./svg-utils');
    var NS_SVG = svgu.NS_SVG;
    var NS_XLINK = svgu.NS_XLINK;
    var SVGPath = svgu.SVGPath;
}

function PathGlyphBase(stroke, fill) {
    this._stroke = stroke;
    this._fill = fill;
}

PathGlyphBase.prototype.draw = function (g) {
    g.beginPath();
    this.drawPath(g);

    if (this._fill) {
        g.fillStyle = this._fill;
        g.fill();
    }
    if (this._stroke) {
        g.strokeStyle = this._stroke;
        g.stroke();
    }
};

PathGlyphBase.prototype.toSVG = function () {
    var g = new SVGPath();
    this.drawPath(g);

    return makeElementNS(NS_SVG, 'path', null, { d: g.toPathData(),
        fill: this._fill || 'none',
        stroke: this._stroke || 'none' });
};

PathGlyphBase.prototype.drawPath = function (g) {
    throw 'drawPath method on PathGlyphBase must be overridden';
};

function BoxGlyph(x, y, width, height, fill, stroke, alpha, radius) {
    this.x = x;
    this.y = y;
    this._width = width;
    this._height = height;
    this.fill = fill;
    this.stroke = stroke;
    this._alpha = alpha;
    this._radius = radius || 0;
}

BoxGlyph.prototype.draw = function (g) {
    var r = this._radius;

    if (r > 0) {
        g.beginPath();
        g.moveTo(this.x + r, this.y);
        g.lineTo(this.x + this._width - r, this.y);
        g.arcTo(this.x + this._width, this.y, this.x + this._width, this.y + r, r);
        g.lineTo(this.x + this._width, this.y + this._height - r);
        g.arcTo(this.x + this._width, this.y + this._height, this.x + this._width - r, this.y + this._height, r);
        g.lineTo(this.x + r, this.y + this._height);
        g.arcTo(this.x, this.y + this._height, this.x, this.y + this._height - r, r);
        g.lineTo(this.x, this.y + r);
        g.arcTo(this.x, this.y, this.x + r, this.y, r);
        g.closePath();

        if (this._alpha != null) {
            g.save();
            g.globalAlpha = this._alpha;
        }

        if (this.fill) {
            g.fillStyle = this.fill;
            g.fill();
        }
        if (this.stroke) {
            g.strokeStyle = this.stroke;
            g.lineWidth = 0.5;
            g.stroke();
        }

        if (this._alpha != null) {
            g.restore();
        }
    } else {
        if (this._alpha != null) {
            g.save();
            g.globalAlpha = this._alpha;
        }

        if (this.fill) {
            g.fillStyle = this.fill;
            g.fillRect(this.x, this.y, this._width, this._height);
        }

        if (this.stroke) {
            g.strokeStyle = this.stroke;
            g.lineWidth = 0.5;
            g.strokeRect(this.x, this.y, this._width, this._height);
        }

        if (this._alpha != null) {
            g.restore();
        }
    }
};

BoxGlyph.prototype.toSVG = function () {
    var s = makeElementNS(NS_SVG, 'rect', null, { x: this.x,
        y: this.y,
        width: this._width,
        height: this._height,
        stroke: this.stroke || 'none',
        strokeWidth: 0.5,
        fill: this.fill || 'none' });
    if (this._alpha != null) {
        s.setAttribute('opacity', this._alpha);
    }

    return s;
};

BoxGlyph.prototype.min = function () {
    return this.x;
};

BoxGlyph.prototype.max = function () {
    return this.x + this._width;
};

BoxGlyph.prototype.height = function () {
    return this.y + this._height;
};

function GroupGlyph(glyphs, connector) {
    this.glyphs = glyphs;
    this.connector = connector;
    this.h = glyphs[0].height();

    var covList = [];
    for (var g = 0; g < glyphs.length; ++g) {
        var gg = glyphs[g];
        covList.push(new Range(gg.min(), gg.max()));
        this.h = Math.max(this.h, gg.height());
    }
    this.coverage = union(covList);
}

GroupGlyph.prototype.drawConnectors = function (g) {
    var ranges = this.coverage.ranges();
    for (var r = 1; r < ranges.length; ++r) {
        var gl = ranges[r];
        var last = ranges[r - 1];
        if (last && gl.min() > last.max()) {
            var start = last.max();
            var end = gl.min();
            var mid = (start + end) / 2;

            if (this.connector === 'hat+') {
                g.moveTo(start, this.h / 2);
                g.lineTo(mid, 0);
                g.lineTo(end, this.h / 2);
            } else if (this.connector === 'hat-') {
                g.moveTo(start, this.h / 2);
                g.lineTo(mid, this.h);
                g.lineTo(end, this.h / 2);
            } else if (this.connector === 'collapsed+') {
                g.moveTo(start, this.h / 2);
                g.lineTo(end, this.h / 2);
                if (end - start > 4) {
                    g.moveTo(mid - 2, this.h / 2 - 3);
                    g.lineTo(mid + 2, this.h / 2);
                    g.lineTo(mid - 2, this.h / 2 + 3);
                }
            } else if (this.connector === 'collapsed-') {
                g.moveTo(start, this.h / 2);
                g.lineTo(end, this.h / 2);
                if (end - start > 4) {
                    g.moveTo(mid + 2, this.h / 2 - 3);
                    g.lineTo(mid - 2, this.h / 2);
                    g.lineTo(mid + 2, this.h / 2 + 3);
                }
            } else {
                g.moveTo(start, this.h / 2);
                g.lineTo(end, this.h / 2);
            }
        }
        last = gl;
    }
};

GroupGlyph.prototype.draw = function (g, oc) {
    for (var i = 0; i < this.glyphs.length; ++i) {
        var gl = this.glyphs[i];
        gl.draw(g, oc);
    }

    g.strokeStyle = 'black';
    g.beginPath();
    this.drawConnectors(g);
    g.stroke();
};

GroupGlyph.prototype.toSVG = function () {
    var g = makeElementNS(NS_SVG, 'g');
    for (var i = 0; i < this.glyphs.length; ++i) {
        g.appendChild(this.glyphs[i].toSVG());
    }

    var p = new SVGPath();
    this.drawConnectors(p);

    var pathData = p.toPathData();
    if (pathData.length > 0) {
        var path = makeElementNS(NS_SVG, 'path', null, { d: p.toPathData(),
            fill: 'none',
            stroke: 'black',
            strokeWidth: 0.5 });
        g.appendChild(path);
    }

    return g;
};

GroupGlyph.prototype.min = function () {
    return this.coverage.min();
};

GroupGlyph.prototype.max = function () {
    return this.coverage.max();
};

GroupGlyph.prototype.height = function () {
    return this.h;
};

function LineGraphGlyph(points, color, height) {
    this.points = points;
    this.color = color;
    this._height = height || 50;
}

LineGraphGlyph.prototype.min = function () {
    return this.points[0].x;
    // return this.points[0];
};

LineGraphGlyph.prototype.max = function () {
    return this.points[this.points.length - 1].x;
    // return this.points[this.points.length - 2];
};

LineGraphGlyph.prototype.height = function () {
    return this._height;
};

LineGraphGlyph.prototype.draw = function (g) {
    g.save();
    g.strokeStyle = this.color;
    g.lineWidth = 2;
    g.beginPath();
    this.points.forEach(function (p, i) {
        if (i === 0) g.moveTo(p.x, p.y);else g.lineTo(p.x, p.y);
    });
    g.stroke();
    g.restore();
};

LineGraphGlyph.prototype.toSVG = function () {
    var p = new SVGPath();
    for (var i = 0; i < this.points.length; ++i) {
        var x = this.points[i].x;
        var y = this.points[i].y;
        if (i == 0) {
            p.moveTo(x, y);
        } else {
            p.lineTo(x, y);
        }
    }

    return makeElementNS(NS_SVG, 'path', null, { d: p.toPathData(),
        fill: 'none',
        stroke: this.color,
        strokeWidth: '2px' });
};

function LabelledGlyph(GLOBAL_GC, glyph, text, unmeasured, anchor, align, font) {
    this.glyph = glyph;
    this.text = text;
    this.anchor = anchor || 'left';
    this.align = align || 'below';
    if (font) {
        this.font = font;
    }
    if (this.font) {
        GLOBAL_GC.save();
        GLOBAL_GC.font = this.font;
    }
    var metrics = GLOBAL_GC.measureText(text);
    if (this.font) {
        GLOBAL_GC.restore();
    }
    this.textLen = metrics.width;
    this.textHeight = 5;
    this.bump = glyph.bump;
    this.measured = !unmeasured;
}

LabelledGlyph.prototype.toSVG = function () {
    var child = this.glyph.toSVG();
    var opts = {};

    if (this.align == 'above') {
        child = makeElementNS(NS_SVG, 'g', child, { transform: "translate(0, " + (this.textHeight | 0 + 2) + ")" });
        opts.y = this.textHeight;
    } else {
        opts.y = this.glyph.height() + 15;
    }

    if (this.font) {
        opts.fontSize = 7;
    }

    if ('center' == this.anchor) {
        opts.x = (this.glyph.min() + this.glyph.max() - this.textLen) / 2;
    } else {
        opts.x = this.glyph.min();
    }

    return makeElementNS(NS_SVG, 'g', [child, makeElementNS(NS_SVG, 'text', this.text, opts)]);
};

LabelledGlyph.prototype.min = function () {
    return this.glyph.min();
};

LabelledGlyph.prototype.max = function () {
    if (this.measured) return Math.max(this.glyph.max(), 1.0 * this.glyph.min() + this.textLen + 10);else return this.glyph.max();
};

LabelledGlyph.prototype.height = function () {
    var h = this.glyph.height();
    if (this.measured) {
        if (this.align == 'above') {
            h += this.textHeight + 2;
        } else {
            h += 20;
        }
    }
    return h;
};

LabelledGlyph.prototype.draw = function (g, oc) {
    if (this.align == 'above') {
        g.save();
        g.translate(0, this.textHeight + 2);
    }
    this.glyph.draw(g);
    if (this.align == 'above') {
        g.restore();
    }

    oc.registerGlyph(this);
};

LabelledGlyph.prototype.drawOverlay = function (g, minVisible, maxVisible) {
    g.fillStyle = 'black';
    if (this.font) {
        g.save();
        g.font = this.font;
    }
    var p;
    if ('center' == this.anchor) {
        p = (this.glyph.min() + this.glyph.max() - this.textLen) / 2;
    } else {
        p = this.glyph.min();
        if (p < minVisible) {
            p = Math.min(minVisible, this.glyph.max() - this.textLen);
        }
    }
    g.fillText(this.text, p, this.align == 'above' ? this.textHeight : this.glyph.height() + 15);
    if (this.font) {
        g.restore();
    }
};

function CrossGlyph(x, height, stroke) {
    this._x = x;
    this._height = height;
    this._stroke = stroke;
}

CrossGlyph.prototype.draw = function (g) {
    var hh = this._height / 2;

    g.beginPath();
    g.moveTo(this._x, 0);
    g.lineTo(this._x, this._height);
    g.moveTo(this._x - hh, hh);
    g.lineTo(this._x + hh, hh);

    g.strokeStyle = this._stroke;
    g.lineWidth = 1;

    g.stroke();
};

CrossGlyph.prototype.toSVG = function () {
    var hh = this._height / 2;

    var g = new SVGPath();
    g.moveTo(this._x, 0);
    g.lineTo(this._x, this._height);
    g.moveTo(this._x - hh, hh);
    g.lineTo(this._x + hh, hh);

    return makeElementNS(NS_SVG, 'path', null, { d: g.toPathData(),
        fill: 'none',
        stroke: this._stroke,
        strokeWidth: '1px' });
};

CrossGlyph.prototype.min = function () {
    return this._x - this._height / 2;
};

CrossGlyph.prototype.max = function () {
    return this._x + this._height / 2;
};

CrossGlyph.prototype.height = function () {
    return this._height;
};

function ExGlyph(x, height, stroke) {
    this._x = x;
    this._height = height;
    this._stroke = stroke;
}

ExGlyph.prototype.draw = function (g) {
    var hh = this._height / 2;

    g.beginPath();
    g.moveTo(this._x - hh, 0);
    g.lineTo(this._x + hh, this._height);
    g.moveTo(this._x - hh, this._height);
    g.lineTo(this._x + hh, 0);

    g.strokeStyle = this._stroke;
    g.lineWidth = 1;

    g.stroke();
};

ExGlyph.prototype.toSVG = function () {
    var hh = this._height / 2;

    var g = new SVGPath();
    g.moveTo(this._x - hh, 0);
    g.lineTo(this._x + hh, this._height);
    g.moveTo(this._x - hh, this._height);
    g.lineTo(this._x + hh, 0);

    return makeElementNS(NS_SVG, 'path', null, { d: g.toPathData(),
        fill: 'none',
        stroke: this._stroke,
        strokeWidth: '1px' });
};

ExGlyph.prototype.min = function () {
    return this._x - this._height / 2;
};

ExGlyph.prototype.max = function () {
    return this._x + this._height / 2;
};

ExGlyph.prototype.height = function () {
    return this._height;
};

function TriangleGlyph(x, height, dir, width, fill, stroke) {
    PathGlyphBase.call(this, stroke, fill);

    this._x = x;
    this._height = height;
    this._dir = dir;
    this._width = width;
}

TriangleGlyph.prototype = Object.create(PathGlyphBase.prototype);

TriangleGlyph.prototype.drawPath = function (g) {
    var hh = this._height / 2;
    var hw = this._width / 2;

    if (this._dir === 'S') {
        g.moveTo(this._x, this._height);
        g.lineTo(this._x - hw, 0);
        g.lineTo(this._x + hw, 0);
    } else if (this._dir === 'W') {
        g.moveTo(this._x + hw, hh);
        g.lineTo(this._x - hw, 0);
        g.lineTo(this._x - hw, this._height);
    } else if (this._dir === 'E') {
        g.moveTo(this._x - hw, hh);
        g.lineTo(this._x + hw, 0);
        g.lineTo(this._x + hw, this._height);
    } else {
        g.moveTo(this._x, 0);
        g.lineTo(this._x + hw, this._height);
        g.lineTo(this._x - hw, this._height);
    }

    g.closePath();
};

TriangleGlyph.prototype.min = function () {
    return this._x - this._height / 2;
};

TriangleGlyph.prototype.max = function () {
    return this._x + this._height / 2;
};

TriangleGlyph.prototype.height = function () {
    return this._height;
};

function DotGlyph(x, height, fill, stroke) {
    this._x = x;
    this._height = height;
    this._fill = fill;
    this._stroke = stroke;
}

DotGlyph.prototype.draw = function (g) {
    var hh = this._height / 2;
    g.fillStyle = this._stroke;
    g.beginPath();
    g.arc(this._x, hh, hh, 0, 6.29);

    if (this._fill) {
        g.fillStyle = this._fill;
        g.fill();
    }

    if (this._stroke) {
        g.strokeStyle = this._stroke;
        g.stroke();
    }
};

DotGlyph.prototype.toSVG = function () {
    var hh = this._height / 2;
    return makeElementNS(NS_SVG, 'circle', null, { cx: this._x, cy: hh, r: hh,
        fill: this._fill || 'none',
        stroke: this._stroke || 'none',
        strokeWidth: '1px' });
};

DotGlyph.prototype.min = function () {
    return this._x - this._height / 2;
};

DotGlyph.prototype.max = function () {
    return this._x + this._height / 2;
};

DotGlyph.prototype.height = function () {
    return this._height;
};

function PaddedGlyph(glyph, minp, maxp) {
    this.glyph = glyph;
    this._min = minp;
    this._max = maxp;
    if (glyph) {
        this.bump = glyph.bump;
    }
}

PaddedGlyph.prototype.draw = function (g, oc) {
    if (this.glyph) this.glyph.draw(g, oc);
};

PaddedGlyph.prototype.toSVG = function () {
    if (this.glyph) {
        return this.glyph.toSVG();
    } else {
        return makeElementNS(NS_SVG, 'g');
    }
};

PaddedGlyph.prototype.min = function () {
    return this._min;
};

PaddedGlyph.prototype.max = function () {
    return this._max;
};

PaddedGlyph.prototype.height = function () {
    if (this.glyph) {
        return this.glyph.height();
    } else {
        return 1;
    }
};

function AArrowGlyph(min, max, height, fill, stroke, ori) {
    PathGlyphBase.call(this, stroke, fill);
    this._min = min;
    this._max = max;
    this._height = height;
    this._ori = ori;
}

AArrowGlyph.prototype = Object.create(PathGlyphBase.prototype);

AArrowGlyph.prototype.min = function () {
    return this._min;
};

AArrowGlyph.prototype.max = function () {
    return this._max;
};

AArrowGlyph.prototype.height = function () {
    return this._height;
};

AArrowGlyph.prototype.drawPath = function (g) {
    var maxPos = this._max;
    var minPos = this._min;
    var height = this._height;
    var lInset = 0;
    var rInset = 0;
    var minLength = this._height + 2;
    var instep = 0.333333 * this._height;
    var y = 0;

    if (this._ori) {
        if (this._ori === '+') {
            rInset = 0.5 * this._height;
        } else if (this._ori === '-') {
            lInset = 0.5 * this._height;
        }
    }

    if (maxPos - minPos < minLength) {
        minPos = (maxPos + minPos - minLength) / 2;
        maxPos = minPos + minLength;
    }

    g.moveTo(minPos + lInset, y + instep);
    g.lineTo(maxPos - rInset, y + instep);
    g.lineTo(maxPos - rInset, y);
    g.lineTo(maxPos, y + this._height / 2);
    g.lineTo(maxPos - rInset, y + height);
    g.lineTo(maxPos - rInset, y + instep + instep);
    g.lineTo(minPos + lInset, y + instep + instep);
    g.lineTo(minPos + lInset, y + height);
    g.lineTo(minPos, y + height / 2);
    g.lineTo(minPos + lInset, y);
    g.lineTo(minPos + lInset, y + instep);
};

function SpanGlyph(min, max, height, stroke) {
    PathGlyphBase.call(this, stroke, null);
    this._min = min;
    this._max = max;
    this._height = height;
}

SpanGlyph.prototype = Object.create(PathGlyphBase.prototype);

SpanGlyph.prototype.min = function () {
    return this._min;
};
SpanGlyph.prototype.max = function () {
    return this._max;
};
SpanGlyph.prototype.height = function () {
    return this._height;
};

SpanGlyph.prototype.drawPath = function (g) {
    var minPos = this._min,
        maxPos = this._max;
    var height = this._height,
        hh = height / 2;
    g.moveTo(minPos, hh);
    g.lineTo(maxPos, hh);
    g.moveTo(minPos, 0);
    g.lineTo(minPos, height);
    g.moveTo(maxPos, 0);
    g.lineTo(maxPos, height);
};

function LineGlyph(min, max, height, style, strand, stroke) {
    this._min = min;
    this._max = max;
    this._height = height;
    this._style = style;
    this._strand = strand;
    this._stroke = stroke;
}

LineGlyph.prototype.min = function () {
    return this._min;
};
LineGlyph.prototype.max = function () {
    return this._max;
};
LineGlyph.prototype.height = function () {
    return this._height;
};

LineGlyph.prototype.drawPath = function (g) {
    var minPos = this._min,
        maxPos = this._max;
    var height = this._height,
        hh = height / 2;

    if (this._style === 'hat') {
        g.moveTo(minPos, hh);
        g.lineTo((minPos + maxPos) / 2, this._strand === '-' ? height : 0);
        g.lineTo(maxPos, hh);
    } else {
        g.moveTo(minPos, hh);
        g.lineTo(maxPos, hh);
    }
};

LineGlyph.prototype.draw = function (g) {
    g.beginPath();
    this.drawPath(g);
    g.strokeStyle = this._stroke;
    if (this._style === 'dashed' && g.setLineDash) {
        g.save();
        g.setLineDash([3]);
        g.stroke();
        g.restore();
    } else {
        g.stroke();
    }
};

LineGlyph.prototype.toSVG = function () {
    var g = new SVGPath();
    this.drawPath(g);

    var opts = { d: g.toPathData(),
        stroke: this._stroke || 'none' };
    if (this._style === 'dashed') {
        opts['strokeDasharray'] = '3';
    }

    return makeElementNS(NS_SVG, 'path', null, opts);
};

function PrimersGlyph(min, max, height, fill, stroke) {
    this._min = min;
    this._max = max;
    this._height = height;
    this._fill = fill;
    this._stroke = stroke;
}

PrimersGlyph.prototype.min = function () {
    return this._min;
};
PrimersGlyph.prototype.max = function () {
    return this._max;
};
PrimersGlyph.prototype.height = function () {
    return this._height;
};

PrimersGlyph.prototype.drawStemPath = function (g) {
    var minPos = this._min,
        maxPos = this._max;
    var height = this._height,
        hh = height / 2;
    g.moveTo(minPos, hh);
    g.lineTo(maxPos, hh);
};

PrimersGlyph.prototype.drawTrigsPath = function (g) {
    var minPos = this._min,
        maxPos = this._max;
    var height = this._height,
        hh = height / 2;
    g.moveTo(minPos, 0);
    g.lineTo(minPos + height, hh);
    g.lineTo(minPos, height);
    g.lineTo(minPos, 0);
    g.moveTo(maxPos, 0);
    g.lineTo(maxPos - height, hh);
    g.lineTo(maxPos, height);
    g.lineTo(maxPos, 0);
};

PrimersGlyph.prototype.draw = function (g) {
    g.beginPath();
    this.drawStemPath(g);
    g.strokeStyle = this._stroke;
    g.stroke();
    g.beginPath();
    this.drawTrigsPath(g);
    g.fillStyle = this._fill;
    g.fill();
};

PrimersGlyph.prototype.toSVG = function () {
    var s = new SVGPath();
    this.drawStemPath(s);
    var t = new SVGPath();
    this.drawTrigsPath(t);

    return makeElementNS(NS_SVG, 'g', [makeElementNS(NS_SVG, 'path', null, { d: s.toPathData(),
        stroke: this._stroke || 'none' }), makeElementNS(NS_SVG, 'path', null, { d: t.toPathData(),
        fill: this._fill || 'none' })]);
};

function ArrowGlyph(min, max, height, color, parallel, sw, ne) {
    PathGlyphBase.call(this, null, color);
    this._min = min;
    this._max = max;
    this._height = height;
    this._color = color;
    this._parallel = parallel;
    this._sw = sw;
    this._ne = ne;
}

ArrowGlyph.prototype = Object.create(PathGlyphBase.prototype);

ArrowGlyph.prototype.min = function () {
    return this._min;
};
ArrowGlyph.prototype.max = function () {
    return this._max;
};
ArrowGlyph.prototype.height = function () {
    return this._height;
};

ArrowGlyph.prototype.drawPath = function (g) {
    var min = this._min,
        max = this._max,
        height = this._height;

    if (this._parallel) {
        var hh = height / 2;
        var instep = 0.4 * height;
        if (this._sw) {
            g.moveTo(min + hh, height - instep);
            g.lineTo(min + hh, height);
            g.lineTo(min, hh);
            g.lineTo(min + hh, 0);
            g.lineTo(min + hh, instep);
        } else {
            g.moveTo(min, height - instep);
            g.lineTo(min, instep);
        }
        if (this._ne) {
            g.lineTo(max - hh, instep);
            g.lineTo(max - hh, 0);
            g.lineTo(max, hh);
            g.lineTo(max - hh, height);
            g.lineTo(max - hh, height - instep);
        } else {
            g.lineTo(max, instep);
            g.lineTo(max, height - instep);
        }
        g.closePath();
    } else {
        var mid = (min + max) / 2;
        var instep = 0.4 * (max - min);
        var th = height / 3;

        if (this._ne) {
            g.moveTo(min + instep, th);
            g.lineTo(min, th);
            g.lineTo(mid, 0);
            g.lineTo(max, th);
            g.lineTo(max - instep, th);
        } else {
            g.moveTo(min + instep, 0);
            g.lineTo(max - instep, 0);
        }
        if (this._sw) {
            g.lineTo(max - instep, height - th);
            g.lineTo(max, height - th);
            g.lineTo(mid, height);
            g.lineTo(min, height - th);
            g.lineTo(min + instep, height - th);
        } else {
            g.lineTo(max - instep, height);
            g.lineTo(min + instep, height);
        }
        g.closePath();
    }
};

function TooManyGlyph(min, max, height, fill, stroke) {
    this._min = min;
    this._max = max;
    this._height = height;
    this._fill = fill;
    this._stroke = stroke;
}

TooManyGlyph.prototype.min = function () {
    return this._min;
};
TooManyGlyph.prototype.max = function () {
    return this._max;
};
TooManyGlyph.prototype.height = function () {
    return this._height;
};

TooManyGlyph.prototype.toSVG = function () {
    return makeElementNS(NS_SVG, 'rect', null, { x: this._min,
        y: 0,
        width: this._max - this._min,
        height: this._height,
        stroke: this._stroke || 'none',
        fill: this._fill || 'none' });
};

TooManyGlyph.prototype.draw = function (g) {
    if (this._fill) {
        g.fillStyle = this._fill;
        g.fillRect(this._min, 0, this._max - this._min, this._height);
    }
    if (this._stroke) {
        g.strokeStyle = this._stroke;
        g.strokeRect(this._min, 0, this._max - this._min, this._height);
        g.beginPath();
        for (var n = 2; n < this._height; n += 3) {
            g.moveTo(this._min, n);
            g.lineTo(this._max, n);
        }
        g.stroke();
    }
};

function TextGlyph(GLOBAL_GC, min, max, height, fill, string) {
    this._min = min;
    this._max = max;
    this._height = height;
    this._fill = fill;
    this._string = string;
    this._textLen = GLOBAL_GC.measureText(string).width;
}

TextGlyph.prototype.min = function () {
    return this._min;
};
TextGlyph.prototype.max = function () {
    return Math.max(this._max, this._min + this._textLen);
};
TextGlyph.prototype.height = function () {
    return this._height;
};

TextGlyph.prototype.draw = function (g) {
    g.fillStyle = this._fill;
    g.fillText(this._string, this._min, this._height - 4);
};

TextGlyph.prototype.toSVG = function () {
    return makeElementNS(NS_SVG, 'text', this._string, { x: this._min, y: this._height - 4 });
};

function aminoTileColor(aa, start, color) {
    var ALTERNATE_COLOR = {
        'red': 'darkred',
        'purple': 'mediumpurple',
        'blue': 'darkblue',
        'green': 'darkgreen'
    };
    var color2 = ALTERNATE_COLOR[color.toLowerCase()];
    var tileColors;
    if (!color2) tileColors = ['rgb(73, 68, 149)', 'rgb(9, 0, 103)'];
    // default to UCSC colors
    else tileColors = [color, color2];

    if (aa == '?') return 'black';else if (aa == 'M') return 'greenyellow';else if (aa == '*') return 'crimson';else return tileColors[start % 2];
}

function reverseComplement(sequence) {
    var seq_dict = { 'A': 'T', 'T': 'A', 'G': 'C', 'C': 'G' };
    var rev_seq = sequence.split('').reverse().join('');
    var rev_compl_seq = [];
    for (var b = 0; b < rev_seq.length; ++b) {
        var base = rev_seq.substr(b, 1).toUpperCase();
        rev_compl_seq.push(base in seq_dict ? seq_dict[base] : 'N');
    }
    return rev_compl_seq.join('');
}

function AminoAcidGlyph(min, max, height, fill, seq, orientation, readframe) {
    this._min = min;
    this._max = max;
    this._height = height;
    this._fill = fill;
    this._seq = seq;
    this._orientation = orientation;
    this._readframe = readframe;
}

AminoAcidGlyph.prototype.min = function () {
    return this._min;
};
AminoAcidGlyph.prototype.max = function () {
    return this._max;
};
AminoAcidGlyph.prototype.height = function () {
    return this._height;
};

AminoAcidGlyph.prototype.draw = function (gc) {
    var seq = this._seq;
    var color = this._fill;

    if (!seq) return;

    var scale = (this._max - this._min + 1) / seq.length;

    var prevOverhang = (3 - this._readframe) % 3;
    var nextOverhang = (seq.length - prevOverhang) % 3;
    var leftOverhang = this._orientation == '+' ? prevOverhang : nextOverhang;

    if (leftOverhang > 0) {
        gc.fillStyle = color;
        gc.fillRect(this._min, 0, scale * leftOverhang, this._height);
    }

    for (var p = leftOverhang; p < seq.length; p += 3) {
        var codon = seq.substr(p, 3).toUpperCase();
        if (this._orientation == '-') codon = reverseComplement(codon);
        var aa = codon in AMINO_ACID_TRANSLATION ? AMINO_ACID_TRANSLATION[codon] : '?';
        color = codon.length == 3 ? aminoTileColor(aa, p, this._fill) : this._fill;
        gc.fillStyle = color;
        gc.fillRect(this._min + p * scale, 0, scale * codon.length, this._height);

        if (scale >= 8 && codon.length == 3) {
            gc.fillStyle = 'white';
            gc.fillText(aa, this._min + (p + 1) * scale, this._height);
        }
    }
};

AminoAcidGlyph.prototype.toSVG = function () {
    var g = makeElementNS(NS_SVG, 'g');
    var seq = this._seq;
    var color = this._fill;

    if (!seq) return g;

    var scale = (this._max - this._min + 1) / seq.length;

    var prevOverhang = (3 - this._readframe) % 3;
    var nextOverhang = (seq.length - prevOverhang) % 3;
    var leftOverhang = this._orientation == '+' ? prevOverhang : nextOverhang;

    if (leftOverhang > 0) {
        g.appendChild(makeElementNS(NS_SVG, 'rect', null, {
            x: this._min,
            y: 0,
            width: scale * leftOverhang,
            height: this._height,
            fill: color }));
    }
    for (var p = leftOverhang; p < seq.length; p += 3) {
        var codon = seq.substr(p, 3).toUpperCase();
        if (this._orientation == '-') codon = reverseComplement(codon);
        var aa = codon in AMINO_ACID_TRANSLATION ? AMINO_ACID_TRANSLATION[codon] : '?';
        color = codon.length == 3 ? aminoTileColor(aa, p, this._fill) : this._fill;
        g.appendChild(makeElementNS(NS_SVG, 'rect', null, {
            x: this._min + p * scale,
            y: 0,
            width: scale * codon.length,
            height: this._height,
            fill: color }));

        if (scale >= 8 && codon.length == 3) {
            g.appendChild(makeElementNS(NS_SVG, 'text', aa, {
                x: this._min + (p + 1) * scale,
                y: this._height,
                fill: 'white' }));
        }
    }
    return g;
};

var isRetina = typeof window !== 'undefined' && window.devicePixelRatio > 1;
var __dalliance_SequenceGlyphCache = {};
var altPattern = new RegExp('^[ACGT-]$');
var isCloseUp = function isCloseUp(scale) {
    return scale >= 8;
};

function SequenceGlyph(baseColors, strandColor, min, max, height, seq, ref, scheme, quals, fillbg, scaleVertical) {
    this.baseColors = baseColors;
    this._strandColor = strandColor;
    this._min = min;
    this._max = max;
    this._height = height;
    this._seq = seq;
    this._ref = ref;
    this._scheme = scheme;
    this._quals = quals;
    this._fillbg = fillbg;
    this._scaleVertical = scaleVertical;
}

SequenceGlyph.prototype.min = function () {
    return this._min;
};
SequenceGlyph.prototype.max = function () {
    return this._max;
};
SequenceGlyph.prototype.height = function () {
    return this._height;
};

SequenceGlyph.prototype.alphaForQual = function (qual) {
    return 0.1 + 0.9 * Math.max(0.0, Math.min(1.0 * qual / 30.0, 1.0));
};

SequenceGlyph.prototype.draw = function (gc) {
    var seq = this._seq;
    var ref = this._ref;
    var mismatch = this._scheme === 'mismatch' || this._scheme === 'mismatch-all';
    var all = this._scheme === 'mismatch-all';

    var seqLength = seq ? seq.length : this._max - this._min + 1;
    var scale = (this._max - this._min + 1) / seqLength;

    if (mismatch && !isCloseUp(scale)) {
        gc.fillStyle = this._strandColor;
        if (this._scaleVertical) gc.fillRect(this._min, scale, this._max - this._min, scale);else gc.fillRect(this._min, this._height / 4, this._max - this._min, this._height / 2);
    }

    for (var p = 0; p < seqLength; ++p) {
        var base = seq ? seq.substr(p, 1).toUpperCase() : 'N';

        if (!altPattern.test(base) && !isCloseUp(scale)) continue;

        var color = this.baseColors[base];

        if (this._quals) {
            var qc = this._quals.charCodeAt(p) - 33;
            var oldAlpha = gc.globalAlpha; // NB hoisted!
            gc.globalAlpha = this.alphaForQual(qc);
        }

        if (!color) {
            var refBase = ref ? ref.substr(p, 1).toUpperCase() : 'N';
            if (base == 'N' || refBase == 'N') color = 'gray';else color = this._strandColor;

            if (all) base = refBase;
        }

        gc.fillStyle = color;

        var alt = altPattern.test(base);
        if (this._fillbg || !isCloseUp(scale) || !alt) {
            if (this._scaleVertical) gc.fillRect(this._min + p * scale, scale, scale, scale);else gc.fillRect(this._min + p * scale, 0, scale, this._height);
        }
        if (isCloseUp(scale) && alt) {
            var key = color + '_' + base;
            var img = __dalliance_SequenceGlyphCache[key];
            if (!img) {
                img = document.createElement('canvas');
                if (isRetina) {
                    img.width = 16;
                    img.height = 20;
                } else {
                    img.width = 8;
                    img.height = 10;
                }
                var imgGc = img.getContext('2d');
                if (isRetina) {
                    imgGc.scale(2, 2);
                }
                imgGc.fillStyle = this._fillbg ? 'black' : color;
                var w = imgGc.measureText(base).width;
                imgGc.fillText(base, 0.5 * (8.0 - w), 8);
                __dalliance_SequenceGlyphCache[key] = img;
            }
            var dy = this._scaleVertical ? scale : 0;
            if (isRetina) gc.drawImage(img, this._min + p * scale + 0.5 * (scale - 8), dy, 8, 10);else gc.drawImage(img, this._min + p * scale + 0.5 * (scale - 8), dy);
        }

        if (this._quals) {
            gc.globalAlpha = oldAlpha;
        }
    }
};

SequenceGlyph.prototype.toSVG = function () {
    var seq = this._seq;
    var ref = this._ref;
    var mismatch = this._scheme === 'mismatch' || this._scheme === 'mismatch-all';
    var all = this._scheme === 'mismatch-all';
    var scale = (this._max - this._min + 1) / this._seq.length;
    var g = makeElementNS(NS_SVG, 'g');

    for (var p = 0; p < seq.length; ++p) {
        var base = seq ? seq.substr(p, 1).toUpperCase() : 'N';
        var color = this.baseColors[base];

        if (!color) {
            var refBase = ref ? ref.substr(p, 1).toUpperCase() : 'N';
            if (base == 'N' || refBase == 'N') color = 'gray';else color = this._strandColor;

            if (all) base = refBase;
        }

        var alpha = 1.0;
        if (this._quals) {
            var qc = this._quals.charCodeAt(p) - 33;
            alpha = this.alphaForQual(qc);
        }

        var alt = altPattern.test(base);
        if (this._fillbg || !isCloseUp(scale) || !alt) {
            g.appendChild(makeElementNS(NS_SVG, 'rect', null, {
                x: this._min + p * scale,
                y: 0,
                width: scale,
                height: this._height,
                fill: color,
                fillOpacity: alpha }));
        }

        if (isCloseUp(scale) && alt) {
            g.appendChild(makeElementNS(NS_SVG, 'text', base, {
                x: this._min + (0.5 + p) * scale,
                y: 8,
                textAnchor: 'middle',
                fill: this._fillbg ? 'black' : color,
                fillOpacity: alpha }));
        }
    }

    return g;
};

function TranslatedGlyph(glyph, x, y, height) {
    this.glyph = glyph;
    this._height = height;
    this._x = x;
    this._y = y;
}

TranslatedGlyph.prototype.height = function () {
    if (this._height) {
        return this._height;
    } else {
        return this.glyph.height() + this._y;
    }
};

TranslatedGlyph.prototype.min = function () {
    return this.glyph.min() + this._x;
};

TranslatedGlyph.prototype.max = function () {
    return this.glyph.max() + this._x;
};

TranslatedGlyph.prototype.minY = function () {
    return this._y;
};

TranslatedGlyph.prototype.maxY = function () {
    return this._y + this.glyph.height();
};

TranslatedGlyph.prototype.draw = function (g, o) {
    g.save();
    g.translate(this._x, this._y);
    this.glyph.draw(g, o);
    g.restore();
};

TranslatedGlyph.prototype.toSVG = function () {
    var s = this.glyph.toSVG();
    s.setAttribute('transform', 'translate(' + this._x + ',' + this._y + ')');
    return s;
};

function PointGlyph(x, y, height, fill) {
    this._x = x;
    this._y = y;
    this._height = height;
    this._fill = fill;
}

PointGlyph.prototype.min = function () {
    return this._x - 2;
};

PointGlyph.prototype.max = function () {
    return this._x + 2;
};

PointGlyph.prototype.height = function () {
    return this._height;
};

PointGlyph.prototype.draw = function (g) {
    g.save();
    g.globalAlpha = 0.3;
    g.fillStyle = this._fill;
    g.beginPath();
    g.arc(this._x, this._y, 1.5, 0, 6.29);
    g.fill();
    g.restore();
};

PointGlyph.prototype.toSVG = function () {
    return makeElementNS(NS_SVG, 'circle', null, { cx: this._x, cy: this._y, r: 2,
        fill: this._fill,
        stroke: 'none' });
};

function GridGlyph(height, yOffset, spacing) {
    this._height = height || 50;
    this.yOffset = yOffset || 0;
    this.spacing = spacing || 10;
}

GridGlyph.prototype.notSelectable = true;

GridGlyph.prototype.min = function () {
    return -100000;
};

GridGlyph.prototype.max = function () {
    return 100000;
};

GridGlyph.prototype.height = function () {
    return this._height;
};

GridGlyph.prototype.draw = function (g) {
    g.save();
    g.strokeStyle = 'black';
    g.lineWidth = 0.1;

    g.beginPath();
    for (var y = this.yOffset; y <= this._height + this.yOffset; y += this.spacing) {
        // for (var y = 0; y <= this._height; y += 10) {
        g.moveTo(-5000, y);
        g.lineTo(5000, y);
    }
    g.stroke();
    g.restore();
};

GridGlyph.prototype.toSVG = function () {
    var p = new SVGPath();
    for (var y = 0; y <= this._height; y += 10) {
        p.moveTo(-5000, y);
        p.lineTo(5000, y);
    }

    return makeElementNS(NS_SVG, 'path', null, { d: p.toPathData(),
        fill: 'none',
        stroke: 'black',
        strokeWidth: '0.1px' });
};

function StarGlyph(x, r, points, fill, stroke) {
    PathGlyphBase.call(this, stroke, fill);
    this._x = x;
    this._r = r;
    this._points = points;
}

StarGlyph.prototype = Object.create(PathGlyphBase.prototype);

StarGlyph.prototype.min = function () {
    return this._x - this._r;
};

StarGlyph.prototype.max = function () {
    return this._x + this._r;
};

StarGlyph.prototype.height = function () {
    return 2 * this._r;
};

StarGlyph.prototype.drawPath = function (g) {
    var midX = this._x,
        midY = this._r,
        r = this._r;
    for (var p = 0; p < this._points; ++p) {
        var theta = p * 6.28 / this._points;
        var px = midX + r * Math.sin(theta);
        var py = midY - r * Math.cos(theta);
        if (p == 0) {
            g.moveTo(px, py);
        } else {
            g.lineTo(px, py);
        }
        theta = (p + 0.5) * 6.28 / this._points;
        px = midX + 0.4 * r * Math.sin(theta);
        py = midY - 0.4 * r * Math.cos(theta);
        g.lineTo(px, py);
    }
    g.closePath();
};

function PlimsollGlyph(x, height, overhang, fill, stroke) {
    this._x = x;
    this._height = height;
    this._overhang = overhang;
    this._fill = fill;
    this._stroke = stroke;
    this._hh = height / 2;
}

PlimsollGlyph.prototype.draw = function (g) {
    var hh = this._height / 2;
    g.fillStyle = this._stroke;
    g.beginPath();
    g.arc(this._x, hh, hh - this._overhang, 0, 6.29);
    g.moveTo(this._x, 0);
    g.lineTo(this._x, this._height);

    if (this._fill) {
        g.fillStyle = this._fill;
        g.fill();
    }

    if (this._stroke) {
        g.strokeStyle = this._stroke;
        g.stroke();
    }
};

PlimsollGlyph.prototype.toSVG = function () {
    var hh = this._hh;
    return makeElementNS(NS_SVG, 'g', [makeElementNS(NS_SVG, 'circle', null, { cx: this._x, cy: hh, r: hh - this._overhang }), makeElementNS(NS_SVG, 'line', null, { x1: this._x, y1: 0, x2: this._x, y2: this._height })], { fill: this._fill || 'none',
        stroke: this._stroke || 'none',
        strokeWidth: '1px' });
};

PlimsollGlyph.prototype.min = function () {
    return this._x - this._hh;
};

PlimsollGlyph.prototype.max = function () {
    return this._x + this._hh;
};

PlimsollGlyph.prototype.height = function () {
    return this._height;
};

function OverlayLabelCanvas() {
    this.ox = 0;
    this.oy = 0;
    this.glyphs = [];
}

OverlayLabelCanvas.prototype.translate = function (x, y) {
    this.ox += x;
    this.oy += y;
};

OverlayLabelCanvas.prototype.registerGlyph = function (g) {
    this.glyphs.push({
        x: this.ox,
        y: this.oy,
        glyph: g
    });
};

OverlayLabelCanvas.prototype.draw = function (g, minVisible, maxVisible) {
    for (var gi = 0; gi < this.glyphs.length; ++gi) {
        var gg = this.glyphs[gi];
        g.save();
        g.translate(gg.x, gg.y);
        gg.glyph.drawOverlay(g, minVisible, maxVisible);
        g.restore();
    }
};

if (typeof module !== 'undefined') {
    module.exports = {
        BoxGlyph: BoxGlyph,
        GroupGlyph: GroupGlyph,
        LineGraphGlyph: LineGraphGlyph,
        LabelledGlyph: LabelledGlyph,
        CrossGlyph: CrossGlyph,
        ExGlyph: ExGlyph,
        TriangleGlyph: TriangleGlyph,
        DotGlyph: DotGlyph,
        PaddedGlyph: PaddedGlyph,
        AArrowGlyph: AArrowGlyph,
        SpanGlyph: SpanGlyph,
        LineGlyph: LineGlyph,
        PrimersGlyph: PrimersGlyph,
        ArrowGlyph: ArrowGlyph,
        TooManyGlyph: TooManyGlyph,
        TextGlyph: TextGlyph,
        SequenceGlyph: SequenceGlyph,
        AminoAcidGlyph: AminoAcidGlyph,
        TranslatedGlyph: TranslatedGlyph,
        GridGlyph: GridGlyph,
        StarGlyph: StarGlyph,
        PointGlyph: PointGlyph,
        PlimsollGlyph: PlimsollGlyph,

        OverlayLabelCanvas: OverlayLabelCanvas
    };
}

},{"./spans":40,"./svg-utils":44,"./utils":55}],24:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// jbjson.js -- query JBrowse-style REST data stores
//

if (typeof require !== 'undefined') {
    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;

    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;

    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;
}

function JBrowseStore(base, query) {
    this.base = base;
    this.query = query;
}

function jbori(strand) {
    if (strand > 0) return '+';else if (strand < 0) return '-';
}

JBrowseStore.prototype.features = function (segment, opts, callback) {
    opts = opts || {};

    var url = this.base + '/features/' + segment.name;

    var filters = [];
    if (this.query) {
        filters.push(this.query);
    }
    if (segment.isBounded) {
        filters.push('start=' + segment.start);
        filters.push('end=' + segment.end);
    }
    if (filters.length > 0) {
        url = url + '?' + filters.join('&');
    }

    var req = new XMLHttpRequest();
    req.onreadystatechange = function () {
        if (req.readyState == 4) {
            if (req.status >= 300) {
                callback(null, 'Error code ' + req.status);
            } else {
                var jf = JSON.parse(req.response)['features'];
                var features = [];
                for (var fi = 0; fi < jf.length; ++fi) {
                    var j = jf[fi];

                    var f = new DASFeature();
                    f.segment = segment.name;
                    f.min = (j['start'] | 0) + 1;
                    f.max = j['end'] | 0;
                    if (j.name) {
                        f.label = j.name;
                    }
                    if (j.strand) f.orientation = jbori(j.strand);
                    f.type = j.type || 'unknown';

                    if (j.subfeatures && j.subfeatures.length > 0) {
                        f.id = j.uniqueID;

                        var blocks = [];
                        var cds = [];
                        var all = [];

                        for (var si = 0; si < j.subfeatures.length; ++si) {
                            var sj = j.subfeatures[si];
                            var sf = shallowCopy(f);
                            sf.min = sj.start + 1;
                            sf.max = sj.end;
                            sf.groups = [f];

                            all.push(sf);
                            blocks.push(new Range(sf.min, sf.max));
                            if (sj.type === 'CDS') cds.push(sf);
                        }

                        if (cds.length > 0) {
                            spans = union(blocks);
                            var txGroup = shallowCopy(f);
                            txGroup.type = 'transcript';
                            spans.ranges().forEach(function (exon) {
                                features.push({
                                    segment: segment.name,
                                    min: exon.min(),
                                    max: exon.max(),
                                    orientation: f.orientation,
                                    groups: [txGroup],
                                    type: 'transcript'
                                });
                            });

                            var tlGroup = shallowCopy(f);
                            cds.forEach(function (cdsExon) {
                                cdsExon.type = 'translation';
                                cdsExon.groups = [tlGroup];
                                features.push(cdsExon);
                            });
                        } else {
                            all.forEach(function (f) {
                                features.push(f);
                            });
                        }
                    } else {
                        features.push(f);
                    }
                }
                callback(features);
            }
        }
    };

    req.open('GET', url, true);
    req.responseType = 'text';
    req.send();
};

if (typeof module !== 'undefined') {
    module.exports = {
        JBrowseStore: JBrowseStore
    };
}

},{"./das":10,"./spans":40,"./utils":55}],25:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// kspace.js
//

"use strict";

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var Awaited = utils.Awaited;
    var pusho = utils.pusho;

    var sa = require('./sourceadapters');
    var MappedFeatureSource = sa.MappedFeatureSource;
    var CachingFeatureSource = sa.CachingFeatureSource;
    var BWGFeatureSource = sa.BWGFeatureSource;
    var RemoteBWGFeatureSource = sa.RemoteBWGFeatureSource;
    var BAMFeatureSource = sa.BAMFeatureSource;
    var RemoteBAMFeatureSource = sa.RemoteBAMFeatureSource;
    var DummySequenceSource = sa.DummySequenceSource;
    var DummyFeatureSource = sa.DummyFeatureSource;

    var OverlayFeatureSource = require('./overlay').OverlayFeatureSource;

    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;

    var sample = require('./sample');
    var downsample = sample.downsample;
    var getBaseCoverage = sample.getBaseCoverage;

    var das = require('./das');
    var DASSequence = das.DASSequence;

    var Promise = require('es6-promise').Promise;
}

function FetchPool() {
    var self = this;
    this.reqs = [];
    this.awaitedFeatures = {};
    this.requestsIssued = new Promise(function (resolve, reject) {
        self.notifyRequestsIssued = resolve;
    });
}

FetchPool.prototype.addRequest = function (xhr) {
    this.reqs.push(xhr);
};

FetchPool.prototype.abortAll = function () {
    for (var i = 0; i < this.reqs.length; ++i) {
        this.reqs[i].abort();
    }
};

function KSCacheBaton(chr, min, max, scale, features, status, coverage) {
    this.chr = chr;
    this.min = min;
    this.max = max;
    this.coverage = coverage;
    this.scale = scale;
    this.features = features || [];
    this.status = status;
}

KSCacheBaton.prototype.toString = function () {
    return this.chr + ":" + this.min + ".." + this.max + ";scale=" + this.scale;
};

function KnownSpace(tierMap, chr, min, max, scale, seqSource) {
    this.tierMap = tierMap;
    this.chr = chr;
    this.min = min;
    this.max = max;
    this.scale = scale;
    this.seqSource = seqSource || new DummySequenceSource();
    this.viewCount = 0;

    this.featureCache = {};
    this.latestViews = {};
}

KnownSpace.prototype.cancel = function () {
    this.cancelled = true;
};

KnownSpace.prototype.bestCacheOverlapping = function (chr, min, max) {
    var baton = this.featureCache[this.tierMap[0]];
    if (baton) {
        return baton;
    } else {
        return null;
    }
};

KnownSpace.prototype.retrieveFeatures = function (tiers, chr, min, max, scale, noStartFetches) {
    if (scale != scale) {
        throw "retrieveFeatures called with silly scale";
    }

    if (chr != this.chr) {
        throw "Can't extend Known Space to a new chromosome";
    }
    if (min < 1) {
        min = 1;
    }

    this.min = min;
    this.max = max;
    this.scale = scale;

    if (this.pool) {
        this.pool.abortAll();
    }
    this.pool = new FetchPool();
    this.awaitedSeq = new Awaited();
    this.seqWasFetched = false;
    this.viewCount++;

    if (!noStartFetches) {
        this.startFetchesForTiers(tiers);
    }
    this.pool.notifyRequestsIssued();
};

function filterFeatures(features, min, max) {
    var ff = [];
    var featuresByGroup = {};

    for (var fi = 0; fi < features.length; ++fi) {
        var f = features[fi];
        if (!f.min || !f.max) {
            ff.push(f);
        } else if (f.groups && f.groups.length > 0) {
            pusho(featuresByGroup, f.groups[0].id, f);
        } else if (f.min <= max && f.max >= min) {
            ff.push(f);
        }
    }

    for (var gid in featuresByGroup) {
        var gf = featuresByGroup[gid];
        var gmin = 100000000000,
            gmax = -100000000000;
        for (var fi = 0; fi < gf.length; ++fi) {
            var f = gf[fi];
            gmin = Math.min(gmin, f.min);
            gmax = Math.max(gmax, f.max);
        }
        if (gmin <= max || gmax >= min) {
            for (var fi = 0; fi < gf.length; ++fi) {
                ff.push(gf[fi]);
            }
        }
    }

    return ff;
}

KnownSpace.prototype.invalidate = function (tier) {
    if (!this.pool) {
        return;
    }

    this.featureCache[tier] = null;
    this.startFetchesForTiers([tier]);
};

KnownSpace.prototype.startFetchesForTiers = function (tiers) {
    var thisB = this;

    var awaitedSeq = this.awaitedSeq;
    var needSeq = false;

    var gex;

    for (var t = 0; t < tiers.length; ++t) {
        var tierRenderer = tiers[t].browser.getTierRenderer(tiers[t]);
        try {
            if (this.startFetchesFor(tiers[t], awaitedSeq)) {
                needSeq = true;
            }
        } catch (ex) {
            var tier = tiers[t];

            tier.currentFeatures = [];
            tier.currentSequence = null;
            console.log('Error fetching tier source');
            console.log(ex);
            gex = ex;
            console.log(ex.stack);
            tierRenderer.renderTier(ex, tier);
            tier.wasRendered();
        }
    }

    if (needSeq && !this.seqWasFetched) {
        this.seqWasFetched = true;
        var smin = this.min,
            smax = this.max;

        if (this.cs) {
            if (this.cs.start <= smin && this.cs.end >= smax) {
                var cachedSeq;
                if (this.cs.start == smin && this.cs.end == smax) {
                    cachedSeq = this.cs;
                } else {
                    cachedSeq = new DASSequence(this.cs.name, smin, smax, this.cs.alphabet, this.cs.seq.substring(smin - this.cs.start, smax + 1 - this.cs.start));
                }
                return awaitedSeq.provide(cachedSeq);
            }
        }

        this.seqSource.fetch(this.chr, smin, smax, this.pool, function (err, seq) {
            if (seq) {
                if (!thisB.cs || smin <= thisB.cs.start && smax >= thisB.cs.end || smin >= thisB.cs.end || smax <= thisB.cs.start || smax - smin > thisB.cs.end - thisB.cs.start) {
                    thisB.cs = seq;
                }
                awaitedSeq.provide(seq);
            } else {
                console.log('Sequence loading failed', err);
                awaitedSeq.provide(null);
            }
        });
    }

    if (gex) throw gex;
};

KnownSpace.prototype.startFetchesFor = function (tier, awaitedSeq) {
    var thisB = this;

    var viewID = this.viewCount;
    var source = tier.getSource() || new DummyFeatureSource();
    var needsSeq = tier.needsSequence(this.scale);
    var baton = thisB.featureCache[tier];
    var styleFilters = tier.getActiveStyleFilters(this.scale);
    var wantedTypes;
    if (styleFilters) wantedTypes = styleFilters.typeList();
    var chr = this.chr,
        min = this.min,
        max = this.max;

    if (wantedTypes === undefined) {
        return false;
    }
    if (baton && baton.chr === this.chr && baton.min <= min && baton.max >= max) {
        var cachedFeatures = baton.features;
        if (baton.min < min || baton.max > max) {
            cachedFeatures = filterFeatures(cachedFeatures, min, max);
        }

        thisB.provision(tier, baton.chr, intersection(baton.coverage, new Range(min, max)), baton.scale, wantedTypes, cachedFeatures, baton.status, needsSeq ? awaitedSeq : null);

        var availableScales = source.getScales();

        if (baton.scale <= this.scale || !availableScales) {
            return needsSeq;
        }
    }

    if (source.instrument) console.log('Starting  fetch ' + viewID + ' (' + min + ', ' + max + ')');

    source.fetch(chr, min, max, this.scale, wantedTypes, this.pool, function (status, features, scale, coverage) {
        if (source.instrument) console.log('Finishing fetch ' + viewID);

        var latestViewID = thisB.latestViews[tier] || -1;
        if (thisB.cancelled || latestViewID > viewID) {
            return;
        }

        if (!coverage) {
            coverage = new Range(min, max);
        }

        if (!baton || min < baton.min || max > baton.max) {
            // FIXME should be merging in some cases?
            thisB.featureCache[tier] = new KSCacheBaton(chr, min, max, scale, features, status, coverage);
        }

        thisB.latestViews[tier] = viewID;
        thisB.provision(tier, chr, coverage, scale, wantedTypes, features, status, needsSeq ? awaitedSeq : null);
    }, styleFilters);
    return needsSeq;
};

KnownSpace.prototype.provision = function (tier, chr, coverage, actualScale, wantedTypes, features, status, awaitedSeq) {
    var tierRenderer = tier.browser.getTierRenderer(tier);
    if (status) {
        tier.setFeatures(chr, coverage, actualScale, [], null);
        if (!features) {
            var e = new Error(status);
            status = "Error fetching data: " + status + "; see browser console";
            console.log("Error fetching data for tier " + tier.dasSource.name + ":");
            console.log(tier.dasSource);
            console.log("Stack trace:");
            console.log(e.stack);
        }
        tierRenderer.renderTier(status, tier);
        tier.wasRendered();
    } else {
        var mayDownsample = false;
        var needBaseComposition = false;
        var src = tier.getSource();
        while (MappedFeatureSource.prototype.isPrototypeOf(src) || CachingFeatureSource.prototype.isPrototypeOf(src) || OverlayFeatureSource.prototype.isPrototypeOf(src)) {

            if (OverlayFeatureSource.prototype.isPrototypeOf(src)) {
                src = src.sources[0];
            } else {
                src = src.source;
            }
        }
        if (BWGFeatureSource.prototype.isPrototypeOf(src) || RemoteBWGFeatureSource.prototype.isPrototypeOf(src) || BAMFeatureSource.prototype.isPrototypeOf(src) || RemoteBAMFeatureSource.prototype.isPrototypeOf(src)) {

            mayDownsample = true;
        }

        if (!src.opts || !src.opts.forceReduction && !src.opts.noDownsample) {
            if ( /* (actualScale < (this.scale/2) && features.length > 200)  || */
            mayDownsample && wantedTypes && wantedTypes.length == 1 && wantedTypes.indexOf('density') >= 0) {
                features = downsample(features, this.scale);
            }
        }

        if (wantedTypes && wantedTypes.length == 1 && wantedTypes.indexOf('base-coverage') >= 0) {
            // Base-composition coverage track
            needBaseComposition = true;
        }

        if (awaitedSeq) {
            awaitedSeq.await(function (seq) {
                if (needBaseComposition) {
                    features = getBaseCoverage(features, seq, tier.browser.baseColors);
                }
                tier.setFeatures(chr, coverage, actualScale, features, seq);
                tierRenderer.renderTier(status, tier);
                tier.wasRendered();
            });
        } else {
            tier.setFeatures(chr, coverage, actualScale, features);
            tierRenderer.renderTier(status, tier);
            tier.wasRendered();
        }
    }
};

if (typeof module !== 'undefined') {
    module.exports = {
        KnownSpace: KnownSpace
    };
}

},{"./das":10,"./overlay":30,"./sample":33,"./sourceadapters":38,"./spans":40,"./utils":55,"es6-promise":59}],26:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// lh3utils.js: common support for lh3's file formats
//

if (typeof require !== 'undefined') {
    var jszlib = require('jszlib');
    var jszlib_inflate_buffer = jszlib.inflateBuffer;
    var arrayCopy = jszlib.arrayCopy;
}

function Vob(b, o) {
    this.block = b;
    this.offset = o;
}

Vob.prototype.toString = function () {
    return '' + this.block + ':' + this.offset;
};

function readVob(ba, offset, allowZero) {
    var block = (ba[offset + 6] & 0xff) * 0x100000000 + (ba[offset + 5] & 0xff) * 0x1000000 + (ba[offset + 4] & 0xff) * 0x10000 + (ba[offset + 3] & 0xff) * 0x100 + (ba[offset + 2] & 0xff);
    var bint = ba[offset + 1] << 8 | ba[offset];
    if (block == 0 && bint == 0 && !allowZero) {
        return null; // Should only happen in the linear index?
    } else {
        return new Vob(block, bint);
    }
}

function unbgzf(data, lim) {
    lim = Math.min(lim || 1, data.byteLength - 50);
    var oBlockList = [];
    var ptr = [0];
    var totalSize = 0;

    while (ptr[0] < lim) {
        var ba = new Uint8Array(data, ptr[0], 12); // FIXME is this enough for all credible BGZF block headers?
        var xlen = ba[11] << 8 | ba[10];
        // dlog('xlen[' + (ptr[0]) +']=' + xlen);
        var unc = jszlib_inflate_buffer(data, 12 + xlen + ptr[0], Math.min(65536, data.byteLength - 12 - xlen - ptr[0]), ptr);
        ptr[0] += 8;
        totalSize += unc.byteLength;
        oBlockList.push(unc);
    }

    if (oBlockList.length == 1) {
        return oBlockList[0];
    } else {
        var out = new Uint8Array(totalSize);
        var cursor = 0;
        for (var i = 0; i < oBlockList.length; ++i) {
            var b = new Uint8Array(oBlockList[i]);
            arrayCopy(b, 0, out, cursor, b.length);
            cursor += b.length;
        }
        return out.buffer;
    }
}

function Chunk(minv, maxv) {
    this.minv = minv;this.maxv = maxv;
}

//
// Binning (transliterated from SAM1.3 spec)
//

/* calculate bin given an alignment covering [beg,end) (zero-based, half-close-half-open) */
function reg2bin(beg, end) {
    --end;
    if (beg >> 14 == end >> 14) return ((1 << 15) - 1) / 7 + (beg >> 14);
    if (beg >> 17 == end >> 17) return ((1 << 12) - 1) / 7 + (beg >> 17);
    if (beg >> 20 == end >> 20) return ((1 << 9) - 1) / 7 + (beg >> 20);
    if (beg >> 23 == end >> 23) return ((1 << 6) - 1) / 7 + (beg >> 23);
    if (beg >> 26 == end >> 26) return ((1 << 3) - 1) / 7 + (beg >> 26);
    return 0;
}

/* calculate the list of bins that may overlap with region [beg,end) (zero-based) */
var MAX_BIN = ((1 << 18) - 1) / 7;
function reg2bins(beg, end) {
    var i = 0,
        k,
        list = [];
    --end;
    list.push(0);
    for (k = 1 + (beg >> 26); k <= 1 + (end >> 26); ++k) {
        list.push(k);
    }for (k = 9 + (beg >> 23); k <= 9 + (end >> 23); ++k) {
        list.push(k);
    }for (k = 73 + (beg >> 20); k <= 73 + (end >> 20); ++k) {
        list.push(k);
    }for (k = 585 + (beg >> 17); k <= 585 + (end >> 17); ++k) {
        list.push(k);
    }for (k = 4681 + (beg >> 14); k <= 4681 + (end >> 14); ++k) {
        list.push(k);
    }return list;
}

if (typeof module !== 'undefined') {
    module.exports = {
        unbgzf: unbgzf,
        readVob: readVob,
        reg2bin: reg2bin,
        reg2bins: reg2bins,
        Chunk: Chunk
    };
}

},{"jszlib":60}],27:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// memstore.js
//

"use strict";

if (typeof require !== 'undefined') {
    var sa = require('./sourceadapters');
    var dalliance_registerSourceAdapterFactory = sa.registerSourceAdapterFactory;
    var dalliance_makeParser = sa.makeParser;
    var FeatureSourceBase = sa.FeatureSourceBase;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;

    var utils = require('./utils');
    var Awaited = utils.Awaited;
    var textXHR = utils.textXHR;
}

function MemStore() {
    this.featuresByChr = {};
    this.maxLength = 1;
    this.chrRing = null;
}

MemStore.prototype.addFeatures = function (features) {
    var dirty = {};
    for (var fi = 0; fi < features.length; ++fi) {
        var f = features[fi];
        var chr = f.segment || f.chr;
        var fa = this.featuresByChr[chr];
        if (!fa) {
            fa = [];
            this.featuresByChr[chr] = fa;
        }
        fa.push(f);
        dirty[chr] = true;

        var len = f.max - f.min + 1;
        if (len > this.maxLength) this.maxLength = len;
    }

    for (chr in dirty) {
        var fa = this.featuresByChr[chr];
        fa.sort(function (f1, f2) {
            var d = f1.min - f2.min;
            if (d != 0) return d;
            return f1.max - f2.max;
        });
    }
    this.chrRing = null;
};

MemStore.prototype._indexFor = function (fa, p) {
    var lb = 0,
        ub = fa.length;
    while (ub > lb) {
        var mid = (lb + ub) / 2 | 0;
        if (mid >= fa.length) return fa.length;
        var mg = fa[mid];
        if (p < mg.min) {
            ub = mid;
        } else {
            lb = mid + 1;
        }
    }
    return ub;
};

MemStore.prototype.fetch = function (chr, min, max) {
    var fa = this.featuresByChr[chr];
    if (!fa) {
        if (chr.indexOf('chr') == 0) fa = this.featuresByChr[chr.substring(3)];else fa = this.featuresByChr['chr' + chr];
    }
    if (!fa) return [];

    var mini = Math.max(0, this._indexFor(fa, min - this.maxLength - 1));
    var maxi = Math.min(fa.length - 1, this._indexFor(fa, max));

    var res = [];
    for (var fi = mini; fi <= maxi; ++fi) {
        var f = fa[fi];
        if (f.min <= max && f.max >= min) res.push(f);
    }
    return res;
};

MemStore.prototype.findNextFeature = function (chr, pos, dir) {
    if (this.chrRing == null) {
        this.chrRing = [];
        for (var chr in this.featuresByChr) {
            this.chrRing.push(chr);
        }
        this.chrRing.sort();
    }

    var fa = this.featuresByChr[chr];
    if (!fa) {
        if (chr.indexOf('chr') == 0) {
            chr = chr.substring(3);
            fa = this.featuresByChr[chr];
        } else {
            chr = 'chr' + chr;
            fa = this.featuresByChr[chr];
        }
    }
    if (!fa) return null;

    var i = Math.max(0, Math.min(this._indexFor(fa, pos), fa.length - 1));
    if (dir > 0) {
        while (i < fa.length) {
            var f = fa[i++];
            if (f.min > pos) return f;
        }
        var chrInd = this.chrRing.indexOf(chr) + 1;
        if (chrInd >= this.chrRing.length) chrInd = 0;
        return this.findNextFeature(this.chrRing[chrInd], 0, dir);
    } else {
        while (i >= 0) {
            var f = fa[i--];
            if (f.max < pos) return f;
        }
        var chrInd = this.chrRing.indexOf(chr) - 1;
        if (chrInd < 0) chrInd = this.chrRing.length - 1;
        return this.findNextFeature(this.chrRing[chrInd], 10000000000, dir);
    }
};

function MemStoreFeatureSource(source) {
    this.source = source;
    FeatureSourceBase.call(this);
    this.storeHolder = new Awaited();
    this.parser = dalliance_makeParser(source.payload);
    if (!this.parser) {
        throw "Unsupported memstore payload: " + source.payload;
    }

    var thisB = this;
    this._load(function (resp, err) {
        if (err) {
            thisB.error = err;
            thisB.storeHolder.provide(null);
        } else {
            var store = new MemStore();
            var features = [];
            var lines = resp.split('\n');

            var session = thisB.parser.createSession(function (f) {
                features.push(f);
            });
            for (var li = 0; li < lines.length; ++li) {
                var line = lines[li];
                if (line.length > 0) {
                    session.parse(line);
                }
            }
            session.flush();

            store.addFeatures(features);

            thisB.storeHolder.provide(store);
        }
    });
}

MemStoreFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

MemStoreFeatureSource.prototype._load = function (callback) {
    if (this.source.blob) {
        var r = new FileReader();
        r.onloadend = function () {
            return callback(r.result, r.error);
        };
        r.readAsText(this.source.blob);
    } else {
        if (this.source.credentials) var opts = { credentials: this.source.credentials };
        textXHR(this.source.uri, callback, opts);
    }
};

MemStoreFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, cnt) {
    var thisB = this;
    this.storeHolder.await(function (store) {
        if (store) {
            var f = store.fetch(chr, min, max);
            return cnt(null, f, 100000000);
        } else {
            return cnt(thisB.error);
        }
    });
};

MemStoreFeatureSource.prototype.getStyleSheet = function (callback) {
    if (this.parser && this.parser.getStyleSheet) this.parser.getStyleSheet(callback);
};

MemStoreFeatureSource.prototype.getDefaultFIPs = function (callback, tier) {
    if (this.parser && this.parser.getDefaultFIPs) this.parser.getDefaultFIPs(callback, tier);
};

MemStoreFeatureSource.prototype.getScales = function () {
    return 100000000;
};

MemStoreFeatureSource.prototype.findNextFeature = function (chr, pos, dir, callback) {
    var thisB = this;
    this.storeHolder.await(function (store) {
        if (store) {
            return callback(store.findNextFeature(chr, pos, dir));
        } else {
            return callback(null, thisB.error);
        }
    });
};

MemStoreFeatureSource.prototype.capabilities = function () {
    var caps = { leap: true };
    return caps;
};

dalliance_registerSourceAdapterFactory('memstore', function (source) {
    return { features: new MemStoreFeatureSource(source) };
});

},{"./das":10,"./sourceadapters":38,"./utils":55}],28:[function(require,module,exports){
/* jshint esversion: 6 */
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.drawTier = exports.renderTier = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _sequenceDraw = require("./sequence-draw.js");

var _glyphs = require("./glyphs.js");

var _defaultRenderer = require("./default-renderer");

var DefaultRenderer = _interopRequireWildcard(_defaultRenderer);

var _ramda = require("ramda");

var R = _interopRequireWildcard(_ramda);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.renderTier = renderTier;
exports.drawTier = drawTier;

/* Renders multiple tiers in a single track.
   Works by simply drawing several tiers to a single canvas.
   Actual rendering is done using default-renderer.es6.
   A multi-tier renderer is configured by adding the following to a tier's
   configuration:
   renderer: 'multi',
   multi: {
       multi_id: "multi_1",
   }

   All subtiers with the "multi_1" multi_id will be drawn to this tier's canvas.
 */

function renderTier(status, tier) {
    drawTier(tier);
    tier.updateStatus(status);
}

function drawTier(multiTier) {
    var multiConfig = multiTier.dasSource.multi;
    var getSubConfig = function getSubConfig(t) {
        return t.dasSource.sub;
    };

    // Padding is used for finding the correct canvas size and must be set
    if (!multiTier.padding) multiTier.padding = 3;

    var canvas = multiTier.viewport.getContext("2d");
    var retina = multiTier.browser.retina && window.devicePixelRatio > 1;
    if (retina) {
        canvas.scale(2, 2);
    }

    // Filter out only tiers that are to be drawn in this multitier,
    // and also have fetched data.
    var tiers = multiTier.browser.tiers.filter(function (tier) {
        return _typeof(getSubConfig(tier)) === "object" && getSubConfig(tier).multi_id === multiConfig.multi_id && (tier.currentFeatures || tier.currentSequence);
    });

    // The shortest distance from the top of the canvas to a subtier
    var minOffset = R.pipe(R.map(function (tier) {
        return tier.dasSource.sub.offset;
    }), R.reduce(function (acc, offset) {
        return offset < acc ? offset : acc;
    }, 0))(tiers);

    tiers.forEach(function (tier) {
        if (tier.sequenceSource) {
            (0, _sequenceDraw.drawSeqTier)(tier, tier.currentSequence);
        } else {
            // Shift subtiers up by the minimum offset,
            // so that there's no empty space at the top
            DefaultRenderer.prepareSubtiers(tier, canvas, getSubConfig(tier).offset - minOffset, false);
        }

        // Must be set for painting to work
        if (!multiTier.glyphCacheOrigin) multiTier.glyphCacheOrigin = tier.glyphCacheOrigin;
    });

    // The canvas should fit all subtiers, including offsets, but no more
    var canvasHeight = R.pipe(R.map(function (tier) {
        return R.map(function (subtier) {
            return subtier.height + getSubConfig(tier).offset;
        }, tier.subtiers);
    }), R.flatten, R.reduce(function (acc, h) {
        return h > acc ? h : acc;
    }, -Infinity), R.add(-minOffset))(tiers);

    prepareViewport(multiTier, canvas, retina, canvasHeight, true);

    tiers.sort(function (t1, t2) {
        return getSubConfig(t1).z > getSubConfig(t2).z;
    });

    // TODO: make it add the glyph on to the first available tier;
    // crashes if last tier is empty...
    if (multiConfig.grid && tiers && tiers[tiers.length - 1] && tiers[tiers.length - 1].subtiers[0]) {
        var grid = new _glyphs.GridGlyph(canvasHeight, multiConfig.grid_offset, multiConfig.grid_spacing);
        // pretty hacky way of adding the grid, but it works (mostly)
        tiers[tiers.length - 1].subtiers[0].glyphs.unshift(grid);
    }

    tiers.forEach(function (tier) {
        // Need to save and restore canvas to make sure that the subtiers are
        // drawn on top of one another, if not shifted...
        canvas.save();
        DefaultRenderer.paint(tier, canvas, retina, true);
        canvas.restore();
    });

    multiTier.drawOverlay();

    if (multiConfig.quant) {
        var quantCanvas = DefaultRenderer.createQuantOverlay(multiTier, canvasHeight + multiTier.padding * 2, retina);
        DefaultRenderer.paintQuant(quantCanvas, multiTier, multiConfig.quant, 10);
    }

    if (typeof multiTier.dasSource.drawCallback === "function") {
        multiTier.dasSource.drawCallback(canvas, multiTier);
    }

    multiTier.originHaxx = 0;
    multiTier.browser.arrangeTiers();
}

function prepareViewport(tier, canvas, retina, canvasHeight) {
    var clear = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

    var desiredWidth = tier.browser.featurePanelWidth + 2000;
    if (retina) {
        desiredWidth *= 2;
    }

    var fpw = tier.viewport.width | 0;
    if (fpw < desiredWidth - 50) {
        tier.viewport.width = fpw = desiredWidth;
    }

    canvasHeight += 2 * tier.padding;
    canvasHeight = Math.max(canvasHeight, tier.browser.minTierHeight);

    if (canvasHeight != tier.viewport.height) {
        tier.viewport.height = canvasHeight;

        if (retina) {
            tier.viewport.height *= 2;
        }
    }

    tier.viewportHolder.style.left = '-1000px';
    tier.viewport.style.width = retina ? '' + fpw / 2 + 'px' : '' + fpw + 'px';
    tier.viewport.style.height = '' + canvasHeight + 'px';
    tier.layoutHeight = Math.max(canvasHeight, tier.browser.minTierHeight);

    tier.updateHeight();
    tier.norigin = tier.browser.viewStart;

    if (clear) {
        DefaultRenderer.clearViewport(canvas, fpw, canvasHeight);
    }

    DefaultRenderer.drawUnmapped(tier, canvas, canvasHeight);
}

},{"./default-renderer":11,"./glyphs.js":23,"./sequence-draw.js":35,"ramda":62}],29:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// numformats.js
//

function formatLongInt(n) {
    return (n | 0).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

function formatQuantLabel(v) {
    return (typeof v === "string" ? parseFloat(v) : v).toPrecision(1);
}

if (typeof module !== 'undefined') {
    module.exports = {
        formatLongInt: formatLongInt,
        formatQuantLabel: formatQuantLabel
    };
}

},{}],30:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// overlay.js: featuresources composed from multiple underlying sources
//

"use strict";

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;
    var arrayIndexOf = utils.arrayIndexOf;
}

function OverlayFeatureSource(sources, opts) {
    this.sources = sources;
    this.opts = opts || {};
    this.activityListeners = [];
    this.readinessListeners = [];
    this.changeListeners = [];
    this.business = [];
    this.readiness = [];

    for (var i = 0; i < this.sources.length; ++i) {
        this.initN(i);
    }

    if (typeof opts.merge === 'function') {
        this.merge = opts.merge;
    } else if (opts.merge == 'concat') {
        this.merge = OverlayFeatureSource_merge_concat;
    } else if (opts.merge == 'alternates') {
        this.merge = OverlayFeatureSource_merge_concat;
        this.filterDispatchOnMethod = true;
    } else {
        this.merge = OverlayFeatureSource_merge_byKey;
    }
}

OverlayFeatureSource.prototype.initN = function (n) {
    var s = this.sources[n];
    var thisB = this;
    this.business[n] = 0;

    if (s.addActivityListener) {
        s.addActivityListener(function (b) {
            thisB.business[n] = b;
            thisB.notifyActivity();
        });
    }
    if (s.addChangeListener) {
        s.addChangeListener(function () {
            thisB.notifyChange();
        });
    }
    if (s.addReadinessListener) {
        s.addReadinessListener(function (r) {
            thisB.readiness[n] = r;
            thisB.notifyReadiness();
        });
    }
};

OverlayFeatureSource.prototype.addReadinessListener = function (l) {
    this.readinessListeners.push(l);
    this.notifyReadinessListener(l);
};

OverlayFeatureSource.prototype.removeReadinessListener = function (l) {
    var idx = arrayIndexOf(this.readinessListeners, l);
    if (idx >= 0) {
        this.readinessListeners.splice(idx, 1);
    }
};

OverlayFeatureSource.prototype.notifyReadiness = function () {
    for (var i = 0; i < this.readinessListeners.length; ++i) {
        this.notifyReadinessListener(this.readinessListeners[i]);
    }
};

OverlayFeatureSource.prototype.notifyReadinessListener = function (l) {
    var r = null;
    for (var i = 0; i < this.readiness.length; ++i) {
        if (this.readiness[i] != null) {
            r = this.readiness[i];break;
        }
    }
    try {
        l(r);
    } catch (e) {
        console.log(e);
    }
};

OverlayFeatureSource.prototype.addActivityListener = function (l) {
    this.activityListeners.push(l);
};

OverlayFeatureSource.prototype.removeActivityListener = function (l) {
    var idx = arrayIndexOf(this.activityListeners, l);
    if (idx >= 0) {
        this.activityListeners.splice(idx, 1);
    }
};

OverlayFeatureSource.prototype.notifyActivity = function () {
    var busy = 0;
    for (var i = 0; i < this.business.length; ++i) {
        busy += this.business[i];
    }

    for (var li = 0; li < this.activityListeners.length; ++li) {
        try {
            this.activityListeners[li](busy);
        } catch (e) {
            console.log(e);
        }
    }
};

OverlayFeatureSource.prototype.addChangeListener = function (listener) {
    this.changeListeners.push(listener);
};

OverlayFeatureSource.prototype.removeChangeListener = function (l) {
    var idx = arrayIndexOf(this.changeListeners, l);
    if (idx >= 0) {
        this.changeListeners.splice(idx, 1);
    }
};

OverlayFeatureSource.prototype.notifyChange = function () {
    for (var li = 0; li < this.changeListeners.length; ++li) {
        try {
            this.changeListeners[li](this.busy);
        } catch (e) {
            console.log(e);
        }
    }
};

OverlayFeatureSource.prototype.getScales = function () {
    return this.sources[0].getScales();
};

OverlayFeatureSource.prototype.getStyleSheet = function (callback) {
    return this.sources[0].getStyleSheet(callback);
};

OverlayFeatureSource.prototype.capabilities = function () {
    var caps = {};
    var s0 = this.sources[0];
    if (s0.capabilities) caps = shallowCopy(s0.capabilities());

    for (var i = 1; i < this.sources.length; ++i) {
        var si = this.sources[i];
        if (si.capabilities) {
            var co = si.capabilities();
            if (co.search) {
                caps.search = co.search;
            }
        }
    }

    return caps;
};

OverlayFeatureSource.prototype.search = function (query, callback) {
    for (var i = 0; i < this.sources.length; ++i) {
        if (_sourceAdapterIsCapable(this.sources[i], 'search')) {
            return this.sources[i].search(query, callback);
        }
    }
};

OverlayFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback, styleFilters) {
    var sources;
    if (this.filterDispatchOnMethod) {
        sources = [];
        var sfl = styleFilters.list();
        for (var si = 0; si < this.sources.length; ++si) {
            var source = this.sources[si];
            for (var fi = 0; fi < sfl.length; ++fi) {
                var filter = sfl[fi];
                if (!filter.method || filter.method == source.name) {
                    sources.push(source);
                    break;
                }
            }
        }
    } else {
        sources = this.sources;
    }

    var baton = new OverlayBaton(this, callback, sources);
    for (var si = 0; si < sources.length; ++si) {
        this.fetchN(baton, si, sources[si], chr, min, max, scale, types, pool, styleFilters);
    }
};

OverlayFeatureSource.prototype.fetchN = function (baton, si, source, chr, min, max, scale, types, pool, styleFilters) {
    // FIXME should we try to prune styleFilters?
    source.fetch(chr, min, max, scale, types, pool, function (status, features, scale) {
        return baton.completed(si, status, features, scale);
    }, styleFilters);
};

OverlayFeatureSource.prototype.quantFindNextFeature = function (chr, pos, dir, threshold, callback) {
    return this.sources[0].quantFindNextFeature(chr, pos, dir, threshold, callback);
};

OverlayFeatureSource.prototype.findNextFeature = function (chr, pos, dir, callback) {
    return this.sources[0].findNextFeature(chr, pos, dir, callback);
};

function OverlayBaton(source, callback, sources) {
    this.source = source;
    this.callback = callback;
    this.sources = sources;
    this.count = sources.length;

    this.returnCount = 0;
    this.statusCount = 0;
    this.returns = [];
    this.features = [];
    this.statuses = [];
    this.scale = null;
}

OverlayBaton.prototype.completed = function (index, status, features, scale) {
    if (this.scale == null || index == 0) this.scale = scale;

    if (this.returns[index]) throw 'Multiple returns for source ' + index;

    this.returns[index] = true;
    this.returnCount++;

    this.features[index] = features;

    if (status) {
        this.statuses[index] = status;
        this.statusCount++;
    }

    if (this.returnCount == this.count) {
        if (this.statusCount > 0) {
            var message = '';
            for (var si = 0; si < this.count; ++si) {
                var s = this.statuses[si];
                if (s) {
                    if (message.length > 0) message += ', ';
                    message += s;
                }
            }
            return this.callback(message, null, this.scale);
        } else {
            this.callback(null, this.source.merge(this.features, this.sources), this.scale);
        }
    }
};

OverlayFeatureSource.prototype.getDefaultFIPs = function (callback) {
    for (var si = 0; si < this.sources.length; ++si) {
        var s = this.sources[si];
        if (s.getDefaultFIPs) s.getDefaultFIPs(callback);
    }
};

OverlayFeatureSource.prototype.keyForFeature = function (feature) {
    return '' + feature.min + '..' + feature.max;
};

function OverlayFeatureSource_merge_byKey(featureSets) {
    var omaps = [];

    for (var fsi = 1; fsi < featureSets.length; ++fsi) {
        var om = {};
        var of = featureSets[fsi];
        for (var fi = 0; fi < of.length; ++fi) {
            om[this.keyForFeature(of[fi])] = of[fi];
        }
        omaps.push(om);
    }

    var mf = [];
    var fl = featureSets[0];
    for (var fi = 0; fi < fl.length; ++fi) {
        var f = fl[fi];

        for (var oi = 0; oi < omaps.length; ++oi) {
            var om = omaps[oi];
            of = om[this.keyForFeature(f)];
            if (of) {
                for (var k in of) {
                    if (k === 'score') {
                        f.score2 = of.score;
                    } else if (k === 'min' || k === 'max' || k === 'segment' || k === '_cachedStyle') {
                        // do nothing
                    } else {
                        f[k] = of[k];
                    }
                }
            }
        }
        mf.push(f);
    }
    return mf;
}

function OverlayFeatureSource_merge_concat(featureSets, sources) {
    var features = [];
    for (var fsi = 0; fsi < featureSets.length; ++fsi) {
        var fs = featureSets[fsi];
        var name = sources[fsi].name;
        for (var fi = 0; fi < fs.length; ++fi) {
            var f = fs[fi];
            f.method = name;
            features.push(f);
        }
    }
    return features;
}

function _sourceAdapterIsCapable(s, cap) {
    if (!s.capabilities) return false;else return s.capabilities()[cap];
}

if (typeof module !== 'undefined') {
    module.exports = {
        OverlayFeatureSource: OverlayFeatureSource
    };
}

},{"./utils":55}],31:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// probe.js
//

"use strict";

if (typeof require !== 'undefined') {
    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;
    var BlobFetchable = bin.BlobFetchable;
    var readInt = bin.readInt;

    var bbi = require('./bigwig');
    var BIG_WIG_MAGIC = bbi.BIG_WIG_MAGIC;
    var BIG_BED_MAGIC = bbi.BIG_BED_MAGIC;

    var lh3utils = require('./lh3utils');
    var unbgzf = lh3utils.unbgzf;

    var bam = require('./bam');
    var BAM_MAGIC = bam.BAM_MAGIC;
    var BAI_MAGIC = bam.BAI_MAGIC;

    var tbi = require('./tabix');
    var TABIX_MAGIC = tbi.TABIX_MAGIC;

    var EncodeFetchable = require('./encode').EncodeFetchable;
}

function probeResource(source, listener, retry) {
    var BED_REGEXP = new RegExp('^\\w+\\s+[0-9]+\\s+[0-9]+.*$');
    var KV_REGEXP = /([^=]+)=\"?([^\"]+)\"?/;
    var VCFHEAD_RE = /^##\s*fileformat=VCFv4\..+/;

    var fetchable;
    if (source.blob) fetchable = new BlobFetchable(source.blob);else if (source.transport == 'encode') fetchable = new EncodeFetchable(source.uri);else fetchable = new URLFetchable(source.uri, { credentials: source.credentials });

    fetchable.slice(0, 1 << 16).salted().fetch(function (result, error) {
        if (!result) {
            if (!retry) {
                source.credentials = true;
                probeResource(source, listener, true);
            }

            return listener(source, "Couldn't fetch data");
        }

        var ba = new Uint8Array(result);
        var la = new Uint32Array(result, 0, 1);
        var magic = la[0];
        if (magic == BIG_WIG_MAGIC || magic == BIG_BED_MAGIC) {
            source.tier_type = 'bwg';
            var nameExtractPattern = new RegExp('/?([^/]+?)(.bw|.bb|.bigWig|.bigBed)?$');
            var match = nameExtractPattern.exec(source.uri || source.blob.name);
            if (match) {
                source.name = match[1];
            }

            return listener(source, null);
        } else if (magic == BAI_MAGIC) {
            source.tier_type = 'bai';
            return listener(source, null);
        } else if (ba[0] == 31 || ba[1] == 139) {
            var unc = unbgzf(result);
            var uncba = new Uint8Array(unc);
            magic = readInt(uncba, 0);
            if (magic == BAM_MAGIC) {
                source.tier_type = 'bam';
                var nameExtractPattern = new RegExp('/?([^/]+?)(.bam)?$');
                var match = nameExtractPattern.exec(source.uri || source.blob.name);
                if (match) {
                    source.name = match[1];
                }

                return listener(source, null);
            } else if (magic == TABIX_MAGIC) {
                source.tier_type = 'tabix-index';
                return listener(source, null);
            } else if (magic == 0x69662323) {
                source.tier_type = 'tabix';
                source.payload = 'vcf';
                var nameExtractPattern = new RegExp('/?([^/]+?)(.vcf)?(.gz)?$');
                var match = nameExtractPattern.exec(source.uri || source.blob.name);
                if (match) {
                    source.name = match[1];
                }

                return listener(source, null);
            } else {
                console.log('magic = ' + magic.toString(16));
                return listener(source, "Unsupported format");
            }
        } else {
            var text = String.fromCharCode.apply(null, ba);
            var lines = text.split("\n");

            if (lines.length > 0 && VCFHEAD_RE.test(lines[0])) {
                source.tier_type = 'memstore';
                source.payload = 'vcf';
                var nameExtractPattern = new RegExp('/?([^/]+?)(\.vcf)?$');
                var match = nameExtractPattern.exec(source.uri || source.blob.name);
                if (match && !source.name) {
                    source.name = match[1];
                }
                return listener(source, null);
            }

            for (var li = 0; li < lines.length; ++li) {
                var line = lines[li].replace('\r', '');
                if (line.length == 0) continue;

                if (line.indexOf('browser') == 0) continue;

                if (line.indexOf('track') == 0) {
                    var maybeType = 'bed';
                    var toks = line.split(/\s/);
                    for (var ti = 1; ti < toks.length; ++ti) {
                        var m = KV_REGEXP.exec(toks[ti]);
                        if (m) {
                            if (m[1] == 'type' && m[2] == 'wiggle_0') {
                                maybeType = 'wig';
                            } else if (m[0] == 'name') {
                                source.name = m[2];
                            }
                        }
                    }

                    finishProbeBedWig(source, maybeType);
                    return listener(source, null);
                }

                if (line.indexOf('fixedStep') == 0) {
                    finishProbeBedWig(source, 'wig');
                    return listener(source, null);
                }

                if (line.indexOf('variableStep') == 0) {
                    finishProbeBedWig(source, 'wig');
                    return listener(source, null);
                }

                if (BED_REGEXP.test(line)) {
                    finishProbeBedWig(source, null);
                    return listener(source, null);
                }

                break;
            }

            return listener(source, "Unsupported format");
        }
    }, { timeout: 1500 }); // Timeout to catch mixed-origin case on Chromium.
}

function finishProbeBedWig(source, maybeType) {
    source.tier_type = 'memstore';
    var nameExtractPattern = new RegExp('/?([^/]+?)(.(bed|wig))?$');
    var match = nameExtractPattern.exec(source.uri || source.blob.name);
    if (match) {
        if (!source.name) source.name = match[1];
        if (!maybeType && match[3]) {
            maybeType = match[3];
        }
    }
    source.payload = maybeType || 'bed';
}

if (typeof module !== 'undefined') {
    module.exports = {
        probeResource: probeResource
    };
}

},{"./bam":1,"./bigwig":3,"./bin":4,"./encode":14,"./lh3utils":26,"./tabix":46}],32:[function(require,module,exports){
/* jshint esversion: 6 */

"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Ruler = Ruler;
exports.rulerDrawCallback = rulerDrawCallback;


function Ruler(options) {
    var self = this;

    self.value = options.value;
    self.min = options.min;
    self.max = options.max;
    self.width = options.width;
    self.color = options.color;

    Object.keys(self).map(function (key) {
        if (self[key] === undefined) {
            console.log("WARNING: Ruler option " + key + " not set");
        }
    });
}

Ruler.prototype.constructor = Ruler;

function rulerDrawCallback(canvas, tier) {
    var rulers = tier.dasSource.rulers;

    if (!rulers) {
        console.log("Tier uses ruler callback but has no rulers!");
    } else if (!(rulers instanceof Array)) {
        console.log("rulers.js: 'rulers' should be an Array");
    }

    rulers.map(function (r) {
        var rulerY = (r.max - r.value) * r.height;
        var viewWidth = tier.viewport.width;
        var oldLineWidth = canvas.lineWidth;

        canvas.strokeStyle = r.color;
        canvas.beginPath();
        canvas.moveTo(-viewWidth, rulerY + r.offset);
        // Other parts of the code rely on not having changed the lineWidth...
        // So we need to change it back when we're done.
        canvas.lineWidth = r.width;
        canvas.lineTo(2 * viewWidth, rulerY + r.offset);
        canvas.stroke();
        canvas.lineWidth = oldLineWidth;
    });
}

},{}],33:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// sample.js: downsampling of quantitative features
//

"use strict";

if (typeof require !== 'undefined') {
    var das = require('./das');
    var DASFeature = das.DASFeature;

    var parseCigar = require('./cigar').parseCigar;

    var shallowCopy = require('./utils').shallowCopy;
}

var __DS_SCALES = [1, 2, 5];

function ds_scale(n) {
    return __DS_SCALES[n % __DS_SCALES.length] * Math.pow(10, n / __DS_SCALES.length | 0);
}

function DSBin(scale, min, max) {
    this.scale = scale;
    this.tot = 0;
    this.cnt = 0;
    this.hasScore = false;
    this.min = min;this.max = max;
    this.features = [];
}

function _featureOrder(a, b) {
    if (a.min < b.min) {
        return -1;
    } else if (a.min > b.min) {
        return 1;
    } else if (a.max < b.max) {
        return -1;
    } else if (b.max > a.max) {
        return 1;
    } else {
        return 0;
    }
}

DSBin.prototype.score = function () {
    if (this.cnt == 0) {
        return 0;
    } else if (this.hasScore) {
        return this.tot / this.cnt;
    } else {
        var features = this.features;
        features.sort(_featureOrder);

        var maxSeen = -10000000000;
        var cov = 0,
            lap = 0;

        for (var fi = 1; fi < features.length; ++fi) {
            var f = features[fi];
            var lMin = Math.max(f.min, this.min);
            var lMax = Math.min(f.max, this.max);
            lap += lMax - lMin + 1;

            if (lMin > maxSeen) {
                cov += lMax - lMin + 1;
                maxSeen = lMax;
            } else {
                if (lMax > maxSeen) {
                    cov += lMax - maxSeen;
                    maxSeen = lMax;
                }
            }
        }

        if (cov > 0) return 1.0 * lap / cov;else return 0;
    }
};

DSBin.prototype.feature = function (f) {
    if (f.score !== undefined) {
        this.tot += f.score;
        this.hasScore = true;
    }

    ++this.cnt;
    this.features.push(f);
};

function downsample(features, targetRez) {
    var sn = 0;
    while (ds_scale(sn + 1) < targetRez) {
        ++sn;
    }
    var scale = ds_scale(sn);

    var binTots = [];
    var maxBin = -10000000000;
    var minBin = 10000000000;
    for (var fi = 0; fi < features.length; ++fi) {
        var f = features[fi];
        if (f.groups && f.groups.length > 0) {
            // Don't downsample complex features (?)
            return features;
        }

        var minLap = f.min / scale | 0;
        var maxLap = f.max / scale | 0;
        maxBin = Math.max(maxBin, maxLap);
        minBin = Math.min(minBin, minLap);
        for (var b = minLap; b <= maxLap; ++b) {
            var bm = binTots[b];
            if (!bm) {
                bm = new DSBin(scale, b * scale, (b + 1) * scale - 1);
                binTots[b] = bm;
            }
            bm.feature(f);
        }
    }

    var sampledFeatures = [];
    for (var b = minBin; b <= maxBin; ++b) {
        var bm = binTots[b];
        if (bm) {
            var f = new DASFeature();
            f.segment = features[0].segment;
            f.min = b * scale + 1;
            f.max = (b + 1) * scale;
            f.score = bm.score();
            f.type = 'density';
            sampledFeatures.push(f);
        }
    }

    var afterDS = Date.now();
    return sampledFeatures;
}

/** Data structure to store information for
a base position:

pos: position of the base.
*/
function BaseBin(pos) {

    this._pos = pos;
    this._bases = {};
    this._totalCount = 0;
}

/** Keep record for incidence of a base,
with related qual score and strand for a position.

Params
    base: base (e.g A, T, G, C, N) observed at position.
    qual: numeric quality score.
    strand: '+' or '-'.
*/
BaseBin.prototype.recordBase = function (base, qual, strand) {
    if (!this._bases[base]) {
        var strandComposition = { '+': 0, '-': 0 };
        strandComposition[strand]++;
        this._bases[base] = {
            cnt: 1,
            totalQual: qual,
            strandCnt: strandComposition
        };
    } else {
        var baseComposition = this._bases[base];
        baseComposition.cnt++;
        baseComposition.totalQual += qual;
        baseComposition.strandCnt[strand]++;
    }
    this._totalCount++;
};

/** Returns count of total number of bases observed at position */
BaseBin.prototype.totalCount = function () {
    return this._totalCount;
};

/** Returns the base position */
BaseBin.prototype.pos = function () {
    return this._pos;
};

/** Creates a list of tag, info pairs in the form
[tag]=[info] for each base, for use in feature-popup */
BaseBin.prototype.infoList = function () {
    var info = [];
    var totalCount = this._totalCount;
    var totalCountStr = "Depth=" + totalCount.toString();
    info.push(totalCountStr);
    for (var base in this._bases) {
        var baseComposition = this._bases[base];
        var baseCnt = baseComposition.cnt;
        var basePercentage = baseCnt * 100 / totalCount;
        var plusStrandCnt = baseComposition.strandCnt['+'];
        var minusStrandCnt = baseComposition.strandCnt['-'];
        var meanQual = baseComposition.totalQual / baseCnt;

        var baseInfoString = [base, '=', baseCnt, ' (', basePercentage.toFixed(0), '%, ', plusStrandCnt, ' +, ', minusStrandCnt, ' -, Qual: ', meanQual.toFixed(0), ')'];
        info.push(baseInfoString.join(''));
    }
    return info;
};

/** Return a list of objects for creating a
histogram showing composition of different bases at a
given location.

Current implementation is hacky: the logic involves
overlaying BoxGlyphs on top of each other, thus the score
is not meaningful, but only used to manipulate height.

Params:
  ref: reference base at position
  threshold: value between 0 and 1 representing min allele frequency
              below which the allele will be ignored in histogram.
              (interpreted as noise)
              Similar to 'allele threshold' parameter in IGV

Returns a list of objects containing 2 properties
    base: such as A, T, G, C, N, - (del)
    score: a numeric score for determining height of histogram
The list is ordered such that a preceeding object always have a
score >= the current object, and the ref base will be the last item.

Example: There are 50 T's and 40 A's (total depth = 90)
at a base where ref=A. The function will return
[T: 90, A: 40]. When creating a histogram with overlap,
this will give an appearance of 40 A's (bottom) and 50 T's (top):
#######
#  T  #
#  T  #
#  T  #
#  T  #
#  T  #
#######
#  A  #
#  A  #
#  A  #
#  A  #
#######
*/
BaseBin.prototype.baseScoreList = function (ref, threshold) {
    var baseScoreList = [];
    var totalCount = this._totalCount;
    var minCount = threshold * totalCount;
    for (var base in this._bases) {
        var baseCount = this._bases[base].cnt;
        if (baseCount < minCount || base == ref) continue;
        var baseScorePair = { base: base, score: totalCount };
        baseScoreList.push(baseScorePair);
        totalCount -= baseCount;
    }
    baseScoreList.push({ base: ref, score: totalCount });
    return baseScoreList;
};

/** Generates an aligned read from the raw sequence of a BAM record
using given cigar string.

Params:
  rawseq: unaligned read sequence from Bam record
  rawquals: unaligned read quals from Bam record
  cigar: Bam cigar string from Bam record

Returns an object with 2 properties:
  seq: string containing aligned read
  quals: string containing printable-character representation
         of sequencing quality score
*/
function alignSeqUsingCigar(rawseq, rawquals, cigar) {
    var ops = parseCigar(cigar);
    var seq = [];
    var quals = [];
    var cursor = 0;
    for (var ci = 0; ci < ops.length; ++ci) {
        var co = ops[ci];
        if (co.op == 'M') {
            seq.push(rawseq.substr(cursor, co.cnt));
            quals.push(rawquals.substr(cursor, co.cnt));
            cursor += co.cnt;
        } else if (co.op == 'D') {
            for (var oi = 0; oi < co.cnt; ++oi) {
                seq.push('-');
                quals.push('Z');
            }
        } else if (co.op == 'I') {
            cursor += co.cnt;
        } else if (co.op == 'S') {
            cursor += co.cnt;
        } else {
            console.log('unknown cigop' + co.op);
        }
    }
    var processedSeq = { seq: seq.join(''), quals: quals.join('') };
    return processedSeq;
}

/** Constructs the reference sequence for a given window.

Params
    currentSequence: DasSequence object containing ref sequence
                     in current browser view.
    min, max: min and max position for window.

Returns a string containing the refseq, padded with 'N' where sequence is not
    available.
*/
function getRefSeq(currentSequence, min, max) {
    var refSeq = [];
    if (currentSequence) {
        var csStart = currentSequence.start | 0;
        var csEnd = currentSequence.end | 0;
        if (csStart <= max && csEnd >= min) {
            var sfMin = Math.max(min, csStart);
            var sfMax = Math.min(max, csEnd);

            for (var i = 0; i < sfMin - min; i++) {
                refSeq.push('N');
            }refSeq.push(currentSequence.seq.substr(sfMin - csStart, sfMax - sfMin + 1));
            for (var i = 0; i < max - sfMax; i++) {
                refSeq.push('N');
            }
        }
    }
    return refSeq.join('');
}

/** Constructs features necessary for a coverage track showing
base composition for BAM reads

Params
    features: a list of features from BAM records.
    currentRefSeq: a DASSequence object containing reference sequence.
    baseColors: an object mapping base to desired colors.

Returns a list of features of type base-coverage.
*/
function getBaseCoverage(features, currentRefSeq, baseColors) {
    var minBin = null;
    var maxBin = null;

    var allBins = [];

    // Populate BaseBins
    for (var fi = 0; fi < features.length; ++fi) {
        var f = features[fi];
        if (f.groups && f.groups.length > 0) {
            // Don't downsample complex features
            return features;
        }
        var processedSeq = alignSeqUsingCigar(f.seq, f.quals, f.cigar);
        var seq = processedSeq.seq;
        var quals = processedSeq.quals;
        var strand = f.orientation;
        var minForFeature = f.min || 0;
        var maxForFeature = f.max || 0;
        var ind = 0;

        for (var b = minForFeature; b <= maxForFeature; ++b) {
            var bm = allBins[b];
            if (!bm) {
                bm = new BaseBin(b);
                allBins[b] = bm;
            }
            var base = seq.charAt(ind);
            var qual = quals.charCodeAt(ind) - 33; // Generate numeric qual score
            bm.recordBase(base, qual, strand);
            ind++;
        }

        if (!minBin) minBin = minForFeature;else minBin = Math.min(minBin, minForFeature);
        if (!maxBin) maxBin = maxForFeature;else maxBin = Math.max(maxBin, maxForFeature);
    }

    // Generate coverage features
    var refSeq = getRefSeq(currentRefSeq, minBin, maxBin);
    var baseFeatures = [];
    var ind = 0;
    for (var b = minBin; b <= maxBin; ++b) {
        var bm = allBins[b];
        if (bm) {
            var f = new DASFeature();
            f.segment = features[0].segment;
            f.min = bm.pos();
            f.max = f.min;
            f.notes = [];
            f.notes = f.notes.concat(bm.infoList());
            f.type = 'base-coverage';
            f.suppressScore = true;
            if (refSeq) {
                var refBase = refSeq.charAt(ind);
                var refString = 'Ref=' + refBase;
                f.notes.unshift(refString);
                var baseScoreList = bm.baseScoreList(refBase, 0.2);
                // TODO: shift 0.2 threshold to a config parameter
                for (var i = 0; i < baseScoreList.length; i++) {
                    var base = baseScoreList[i].base;
                    var score = baseScoreList[i].score;
                    var fBase = shallowCopy(f);
                    fBase.score = score;
                    // Color by baseColor when mismatch occurs
                    // otherwise, BoxGlyph to COLOR1 in style
                    if (baseScoreList.length > 1 || base != refBase) fBase.itemRgb = baseColors[base];

                    baseFeatures.push(fBase);
                }
            } else {
                // No refSeq, only show coverage height.
                baseFeatures.push(f);
            }
        }
        ind++;
    }
    return baseFeatures;
}

if (typeof module !== 'undefined') {
    module.exports = {
        downsample: downsample,
        getBaseCoverage: getBaseCoverage
    };
}

},{"./cigar":8,"./das":10,"./utils":55}],34:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// search.js general binary data support
//

"use strict";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;

    var connectTrix = require('./trix').connectTrix;
}

var REGION_PATTERN = /^([\d+,\w,\.,\_,\-]+)[\s:]+([0-9,\.]+?)([KkMmGg])?((-|\.\.|\s)+([0-9,\.]+)([KkMmGg])?)?$/;

function parseLocCardinal(n, m) {
    var i = parseFloat(n.replace(/,/g, ''));
    if (m === 'k' || m === 'K') {
        return i * 1000 | 0;
    } else if (m == 'm' || m === 'M') {
        return i * 1000000 | 0;
    } else {
        return i | 0;
    }
}

Browser.prototype.search = function (g, statusCallback, opts) {
    var thisB = this;
    opts = opts || {};
    var srPadding = opts.padding || this.defaultSearchRegionPadding;

    var m = REGION_PATTERN.exec(g);

    if (m) {
        var chr = m[1],
            start,
            end;
        if (m[6]) {
            start = parseLocCardinal(m[2], m[3]);
            end = parseLocCardinal(m[6], m[7]);
        } else {
            var width = this.viewEnd - this.viewStart + 1;
            start = parseLocCardinal(m[2], m[3]) - width / 2 | 0;
            end = start + width - 1;
        }
        this.setLocation(chr, start, end, statusCallback);
    } else {
        if (!g || g.length == 0) {
            return false;
        }

        var searchCount = 0;
        var foundLatch = false;

        var searchCallback = function searchCallback(found, err) {
            --searchCount;
            if (err) {
                return statusCallback(err);
            }

            if (!found) found = [];
            var min = 500000000,
                max = -100000000;
            var nchr = null;
            for (var fi = 0; fi < found.length; ++fi) {
                var f = found[fi];

                if (nchr == null) {
                    nchr = f.segment;
                }
                min = Math.min(min, f.min);
                max = Math.max(max, f.max);
            }

            if (!nchr) {
                if (searchCount == 0 && !foundLatch) return statusCallback("no match for '" + g + "'");
            } else {
                foundLatch = true;
                thisB.highlightRegion(nchr, min, max);

                var mid = (max + min) / 2 | 0;
                var padding = Math.max(srPadding, 0.3 * (max - min + 1) | 0);
                thisB.setLocation(nchr, min - padding, max + padding, statusCallback);
            }
        };

        var doTrixSearch = function doTrixSearch(tier, trix) {
            trix.lookup(g, function (result, status) {
                if (result == null || result.length < 2) {
                    return tier.featureSource.search(g, searchCallback);
                } else {
                    var hit = result[1].split(',')[0];
                    return tier.featureSource.search(hit, searchCallback);
                }
            });
        };

        if (this.searchEndpoint) {
            searchCount = 1;
            return this.doDasSearch(thisB.searchEndpoint, g, searchCallback);
        }

        var searchSources = [].concat(_toConsumableArray(this.searchOnlySourceHolders || []), _toConsumableArray(this.tiers));

        for (var ti = 0; ti < searchSources.length; ++ti) {
            (function (tier) {
                if (thisB.sourceAdapterIsCapable(tier.featureSource, 'search')) {
                    if (tier.dasSource.trixURI) {
                        ++searchCount;
                        if (tier.trix) {
                            doTrixSearch(tier, tier.trix);
                        } else {
                            var ix = new URLFetchable(tier.dasSource.trixURI, { credentials: tier.dasSource.credentials,
                                resolver: tier.dasSource.resolver });

                            var ixx = new URLFetchable(tier.dasSource.trixxURI || tier.dasSource.trixURI + 'x', { credentials: tier.dasSource.credentials,
                                resolver: tier.dasSource.resolver });

                            connectTrix(ix, ixx, function (trix) {
                                tier.trix = trix;
                                doTrixSearch(tier, trix);
                            });
                        }
                    } else {
                        ++searchCount;
                        tier.featureSource.search(g, searchCallback);
                    }
                } else if (tier.dasSource.provides_search) {
                    ++searchCount;
                    thisB.doDasSearch(tier.dasSource, g, searchCallback);
                }
            })(searchSources[ti]);
        }
    }
};

Browser.prototype.doDasSearch = function (source, g, searchCallback) {
    var thisB = this;
    source.features(null, { group: g, type: 'transcript' }, function (found) {
        if (!found) found = [];
        var min = 500000000,
            max = -100000000;
        var nchr = null;

        var found2 = [];
        for (var fi = 0; fi < found.length; ++fi) {
            var f = found[fi];

            if (f.label.toLowerCase() != g.toLowerCase()) {
                // ...because Dazzle can return spurious overlapping features.
                continue;
            }
            found2.push(f);
        }

        return searchCallback(found2);
    }, false);
};

},{"./bin":4,"./cbrowser":6,"./trix":53}],35:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2012
//
// sequence-draw.js: renderers for sequence-related data
//

"use strict";

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var formatLongInt = utils.formatLongInt;
    var makeElementNS = utils.makeElementNS;

    var svgu = require('./svg-utils');
    var NS_SVG = svgu.NS_SVG;
    var NS_XLINK = svgu.NS_XLINK;
    var SVGPath = svgu.SVGPath;

    var nf = require('./numformats');
    var formatLongInt = nf.formatLongInt;
}

var MIN_TILE = 100;
var rulerTileColors = ['black', 'white'];

var steps = [1, 2, 5];

var NS_SVG = 'http://www.w3.org/2000/svg';

function tileSizeForScale(scale, min) {
    if (!min) {
        min = MIN_TILE;
    }

    function ts(p) {
        return steps[p % steps.length] * Math.pow(10, p / steps.length | 0);
    }
    var pow = steps.length;
    while (scale * ts(pow) < min) {
        ++pow;
    }
    return ts(pow);
}

function drawSeqTier(tier, seq) {
    var gc = tier.viewport.getContext('2d');
    var retina = tier.browser.retina && window.devicePixelRatio > 1;
    var desiredWidth = tier.browser.featurePanelWidth + 2000;
    if (retina) {
        desiredWidth *= 2;
    }
    var fpw = tier.viewport.width | 0; // this.browser.featurePanelWidth;
    if (fpw < desiredWidth - 50) {
        tier.viewport.width = fpw = desiredWidth;
    }

    var height = 50;
    if (seq && seq.seq) {
        height += 25;
    }

    var canvasHeight = height;
    if (retina) canvasHeight *= 2;

    tier.viewport.height = canvasHeight;
    tier.viewport.style.height = '' + height + 'px';
    tier.viewport.style.width = retina ? '' + fpw / 2 + 'px' : '' + fpw + 'px';
    tier.layoutHeight = height;
    tier.updateHeight();

    if (tier.background) {
        gc.fillStyle = tier.background;
        gc.fillRect(0, 0, fpw, tier.viewport.height);
    }
    if (retina) {
        gc.scale(2, 2);
    }

    gc.translate(1000, 0);
    drawSeqTierGC(tier, seq, gc);
    tier.norigin = tier.browser.viewStart;
    tier.viewportHolder.style.left = '-1000px';
}

function drawSeqTierGC(tier, seq, gc) {
    var scale = tier.browser.scale,
        knownStart = tier.browser.viewStart - 1000 / scale | 0,
        knownEnd = tier.browser.viewEnd + 2000 / scale,
        currentSeqMax = tier.browser.currentSeqMax;

    var seqTierMax = knownEnd;
    if (currentSeqMax > 0 && currentSeqMax < knownEnd) {
        seqTierMax = currentSeqMax;
    }
    var tile = tileSizeForScale(scale);
    var pos = Math.max(0, (knownStart / tile | 0) * tile);

    var origin = tier.browser.viewStart;

    while (pos <= seqTierMax) {
        gc.fillStyle = pos / tile % 2 == 0 ? 'white' : 'black';
        gc.strokeStyle = 'black';
        gc.fillRect((pos - origin) * scale, 8, tile * scale, 3);
        gc.strokeRect((pos - origin) * scale, 8, tile * scale, 3);

        gc.fillStyle = 'black';
        gc.fillText(formatLongInt(pos), (pos - origin) * scale, 22);

        pos += tile;
    }

    if (seq && seq.seq) {
        for (var p = knownStart; p <= knownEnd; ++p) {
            if (p >= seq.start && p <= seq.end) {
                var base = seq.seq.substr(p - seq.start, 1).toUpperCase();
                var color = tier.browser.baseColors[base];
                if (!color) {
                    color = 'gray';
                }

                gc.fillStyle = color;

                if (scale >= 8) {
                    var w = gc.measureText(base).width;
                    // console.log(scale-w);
                    gc.fillText(base, (p - origin) * scale + (scale - w) * 0.5, 52);
                } else {
                    gc.fillRect((p - origin) * scale, 42, scale, 12);
                }
            }
        }
    }
}

function svgSeqTier(tier, seq) {
    var scale = tier.browser.scale,
        knownStart = tier.browser.viewStart - 1000 / scale | 0,
        knownEnd = tier.browser.viewEnd + 2000 / scale,
        currentSeqMax = tier.browser.currentSeqMax;

    var fpw = tier.viewport.width | 0;

    var seqTierMax = knownEnd;
    if (currentSeqMax > 0 && currentSeqMax < knownEnd) {
        seqTierMax = currentSeqMax;
    }
    var tile = tileSizeForScale(scale);
    var pos = Math.max(0, (knownStart / tile | 0) * tile);

    var origin = tier.browser.viewStart;

    var g = makeElementNS(NS_SVG, 'g', [], { fontSize: '8pt' });
    while (pos <= seqTierMax) {
        g.appendChild(makeElementNS(NS_SVG, 'rect', null, { x: (pos - origin) * scale,
            y: 8,
            width: tile * scale,
            height: 3,
            fill: pos / tile % 2 == 0 ? 'white' : 'black',
            stroke: 'black' }));

        g.appendChild(makeElementNS(NS_SVG, 'text', formatLongInt(pos), { x: (pos - origin) * scale,
            y: 28,
            fill: 'black', stroke: 'none' }));

        pos += tile;
    }

    if (seq && seq.seq) {
        for (var p = knownStart; p <= knownEnd; ++p) {
            if (p >= seq.start && p <= seq.end) {
                var base = seq.seq.substr(p - seq.start, 1).toUpperCase();
                var color = tier.browser.baseColors[base];
                if (!color) {
                    color = 'gray';
                }

                if (scale >= 8) {
                    g.appendChild(makeElementNS(NS_SVG, 'text', base, {
                        x: (0.5 + p - origin) * scale,
                        y: 52,
                        textAnchor: 'middle',
                        fill: color }));
                } else {
                    g.appendChild(makeElementNS(NS_SVG, 'rect', null, {
                        x: (p - origin) * scale,
                        y: 42,
                        width: scale,
                        height: 12,
                        fill: color }));
                }
            }
        }
    }

    return g;
}

if (typeof module !== 'undefined') {
    module.exports = {
        drawSeqTier: drawSeqTier,
        drawSeqTierGC: drawSeqTierGC,
        svgSeqTier: svgSeqTier
    };
}

},{"./numformats":29,"./svg-utils":44,"./utils":55}],36:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// session.js
//

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (typeof require != 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var sc = require('./sourcecompare');
    var sourceDataURI = sc.sourceDataURI;
    var sourcesAreEqual = sc.sourcesAreEqual;

    var VERSION = require('./version');

    var utils = require('./utils');
    var miniJSONify = utils.miniJSONify;

    var sha1 = require('./sha1');
    var hex_sha1 = sha1.hex_sha1;
}

Browser.prototype.nukeStatus = function () {
    delete localStorage['dalliance.' + this.cookieKey + '.view-chr'];
    delete localStorage['dalliance.' + this.cookieKey + '.view-start'];
    delete localStorage['dalliance.' + this.cookieKey + '.view-end'];
    delete localStorage['dalliance.' + this.cookieKey + '.current-seq-length'];
    delete localStorage['dalliance.' + this.cookieKey + '.showing-alt-zoom'];
    delete localStorage['dalliance.' + this.cookieKey + '.saved-zoom'];

    delete localStorage['dalliance.' + this.cookieKey + '.sources'];
    delete localStorage['dalliance.' + this.cookieKey + '.hubs'];
    delete localStorage['dalliance.' + this.cookieKey + '.version'];

    delete localStorage['dalliance.' + this.cookieKey + '.reverse-scrolling'];
    delete localStorage['dalliance.' + this.cookieKey + '.reverse-key-scrolling'];
    delete localStorage['dalliance.' + this.cookieKey + '.ruler-location'];
};

Browser.prototype.storeStatus = function () {
    this.storeViewStatus();
    this.storeTierStatus();
};

Browser.prototype.storeViewStatus = function () {
    if (!this.cookieKey || this.noPersist || this.noPersistView) {
        return;
    }

    localStorage['dalliance.' + this.cookieKey + '.view-chr'] = this.chr;
    localStorage['dalliance.' + this.cookieKey + '.view-start'] = this.viewStart | 0;
    localStorage['dalliance.' + this.cookieKey + '.view-end'] = this.viewEnd | 0;
    localStorage['dalliance.' + this.cookieKey + '.showing-alt-zoom'] = '' + this.isSnapZooming;
    localStorage['dalliance.' + this.cookieKey + '.saved-zoom'] = this.savedZoom;
    if (this.currentSeqMax) {
        localStorage['dalliance.' + this.cookieKey + '.current-seq-length'] = this.currentSeqMax;
    }
};

Browser.prototype.storeTierStatus = function () {
    if (!this.cookieKey || this.noPersist) {
        return;
    }

    var currentSourceList = [];
    for (var t = 0; t < this.tiers.length; ++t) {
        var tt = this.tiers[t];
        var ts = tt.dasSource;
        if (!ts.noPersist) {
            currentSourceList.push({ source: tt.dasSource, config: tt.config || {} });
        }
    }
    localStorage['dalliance.' + this.cookieKey + '.sources'] = JSON.stringify(currentSourceList);

    var coveredHubURLs = {};
    var currentHubList = [];
    for (var hi = 0; hi < this.hubObjects.length; ++hi) {
        var tdb = this.hubObjects[hi];
        var hc = { url: tdb.hub.url, genome: tdb.genome };
        if (tdb.credentials) hc.credentials = tdb.credentials;
        if (tdb.mapping) hc.mapping = tdb.mapping;
        coveredHubURLs[hc.url] = true;
        currentHubList.push(hc);
    }

    // Needed to handle hubs that failed to connect, or hubs that haven't
    // connected yet when we're called soon after startup.
    for (var hi = 0; hi < this.hubs.length; ++hi) {
        var hc = this.hubs[hi];
        if (typeof hc === 'string') hc = { url: hc };
        if (!coveredHubURLs[hc.url]) currentHubList.push(hc);
    }

    localStorage['dalliance.' + this.cookieKey + '.hubs'] = JSON.stringify(currentHubList);

    localStorage['dalliance.' + this.cookieKey + '.reverse-scrolling'] = this.reverseScrolling;
    localStorage['dalliance.' + this.cookieKey + '.reverse-key-scrolling'] = this.reverseKeyScrolling;
    localStorage['dalliance.' + this.cookieKey + '.single-base-highlight'] = this.singleBaseHighlight;
    localStorage['dalliance.' + this.cookieKey + '.ruler-location'] = this.rulerLocation;

    localStorage['dalliance.' + this.cookieKey + '.export-ruler'] = this.exportRuler;
    localStorage['dalliance.' + this.cookieKey + '.export-highlights'] = this.exportHighlights;

    localStorage['dalliance.' + this.cookieKey + '.version'] = VERSION.CONFIG;
};

Browser.prototype.restoreStatus = function () {
    if (this.noPersist) return;

    var storedConfigVersion = localStorage['dalliance.' + this.cookieKey + '.version'];
    if (storedConfigVersion) {
        storedConfigVersion = storedConfigVersion | 0;
    } else {
        storedConfigVersion = -100;
    }
    if (VERSION.CONFIG != storedConfigVersion) {
        return;
    }

    var storedConfigHash = localStorage['dalliance.' + this.cookieKey + '.configHash'] || '';
    var pageConfigHash = hex_sha1(miniJSONify({
        sources: this.sources,
        hubs: this.hubs,
        rulerLocation: this.rulerLocation
    }));
    if (pageConfigHash != storedConfigHash) {
        localStorage['dalliance.' + this.cookieKey + '.configHash'] = pageConfigHash;
        return;
    }

    var defaultSourcesByURI = {};
    for (var si = 0; si < this.sources.length; ++si) {
        var source = this.sources[si];
        if (!source) continue;

        var uri = sourceDataURI(source);
        var ul = defaultSourcesByURI[uri];
        if (!ul) defaultSourcesByURI[uri] = ul = [];
        ul.push(source);
    }

    if (!this.noPersistView) {
        var qChr = localStorage['dalliance.' + this.cookieKey + '.view-chr'];
        var qMin = localStorage['dalliance.' + this.cookieKey + '.view-start'] | 0;
        var qMax = localStorage['dalliance.' + this.cookieKey + '.view-end'] | 0;
        if (qChr && qMin && qMax) {
            this.chr = qChr;
            this.viewStart = qMin;
            this.viewEnd = qMax;

            var csm = localStorage['dalliance.' + this.cookieKey + '.current-seq-length'];
            if (csm) {
                this.currentSeqMax = csm | 0;
            }

            this.isSnapZooming = localStorage['dalliance.' + this.cookieKey + '.showing-alt-zoom'] == 'true';

            var sz = parseFloat(localStorage['dalliance.' + this.cookieKey + '.saved-zoom']);
            if (typeof sz === 'number' && !isNaN(sz)) {
                this.savedZoom = sz;
            }
        }
    }

    var rs = localStorage['dalliance.' + this.cookieKey + '.reverse-scrolling'];
    this.reverseScrolling = rs && rs == 'true';
    var rks = localStorage['dalliance.' + this.cookieKey + '.reverse-key-scrolling'];
    this.reverseKeyScrolling = rks && rks == 'true';
    var sbh = localStorage['dalliance.' + this.cookieKey + '.single-base-highlight'];
    this.singleBaseHighlight = sbh && sbh == 'true';

    var rl = localStorage['dalliance.' + this.cookieKey + '.ruler-location'];
    if (rl) this.rulerLocation = rl;

    var x = localStorage['dalliance.' + this.cookieKey + '.export-ruler'];
    if (x) this.exportRuler = x === 'true';
    var x = localStorage['dalliance.' + this.cookieKey + '.export-highlights'];
    if (x) this.exportHighlights = x === 'true';

    var sourceStr = localStorage['dalliance.' + this.cookieKey + '.sources'];
    if (sourceStr) {
        var storedSources = JSON.parse(sourceStr);
        this.sources = [];
        this.restoredConfigs = [];
        for (var si = 0; si < storedSources.length; ++si) {
            var source = this.sources[si] = storedSources[si].source;
            this.restoredConfigs[si] = storedSources[si].config;
            var uri = sourceDataURI(source);
            var ul = defaultSourcesByURI[uri] || [];
            for (var osi = 0; osi < ul.length; ++osi) {
                var oldSource = ul[osi];
                if (sourcesAreEqual(source, oldSource)) {
                    for (var k in oldSource) {
                        if (oldSource.hasOwnProperty(k) && (typeof oldSource[k] === 'function' || oldSource[k] instanceof Blob)) {
                            source[k] = oldSource[k];
                        }
                    }

                    if (_typeof(oldSource.renderer) === 'object' && oldSource.renderer.renderTier) {
                        source.renderer = oldSource.renderer;
                    }
                }
            }
        }
    }

    var hubStr = localStorage['dalliance.' + this.cookieKey + '.hubs'];
    if (hubStr) {
        this.hubs = JSON.parse(hubStr);
    }

    return true;
};

Browser.prototype.reset = function () {
    for (var i = this.tiers.length - 1; i >= 0; --i) {
        this.removeTier({ index: i }, true);
    }
    for (var i = 0; i < this.defaultSources.length; ++i) {
        var s = this.defaultSources[i];
        if (!s.disabled) this.addTier(this.defaultSources[i]);
    }

    this.highlights.splice(0, this.highlights.length);

    this.setLocation(this.defaultChr, this.defaultStart, this.defaultEnd);
};

},{"./cbrowser":6,"./sha1":37,"./sourcecompare":39,"./utils":55,"./version":57}],37:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS 180-1
 * Version 2.2 Copyright Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

"use strict";

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */

var hexcase = 0; /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad = ""; /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s) {
  return rstr2hex(rstr_sha1(str2rstr_utf8(s)));
}
function b64_sha1(s) {
  return rstr2b64(rstr_sha1(str2rstr_utf8(s)));
}
function any_sha1(s, e) {
  return rstr2any(rstr_sha1(str2rstr_utf8(s)), e);
}
function hex_hmac_sha1(k, d) {
  return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)));
}
function b64_hmac_sha1(k, d) {
  return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)));
}
function any_hmac_sha1(k, d, e) {
  return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e);
}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test() {
  return hex_sha1("abc").toLowerCase() == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA1 of a raw string
 */
function rstr_sha1(s) {
  return binb2rstr(binb_sha1(rstr2binb(s), s.length * 8));
}

/*
 * Calculate the HMAC-SHA1 of a key and some data (raw strings)
 */
function rstr_hmac_sha1(key, data) {
  var bkey = rstr2binb(key);
  if (bkey.length > 16) bkey = binb_sha1(bkey, key.length * 8);

  var ipad = Array(16),
      opad = Array(16);
  for (var i = 0; i < 16; i++) {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
  return binb2rstr(binb_sha1(opad.concat(hash), 512 + 160));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input) {
  // try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for (var i = 0; i < input.length; i++) {
    x = input.charCodeAt(i);
    output += hex_tab.charAt(x >>> 4 & 0x0F) + hex_tab.charAt(x & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input) {
  // try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for (var i = 0; i < len; i += 3) {
    var triplet = input.charCodeAt(i) << 16 | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) | (i + 2 < len ? input.charCodeAt(i + 2) : 0);
    for (var j = 0; j < 4; j++) {
      if (i * 8 + j * 6 > input.length * 8) output += b64pad;else output += tab.charAt(triplet >>> 6 * (3 - j) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding) {
  var divisor = encoding.length;
  var remainders = Array();
  var i, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for (i = 0; i < dividend.length; i++) {
    dividend[i] = input.charCodeAt(i * 2) << 8 | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. We stop when the dividend is zero.
   * All remainders are stored for later use.
   */
  while (dividend.length > 0) {
    quotient = Array();
    x = 0;
    for (i = 0; i < dividend.length; i++) {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if (quotient.length > 0 || q > 0) quotient[quotient.length] = q;
    }
    remainders[remainders.length] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for (i = remainders.length - 1; i >= 0; i--) {
    output += encoding.charAt(remainders[i]);
  } /* Append leading zero equivalents */
  var full_length = Math.ceil(input.length * 8 / (Math.log(encoding.length) / Math.log(2)));
  for (i = output.length; i < full_length; i++) {
    output = encoding[0] + output;
  }return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input) {
  var output = "";
  var i = -1;
  var x, y;

  while (++i < input.length) {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if (x <= 0x7F) output += String.fromCharCode(x);else if (x <= 0x7FF) output += String.fromCharCode(0xC0 | x >>> 6 & 0x1F, 0x80 | x & 0x3F);else if (x <= 0xFFFF) output += String.fromCharCode(0xE0 | x >>> 12 & 0x0F, 0x80 | x >>> 6 & 0x3F, 0x80 | x & 0x3F);else if (x <= 0x1FFFFF) output += String.fromCharCode(0xF0 | x >>> 18 & 0x07, 0x80 | x >>> 12 & 0x3F, 0x80 | x >>> 6 & 0x3F, 0x80 | x & 0x3F);
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input) {
  var output = "";
  for (var i = 0; i < input.length; i++) {
    output += String.fromCharCode(input.charCodeAt(i) & 0xFF, input.charCodeAt(i) >>> 8 & 0xFF);
  }return output;
}

function str2rstr_utf16be(input) {
  var output = "";
  for (var i = 0; i < input.length; i++) {
    output += String.fromCharCode(input.charCodeAt(i) >>> 8 & 0xFF, input.charCodeAt(i) & 0xFF);
  }return output;
}

/*
 * Convert a raw string to an array of big-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binb(input) {
  var output = Array(input.length >> 2);
  for (var i = 0; i < output.length; i++) {
    output[i] = 0;
  }for (var i = 0; i < input.length * 8; i += 8) {
    output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << 24 - i % 32;
  }return output;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2rstr(input) {
  var output = "";
  for (var i = 0; i < input.length * 32; i += 8) {
    output += String.fromCharCode(input[i >> 5] >>> 24 - i % 32 & 0xFF);
  }return output;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function binb_sha1(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << 24 - len % 32;
  x[(len + 64 >> 9 << 4) + 15] = len;

  var w = Array(80);
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  var e = -1009589776;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for (var j = 0; j < 80; j++) {
      if (j < 16) w[j] = x[i + j];else w[j] = bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
      var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = bit_rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);
}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d) {
  if (t < 20) return b & c | ~b & d;
  if (t < 40) return b ^ c ^ d;
  if (t < 60) return b & c | b & d | c & d;
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t) {
  return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xFFFF;
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}

if (typeof module !== 'undefined') {
  module.exports = {
    b64_sha1: b64_sha1,
    hex_sha1: hex_sha1
  };
}

},{}],38:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// sourceadapters.js
//

"use strict";

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var tier = require('./tier');
    var DasTier = tier.DasTier;

    var utils = require('./utils');
    var Awaited = utils.Awaited;
    var arrayIndexOf = utils.arrayIndexOf;
    var shallowCopy = utils.shallowCopy;
    var resolveUrlToPage = utils.resolveUrlToPage;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASSource = das.DASSource;
    var DASSegment = das.DASSegment;
    var DASFeature = das.DASFeature;
    var DASSequence = das.DASSequence;
    var DASLink = das.DASLink;

    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;
    var BlobFetchable = bin.BlobFetchable;

    var twoBit = require('./twoBit');
    var makeTwoBit = twoBit.makeTwoBit;

    var bbi = require('./bigwig');
    var makeBwg = bbi.makeBwg;

    var bam = require('./bam');
    var makeBam = bam.makeBam;
    var BamFlags = bam.BamFlags;

    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;

    var parseCigar = require('./cigar').parseCigar;

    var OverlayFeatureSource = require('./overlay').OverlayFeatureSource;

    var JBrowseStore = require('./jbjson').JBrowseStore;

    var Chainset = require('./chainset').Chainset;

    var style = require('./style');
    var StyleFilterSet = style.StyleFilterSet;

    var EncodeFetchable = require('./encode').EncodeFetchable;
}

var __dalliance_sourceAdapterFactories = {};

function dalliance_registerSourceAdapterFactory(type, factory) {
    __dalliance_sourceAdapterFactories[type] = factory;
}

var __dalliance_parserFactories = {};

function dalliance_registerParserFactory(type, factory) {
    __dalliance_parserFactories[type] = factory;
}

function dalliance_makeParser(type) {
    if (__dalliance_parserFactories[type]) {
        return __dalliance_parserFactories[type](type);
    }
}

DasTier.prototype.initSources = function () {
    var thisTier = this;

    var sources = this.browser.createSources(this.dasSource);
    this.featureSource = sources.features || new DummyFeatureSource();
    this.sequenceSource = sources.sequence;

    if (this.featureSource && this.featureSource.addChangeListener) {
        this.featureSource.addChangeListener(function () {
            thisTier.browser.refreshTier(thisTier);
        });
    }
};

Browser.prototype.createSources = function (config) {
    var sources = this.sourceCache.get(config);
    if (sources) return sources;

    var fs, ss;

    if (config.tier_type == 'sequence' || config.twoBitURI || config.twoBitBlob) {
        if (config.twoBitURI || config.twoBitBlob) {
            ss = new TwoBitSequenceSource(config);
        } else if (config.ensemblURI) {
            ss = new EnsemblSequenceSource(config);
        } else {
            ss = new DASSequenceSource(config);
        }
    } else if (config.tier_type && __dalliance_sourceAdapterFactories[config.tier_type]) {
        var saf = __dalliance_sourceAdapterFactories[config.tier_type];
        var ns = saf(config);
        fs = ns.features;
        ss = ns.sequence;
    } else if (config.bwgURI || config.bwgBlob) {
        var worker = this.getWorker();
        if (worker) fs = new RemoteBWGFeatureSource(config, worker, this);else fs = new BWGFeatureSource(config);
    } else if (config.bamURI || config.bamBlob) {
        var worker = this.getWorker();
        if (worker) fs = new RemoteBAMFeatureSource(config, worker, this);else fs = new BAMFeatureSource(config);
    } else if (config.jbURI) {
        fs = new JBrowseFeatureSource(config);
    } else if (config.uri || config.features_uri) {
        fs = new DASFeatureSource(config);
    }

    if (config.overlay) {
        var sources = [];
        if (fs) sources.push(new CachingFeatureSource(fs));

        for (var oi = 0; oi < config.overlay.length; ++oi) {
            var cs = this.createSources(config.overlay[oi]);
            if (cs && cs.features) sources.push(cs.features);
        }
        fs = new OverlayFeatureSource(sources, config);
    }

    if (config.sequenceAliases) {
        fs = new MappedFeatureSource(fs, new Chainset({ type: 'alias', sequenceAliases: config.sequenceAliases }));
    }

    if (config.mapping) {
        fs = new MappedFeatureSource(fs, this.chains[config.mapping]);
    }

    if (config.name && fs && !fs.name) {
        fs.name = config.name;
    }

    if (typeof fs !== 'undefined' && fs !== null) {
        fs = new CachingFeatureSource(fs);
    }

    if (typeof fs !== 'undefined' && fs !== null || typeof ss !== 'undefined' && ss != null) {
        sources = {
            features: fs,
            sequence: ss
        };
        this.sourceCache.put(config, sources);
    }

    return sources;
};

DasTier.prototype.fetchStylesheet = function (cb) {
    var ssSource;
    // Somewhat ugly workaround for the special case of DAS sources...
    if (this.dasSource.stylesheet_uri || !this.dasSource.tier_type && !this.dasSource.bwgURI && !this.dasSource.bwgBlob && !this.dasSource.bamURI && !this.dasSource.bamBlob && !this.dasSource.twoBitURI && !this.dasSource.twoBitBlob && !this.dasSource.jbURI && !this.dasSource.overlay) {
        ssSource = new DASFeatureSource(this.dasSource);
    } else {
        ssSource = this.getSource();
    }
    ssSource.getStyleSheet(cb);
};

var __cfs_id_seed = 0;

function CachingFeatureSource(source) {
    var thisB = this;

    this.source = source;
    this.cfsid = 'cfs' + ++__cfs_id_seed;
    if (source.name) {
        this.name = source.name;
    }
    if (source.addChangeListener) {
        source.addChangeListener(function () {
            thisB.cfsid = 'cfs' + ++__cfs_id_seed;
        });
    }
}

CachingFeatureSource.prototype.addReadinessListener = function (listener) {
    if (this.source.addReadinessListener) return this.source.addReadinessListener(listener);else listener(null);
};

CachingFeatureSource.prototype.removeReadinessListener = function (listener) {
    if (this.source.removeReadinessListener) return this.source.removeReadinessListener(listener);
};

CachingFeatureSource.prototype.search = function (query, callback) {
    if (this.source.search) return this.source.search(query, callback);
};

CachingFeatureSource.prototype.getDefaultFIPs = function (callback, tier) {
    if (this.source.getDefaultFIPs) return this.source.getDefaultFIPs(callback, tier);
};

CachingFeatureSource.prototype.getStyleSheet = function (callback) {
    this.source.getStyleSheet(callback);
};

CachingFeatureSource.prototype.getScales = function () {
    return this.source.getScales();
};

CachingFeatureSource.prototype.addActivityListener = function (l) {
    if (this.source.addActivityListener) {
        this.source.addActivityListener(l);
    }
};

CachingFeatureSource.prototype.removeActivityListener = function (l) {
    if (this.source.removeActivityListener) {
        this.source.removeActivityListener(l);
    }
};

CachingFeatureSource.prototype.addChangeListener = function (l) {
    if (this.source.addChangeListener) this.source.addChangeListener(l);
};

CachingFeatureSource.prototype.removeChangeListener = function (l) {
    if (this.source.removeChangeListener) this.source.removeChangeListener(l);
};

CachingFeatureSource.prototype.findNextFeature = function (chr, pos, dir, callback) {
    this.source.findNextFeature(chr, pos, dir, callback);
};

CachingFeatureSource.prototype.quantFindNextFeature = function (chr, pos, dir, threshold, callback) {
    this.source.quantFindNextFeature(chr, pos, dir, threshold, callback);
};

CachingFeatureSource.prototype.capabilities = function () {
    if (this.source.capabilities) {
        return this.source.capabilities();
    } else {
        return {};
    }
};

CachingFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback, styleFilters) {
    if (!pool) {
        throw Error('Fetch pool is null');
    }

    var self = this;
    var cacheKey = this.cfsid;

    var awaitedFeatures = pool.awaitedFeatures[cacheKey];
    if (awaitedFeatures && awaitedFeatures.started) {
        if (awaitedFeatures.styleFilters.doesNotContain(styleFilters)) {
            // console.log('Fetch already started with wrong parameters, skipping cache.');
            self.source.fetch(chr, min, max, scale, types, pool, callback, styleFilters);
            return;
        }
    } else if (awaitedFeatures) {
        awaitedFeatures.styleFilters.addAll(styleFilters);
    } else {
        awaitedFeatures = new Awaited();
        awaitedFeatures.styleFilters = styleFilters;
        pool.awaitedFeatures[cacheKey] = awaitedFeatures;

        pool.requestsIssued.then(function () {
            awaitedFeatures.started = true;
            self.source.fetch(chr, min, max, scale, awaitedFeatures.styleFilters.typeList(), pool, function (status, features, scale, coverage) {
                if (!awaitedFeatures.res) awaitedFeatures.provide({ status: status, features: features, scale: scale, coverage: coverage });
            }, awaitedFeatures.styleFilters);
        }).catch(function (err) {
            console.log(err);
        });
    }

    awaitedFeatures.await(function (af) {
        callback(af.status, af.features, af.scale, af.coverage);
    });
};

function FeatureSourceBase() {
    this.busy = 0;
    this.activityListeners = [];
    this.readinessListeners = [];
    this.readiness = null;
}

FeatureSourceBase.prototype.addReadinessListener = function (listener) {
    this.readinessListeners.push(listener);
    listener(this.readiness);
};

FeatureSourceBase.prototype.removeReadinessListener = function (listener) {
    var idx = arrayIndexOf(this.readinessListeners, listener);
    if (idx >= 0) {
        this.readinessListeners.splice(idx, 1);
    }
};

FeatureSourceBase.prototype.notifyReadiness = function () {
    for (var li = 0; li < this.readinessListeners.length; ++li) {
        try {
            this.readinessListeners[li](this.readiness);
        } catch (e) {
            console.log(e);
        }
    }
};

FeatureSourceBase.prototype.addActivityListener = function (listener) {
    this.activityListeners.push(listener);
};

FeatureSourceBase.prototype.removeActivityListener = function (listener) {
    var idx = arrayIndexOf(this.activityListeners, listener);
    if (idx >= 0) {
        this.activityListeners.splice(idx, 1);
    }
};

FeatureSourceBase.prototype.notifyActivity = function () {
    for (var li = 0; li < this.activityListeners.length; ++li) {
        try {
            this.activityListeners[li](this.busy);
        } catch (e) {
            console.log(e);
        }
    }
};

FeatureSourceBase.prototype.getScales = function () {
    return null;
};

FeatureSourceBase.prototype.fetch = function (chr, min, max, scale, types, pool, cnt) {
    return cnt(null, [], 1000000000);
};

FeatureSourceBase.prototype.getStyleSheet = function (callback) {
    var stylesheet = new DASStylesheet();
    var defStyle = new DASStyle();
    defStyle.glyph = 'BOX';
    defStyle.BGCOLOR = 'blue';
    defStyle.FGCOLOR = 'black';
    stylesheet.pushStyle({ type: 'default' }, null, defStyle);
    return callback(stylesheet);
};

function DASFeatureSource(dasSource) {
    this.dasSource = new DASSource(dasSource);
    this.busy = 0;
    this.activityListeners = [];
}

DASFeatureSource.prototype.addActivityListener = function (listener) {
    this.activityListeners.push(listener);
};

DASFeatureSource.prototype.removeActivityListener = function (listener) {
    var idx = arrayIndexOf(this.activityListeners, listener);
    if (idx >= 0) this.activityListeners.splice(idx, 1);
};

DASFeatureSource.prototype.notifyActivity = function () {
    for (var li = 0; li < this.activityListeners.length; ++li) {
        try {
            this.activityListeners[li](this.busy);
        } catch (e) {
            console.log(e);
        }
    }
};

DASFeatureSource.prototype.getStyleSheet = function (callback) {
    this.dasSource.stylesheet(function (stylesheet) {
        callback(stylesheet);
    }, function () {
        callback(null, "Couldn't fetch DAS stylesheet");
    });
};

DASFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback) {
    if (types && types.length === 0) {
        callback(null, [], scale);
        return;
    }

    if (!this.dasSource.uri && !this.dasSource.features_uri) {
        // FIXME should this be making an error callback???
        return;
    }

    if (this.dasSource.dasStaticFeatures && this.cachedStaticFeatures) {
        return callback(null, this.cachedStaticFeatures, this.cachedStaticScale);
    }

    var tryMaxBins = this.dasSource.maxbins !== false;
    var fops = {
        type: types
    };
    if (tryMaxBins) {
        fops.maxbins = 1 + ((max - min) / scale | 0);
    }

    var thisB = this;
    thisB.busy++;
    thisB.notifyActivity();

    this.dasSource.features(new DASSegment(chr, min, max), fops, function (features, status) {

        thisB.busy--;
        thisB.notifyActivity();

        var retScale = scale;
        if (!tryMaxBins) {
            retScale = 0.1;
        }
        if (!status && thisB.dasSource.dasStaticFeatures) {
            thisB.cachedStaticFeatures = features;
            thisB.cachedStaticScale = retScale;
        }
        callback(status, features, retScale);
    });
};

DASFeatureSource.prototype.findNextFeature = function (chr, pos, dir, callback) {
    if (this.dasSource.capabilities && arrayIndexOf(this.dasSource.capabilities, 'das1:adjacent-feature') >= 0) {
        var thisB = this;
        if (this.dasAdjLock) {
            return console.log('Already looking for a next feature, be patient!');
        }
        this.dasAdjLock = true;
        var fops = {
            adjacent: chr + ':' + (pos | 0) + ':' + (dir > 0 ? 'F' : 'B')
        };
        var types = thisTier.getDesiredTypes(thisTier.browser.scale);
        if (types) {
            fops.types = types;
        }
        thisTier.dasSource.features(null, fops, function (res) {
            thisB.dasAdjLock = false;
            if (res.length > 0 && res[0] !== null) {
                callback(res[0]);
            }
        });
    }
};

function DASSequenceSource(dasSource) {
    this.dasSource = new DASSource(dasSource);
    this.awaitedEntryPoints = new Awaited();

    var thisB = this;
    this.dasSource.entryPoints(function (ep) {
        thisB.awaitedEntryPoints.provide(ep);
    });
}

DASSequenceSource.prototype.fetch = function (chr, min, max, pool, callback) {
    this.dasSource.sequence(new DASSegment(chr, min, max), function (seqs) {
        if (seqs.length == 1) {
            return callback(null, seqs[0]);
        } else {
            return callback("Didn't get sequence");
        }
    });
};

DASSequenceSource.prototype.getSeqInfo = function (chr, cnt) {
    this.awaitedEntryPoints.await(function (ep) {
        for (var epi = 0; epi < ep.length; ++epi) {
            if (ep[epi].name == chr) {
                return cnt({ length: ep[epi].end });
            }
        }
        return cnt();
    });
};

function TwoBitSequenceSource(source) {
    var thisB = this;
    this.source = source;
    this.twoBit = new Awaited();
    var data;
    if (source.twoBitURI) {
        data = new URLFetchable(source.twoBitURI, { credentials: source.credentials, resolver: source.resolver });
    } else if (source.twoBitBlob) {
        data = new BlobFetchable(source.twoBitBlob);
    } else {
        throw Error("No twoBitURI or twoBitBlob parameter");
    }

    makeTwoBit(data, function (tb, error) {
        if (error) {
            console.log(error);
        } else {
            thisB.twoBit.provide(tb);
        }
    });
}

TwoBitSequenceSource.prototype.fetch = function (chr, min, max, pool, callback) {
    this.twoBit.await(function (tb) {
        tb.fetch(chr, min, max, function (seq, err) {
            if (err) {
                return callback(err, null);
            } else {
                var sequence = new DASSequence(chr, min, max, 'DNA', seq);
                return callback(null, sequence);
            }
        });
    });
};

TwoBitSequenceSource.prototype.getSeqInfo = function (chr, cnt) {
    this.twoBit.await(function (tb) {
        var seq = tb.getSeq(chr);
        if (seq) {
            tb.getSeq(chr).length(function (l) {
                cnt({ length: l });
            });
        } else {
            cnt();
        }
    });
};

function EnsemblSequenceSource(source) {
    this.source = source;
    // http://data.gramene.org/ensembl/info/assembly/triticum_aestivum/2B?content-type=application/json
    // http://data.gramene.org/ensembl/sequence/region/triticum_aestivum/2B:8001..18000:1?content-type=application/json
}

EnsemblSequenceSource.prototype.fetch = function (chr, min, max, pool, callback) {
    var url = this.source.ensemblURI + '/sequence/region/' + this.source.species + '/' + chr + ':' + min + '..' + max + ':1?content-type=application/json';
    var req = new XMLHttpRequest();
    req.onreadystatechange = function () {
        if (req.readyState == 4) {
            var jr;
            if (req.status >= 300) {
                var err = 'Error code ' + req.status;
                try {
                    jr = JSON.parse(req.response);
                    if (jr.error) {
                        err = jr.error;
                    }
                } finally {
                    callback(err, null);
                }
            } else {
                jr = JSON.parse(req.response);
                var sequence = new DASSequence(chr, min, max, 'DNA', jr.seq);
                return callback(null, sequence);
            }
        }
    };
    req.open('GET', url, true);
    req.responseType = 'text';
    req.send();
};

EnsemblSequenceSource.prototype.getSeqInfo = function (chr, cnt) {
    var url = this.source.ensemblURI + '/info/assembly/' + this.source.species + '/' + chr + '?content-type=application/json';
    var req = new XMLHttpRequest();
    req.onreadystatechange = function () {
        if (req.readyState == 4) {
            if (req.status >= 300) {
                cnt();
            } else {
                var jr = JSON.parse(req.response);
                cnt(jr);
            }
        }
    };
    req.open('GET', url, true);
    req.responseType = 'text';
    req.send();
};

DASFeatureSource.prototype.getScales = function () {
    return [];
};

var bwg_preflights = {};

function BWGFeatureSource(bwgSource) {
    FeatureSourceBase.call(this);

    var thisB = this;
    this.readiness = 'Connecting';
    this.bwgSource = this.opts = bwgSource;
    thisB.bwgHolder = new Awaited();

    if (this.opts.preflight) {
        var pfs = bwg_preflights[this.opts.preflight];
        if (!pfs) {
            pfs = new Awaited();
            bwg_preflights[this.opts.preflight] = pfs;

            var req = new XMLHttpRequest();
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (req.status == 200) {
                        pfs.provide('success');
                    } else {
                        pfs.provide('failure');
                    }
                }
            };
            req.open('get', this.opts.preflight + '?' + hex_sha1('salt' + Date.now()), true); // Instead, ensure we always preflight a unique URI.
            if (this.opts.credentials) {
                req.withCredentials = true;
            }
            req.send();
        }
        pfs.await(function (status) {
            if (status === 'success') {
                thisB.init();
            }
        });
    } else {
        thisB.init();
    }
}

BWGFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

BWGFeatureSource.prototype.init = function () {
    var thisB = this;
    var arg;

    var uri = this.bwgSource.uri || this.bwgSource.bwgURI;
    if (uri) {
        if (this.bwgSource.transport === 'encode') {
            arg = new EncodeFetchable(uri, { credentials: this.opts.credentials });
        } else {
            arg = new URLFetchable(uri, { credentials: this.opts.credentials, resolver: this.opts.resolver });
        }
    } else {
        arg = new BlobFetchable(this.bwgSource.bwgBlob);
    }

    makeBwg(arg, function (bwg, err) {
        if (err) {
            thisB.error = err;
            thisB.readiness = null;
            thisB.notifyReadiness();
            thisB.bwgHolder.provide(null);
        } else {
            thisB.bwgHolder.provide(bwg);
            thisB.readiness = null;
            thisB.notifyReadiness();
            if (bwg.type == 'bigbed') {
                bwg.getExtraIndices(function (ei) {
                    thisB.extraIndices = ei;
                });
            }
        }
    });
};

BWGFeatureSource.prototype.capabilities = function () {
    var caps = { leap: true };
    if (this.bwgHolder.res && this.bwgHolder.res.type == 'bigwig') caps.quantLeap = true;
    if (this.extraIndices && this.extraIndices.length > 0) {
        caps.search = [];
        for (var eii = 0; eii < this.extraIndices.length; ++eii) {
            caps.search.push(this.extraIndices[eii].field);
        }
    }
    return caps;
};

BWGFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback) {
    var thisB = this;
    this.bwgHolder.await(function (bwg) {
        if (typeof bwg === 'undefined' || bwg === null) {
            return callback(thisB.error || "Can't access binary file", null, null);
        }

        var data;
        var wantDensity = !types || types.length === 0 || arrayIndexOf(types, 'density') >= 0;
        if (thisB.opts.clientBin) {
            wantDensity = false;
        }
        var scaleFactor = thisB.opts.scaleFactor || 1.0;
        if (bwg.type == 'bigwig' || wantDensity || typeof thisB.opts.forceReduction !== 'undefined') {
            var zoom = -1;
            for (var z = 0; z < bwg.zoomLevels.length; ++z) {
                if (bwg.zoomLevels[z].reduction <= scale * scaleFactor) {
                    zoom = z;
                } else {
                    break;
                }
            }
            if (typeof thisB.opts.forceReduction !== 'undefined') {
                zoom = thisB.opts.forceReduction;
            }

            if (zoom < 0) {
                data = bwg.getUnzoomedView();
            } else {
                data = bwg.getZoomedView(zoom);
            }
        } else {
            data = bwg.getUnzoomedView();
        }

        thisB.busy++;
        thisB.notifyActivity();
        data.readWigData(chr, min, max, function (features) {
            thisB.busy--;
            thisB.notifyActivity();

            var fs = 1000000000;
            if (bwg.type === 'bigwig') {
                var is = (max - min) / features.length / 2;
                if (is < fs) {
                    fs = is;
                }
            }
            if (thisB.opts.link) {
                for (var fi = 0; fi < features.length; ++fi) {
                    var f = features[fi];
                    if (f.label) {
                        f.links = [new DASLink('Link', thisB.opts.link.replace(/\$\$/, f.label))];
                    }
                }
            }
            callback(null, features, fs);
        });
    });
};

BWGFeatureSource.prototype.quantFindNextFeature = function (chr, pos, dir, threshold, callback) {
    // var beforeQFNF = Date.now()|0;
    var thisB = this;
    thisB.busy++;
    thisB.notifyActivity();
    this.bwgHolder.res.thresholdSearch(chr, pos, dir, threshold, function (a, b) {
        thisB.busy--;
        thisB.notifyActivity();
        // var afterQFNF = Date.now()|0;
        // console.log('QFNF took ' + (afterQFNF - beforeQFNF) + 'ms');
        return callback(a, b);
    });
};

BWGFeatureSource.prototype.findNextFeature = function (chr, pos, dir, callback) {
    var thisB = this;
    thisB.busy++;
    thisB.notifyActivity();
    this.bwgHolder.res.getUnzoomedView().getFirstAdjacent(chr, pos, dir, function (res) {
        thisB.busy--;
        thisB.notifyActivity();
        if (res.length > 0 && res[0] !== null) {
            callback(res[0]);
        }
    });
};

BWGFeatureSource.prototype.getScales = function () {
    var bwg = this.bwgHolder.res;
    if (bwg /* && bwg.type == 'bigwig' */) {
            var scales = [1]; // Can we be smarter about inferring baseline scale?
            for (var z = 0; z < bwg.zoomLevels.length; ++z) {
                scales.push(bwg.zoomLevels[z].reduction);
            }
            return scales;
        } else {
        return null;
    }
};

BWGFeatureSource.prototype.search = function (query, callback) {
    if (!this.extraIndices || this.extraIndices.length === 0) {
        return callback(null, 'No indices available');
    }

    var index = this.extraIndices[0];
    return index.lookup(query, callback);
};

BWGFeatureSource.prototype.getDefaultFIPs = function (callback) {
    if (this.opts.noExtraFeatureInfo) return true;

    this.bwgHolder.await(function (bwg) {
        if (!bwg) return;

        if (bwg.schema && bwg.definedFieldCount < bwg.schema.fields.length) {
            var fip = function fip(feature, featureInfo) {
                for (var hi = 0; hi < featureInfo.hit.length; ++hi) {
                    if (featureInfo.hit[hi].isSuperGroup) return;
                }
                for (var fi = bwg.definedFieldCount; fi < bwg.schema.fields.length; ++fi) {
                    var f = bwg.schema.fields[fi];
                    featureInfo.add(f.comment, feature[f.name]);
                }
            };

            callback(fip);
        } else {
            // No need to do anything.
        }
    });
};

BWGFeatureSource.prototype.getStyleSheet = function (callback) {
    var thisB = this;

    this.bwgHolder.await(function (bwg) {
        if (!bwg) {
            return callback(null, 'bbi error');
        }

        var stylesheet = new DASStylesheet();
        if (bwg.type == 'bigbed') {
            var wigStyle = new DASStyle();
            wigStyle.glyph = 'BOX';
            wigStyle.FGCOLOR = 'black';
            wigStyle.BGCOLOR = 'blue';
            wigStyle.HEIGHT = 8;
            wigStyle.BUMP = true;
            wigStyle.LABEL = true;
            wigStyle.ZINDEX = 20;
            stylesheet.pushStyle({ type: 'bigbed' }, null, wigStyle);

            wigStyle.glyph = 'BOX';
            wigStyle.FGCOLOR = 'black';
            wigStyle.BGCOLOR = 'red';
            wigStyle.HEIGHT = 10;
            wigStyle.BUMP = true;
            wigStyle.ZINDEX = 20;
            stylesheet.pushStyle({ type: 'translation' }, null, wigStyle);

            var tsStyle = new DASStyle();
            tsStyle.glyph = 'BOX';
            tsStyle.FGCOLOR = 'black';
            tsStyle.BGCOLOR = 'white';
            tsStyle.HEIGHT = 10;
            tsStyle.ZINDEX = 10;
            tsStyle.BUMP = true;
            tsStyle.LABEL = true;
            stylesheet.pushStyle({ type: 'transcript' }, null, tsStyle);

            var densStyle = new DASStyle();
            densStyle.glyph = 'HISTOGRAM';
            densStyle.COLOR1 = 'white';
            densStyle.COLOR2 = 'black';
            densStyle.HEIGHT = 30;
            stylesheet.pushStyle({ type: 'density' }, null, densStyle);
        } else {
            var wigStyle = new DASStyle();
            wigStyle.glyph = 'HISTOGRAM';
            wigStyle.COLOR1 = 'white';
            wigStyle.COLOR2 = 'black';
            wigStyle.HEIGHT = 30;
            stylesheet.pushStyle({ type: 'default' }, null, wigStyle);
        }

        if (bwg.definedFieldCount == 12 && bwg.fieldCount >= 14) {
            stylesheet.geneHint = true;
        }

        return callback(stylesheet);
    });
};

function RemoteBWGFeatureSource(bwgSource, worker, browser) {
    FeatureSourceBase.call(this);

    var thisB = this;
    this.worker = worker;
    this.readiness = 'Connecting';
    this.bwgSource = this.opts = bwgSource;
    this.keyHolder = new Awaited();

    if (bwgSource.resolver) {
        this.resolverKey = browser.registerResolver(bwgSource.resolver);
    }

    this.init();
}

RemoteBWGFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

RemoteBWGFeatureSource.prototype.init = function () {
    var thisB = this;
    var uri = this.uri || this.bwgSource.uri || this.bwgSource.bwgURI;
    var blob = this.bwgSource.blob || this.bwgSource.bwgBlob;

    var cnt = function cnt(key, err) {
        thisB.readiness = null;
        thisB.notifyReadiness();

        if (key) {
            thisB.worker.postCommand({ command: 'meta', connection: key }, function (meta, err) {
                if (err) {
                    thisB.error = err;
                    thisB.keyHolder.provide(null);
                } else {
                    thisB.meta = meta;
                    thisB.keyHolder.provide(key);
                }
            });
        } else {
            thisB.error = err;
            thisB.keyHolder.provide(null);
        }
    };

    if (blob) {
        this.worker.postCommand({ command: 'connectBBI', blob: blob }, cnt);
    } else {
        this.worker.postCommand({
            command: 'connectBBI',
            uri: resolveUrlToPage(uri),
            resolver: this.resolverKey,
            transport: this.bwgSource.transport,
            credentials: this.bwgSource.credentials }, cnt);
    }
};

RemoteBWGFeatureSource.prototype.capabilities = function () {
    var caps = { leap: true };

    if (this.meta && this.meta.type == 'bigwig') caps.quantLeap = true;
    if (this.meta && this.meta.extraIndices && this.meta.extraIndices.length > 0) {
        caps.search = [];
        for (var eii = 0; eii < this.meta.extraIndices.length; ++eii) {
            caps.search.push(this.meta.extraIndices[eii].field);
        }
    }
    return caps;
};

RemoteBWGFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback) {
    var thisB = this;

    thisB.busy++;
    thisB.notifyActivity();

    this.keyHolder.await(function (key) {
        if (!key) {
            thisB.busy--;
            thisB.notifyActivity();
            return callback(thisB.error || "Can't access binary file", null, null);
        }

        var zoom = -1;
        var wantDensity = !types || types.length === 0 || arrayIndexOf(types, 'density') >= 0;
        if (thisB.opts.clientBin) {
            wantDensity = false;
        }
        if (thisB.meta.type == 'bigwig' || wantDensity || typeof thisB.opts.forceReduction !== 'undefined') {
            for (var z = 1; z < thisB.meta.zoomLevels.length; ++z) {
                if (thisB.meta.zoomLevels[z] <= scale) {
                    zoom = z - 1; // Scales returned in metadata start at 1, unlike "real" zoom levels.
                } else {
                    break;
                }
            }
            if (typeof thisB.opts.forceReduction !== 'undefined') {
                zoom = thisB.opts.forceReduction;
            }
        }

        thisB.worker.postCommand({ command: 'fetch', connection: key, chr: chr, min: min, max: max, zoom: zoom }, function (features, error) {
            thisB.busy--;
            thisB.notifyActivity();

            var fs = 1000000000;
            if (thisB.meta.type === 'bigwig') {
                var is = (max - min) / features.length / 2;
                if (is < fs) {
                    fs = is;
                }
            }
            if (thisB.opts.link) {
                for (var fi = 0; fi < features.length; ++fi) {
                    var f = features[fi];
                    if (f.label) {
                        f.links = [new DASLink('Link', thisB.opts.link.replace(/\$\$/, f.label))];
                    }
                }
            }
            callback(error, features, fs);
        });
    });
};

RemoteBWGFeatureSource.prototype.quantFindNextFeature = function (chr, pos, dir, threshold, callback) {
    var thisB = this;
    this.busy++;
    this.notifyActivity();
    this.worker.postCommand({ command: 'quantLeap', connection: this.keyHolder.res, chr: chr, pos: pos, dir: dir, threshold: threshold, under: false }, function (result, err) {
        console.log(result, err);
        thisB.busy--;
        thisB.notifyActivity();
        return callback(result, err);
    });
};

RemoteBWGFeatureSource.prototype.findNextFeature = function (chr, pos, dir, callback) {
    var thisB = this;
    this.busy++;
    this.notifyActivity();
    this.worker.postCommand({ command: 'leap', connection: this.keyHolder.res, chr: chr, pos: pos, dir: dir }, function (result, err) {
        thisB.busy--;
        thisB.notifyActivity();
        if (result.length > 0 && result[0] !== null) {
            callback(result[0]);
        }
    });
};

RemoteBWGFeatureSource.prototype.getScales = function () {
    var meta = this.meta;
    if (meta) {
        return meta.zoomLevels;
    } else {
        return null;
    }
};

RemoteBWGFeatureSource.prototype.search = function (query, callback) {
    if (!this.meta.extraIndices || this.meta.extraIndices.length === 0) {
        return callback(null, 'No indices available');
    }

    var thisB = this;
    this.busy++;
    this.notifyActivity();
    var index = this.meta.extraIndices[0];
    this.worker.postCommand({ command: 'search', connection: this.keyHolder.res, query: query, index: index }, function (result, err) {
        thisB.busy--;
        thisB.notifyActivity();

        callback(result, err);
    });
};

RemoteBWGFeatureSource.prototype.getDefaultFIPs = function (callback) {
    if (this.opts.noExtraFeatureInfo) return true;

    var thisB = this;
    this.keyHolder.await(function (key) {
        var bwg = thisB.meta;
        if (!bwg) return;

        if (bwg.schema && bwg.definedFieldCount < bwg.schema.fields.length) {
            var fip = function fip(feature, featureInfo) {
                for (var hi = 0; hi < featureInfo.hit.length; ++hi) {
                    if (featureInfo.hit[hi].isSuperGroup) return;
                }
                for (var fi = bwg.definedFieldCount; fi < bwg.schema.fields.length; ++fi) {
                    var f = bwg.schema.fields[fi];
                    featureInfo.add(f.comment, feature[f.name]);
                }
            };

            callback(fip);
        } else {
            // No need to do anything.
        }
    });
};

RemoteBWGFeatureSource.prototype.getStyleSheet = function (callback) {
    var thisB = this;

    this.keyHolder.await(function (key) {
        var bwg = thisB.meta;
        if (!bwg) {
            return callback(null, 'bbi error');
        }

        var stylesheet = new DASStylesheet();
        if (bwg.type == 'bigbed') {
            var wigStyle = new DASStyle();
            wigStyle.glyph = 'BOX';
            wigStyle.FGCOLOR = 'black';
            wigStyle.BGCOLOR = 'blue';
            wigStyle.HEIGHT = 8;
            wigStyle.BUMP = true;
            wigStyle.LABEL = true;
            wigStyle.ZINDEX = 20;
            stylesheet.pushStyle({ type: 'bigbed' }, null, wigStyle);

            wigStyle.glyph = 'BOX';
            wigStyle.FGCOLOR = 'black';
            wigStyle.BGCOLOR = 'red';
            wigStyle.HEIGHT = 10;
            wigStyle.BUMP = true;
            wigStyle.ZINDEX = 20;
            stylesheet.pushStyle({ type: 'translation' }, null, wigStyle);

            var tsStyle = new DASStyle();
            tsStyle.glyph = 'BOX';
            tsStyle.FGCOLOR = 'black';
            tsStyle.BGCOLOR = 'white';
            tsStyle.HEIGHT = 10;
            tsStyle.ZINDEX = 10;
            tsStyle.BUMP = true;
            tsStyle.LABEL = true;
            stylesheet.pushStyle({ type: 'transcript' }, null, tsStyle);

            var densStyle = new DASStyle();
            densStyle.glyph = 'HISTOGRAM';
            densStyle.COLOR1 = 'white';
            densStyle.COLOR2 = 'black';
            densStyle.HEIGHT = 30;
            stylesheet.pushStyle({ type: 'density' }, null, densStyle);
        } else {
            var wigStyle = new DASStyle();
            wigStyle.glyph = 'HISTOGRAM';
            wigStyle.COLOR1 = 'white';
            wigStyle.COLOR2 = 'black';
            wigStyle.HEIGHT = 30;
            stylesheet.pushStyle({ type: 'default' }, null, wigStyle);
        }

        if (bwg.definedFieldCount == 12 && bwg.fieldCount >= 14) {
            stylesheet.geneHint = true;
        }

        return callback(stylesheet);
    });
};

function bamRecordToFeature(r, group) {
    if (r.flag & BamFlags.SEGMENT_UNMAPPED) return;

    var len;
    if (r.seq) len = r.seq.length;else len = r.seqLength;

    if (r.cigar) {
        len = 0;
        var ops = parseCigar(r.cigar);
        for (var ci = 0; ci < ops.length; ++ci) {
            var co = ops[ci];
            if (co.op == 'M' || co.op == 'D') len += co.cnt;
        }
    }

    var f = new DASFeature();
    f.min = r.pos + 1;
    f.max = r.pos + len;
    f.segment = r.segment;
    f.type = 'bam';
    f.id = r.readName;
    f.notes = [/* 'Sequence=' + r.seq, 'CIGAR=' + r.cigar, */'MQ=' + r.mq];
    f.cigar = r.cigar;
    f.seq = r.seq;
    f.quals = r.quals;
    f.orientation = r.flag & BamFlags.REVERSE_COMPLEMENT ? '-' : '+';
    f.bamRecord = r;

    if (group && r.flag & BamFlags.MULTIPLE_SEGMENTS) {
        f.groups = [{ id: r.readName,
            type: 'readpair' }];
    }

    return f;
}

function BAMFeatureSource(bamSource) {
    FeatureSourceBase.call(this);

    var thisB = this;
    this.bamSource = bamSource;
    this.opts = { credentials: bamSource.credentials, preflight: bamSource.preflight, bamGroup: bamSource.bamGroup };
    this.bamHolder = new Awaited();

    if (this.opts.preflight) {
        var pfs = bwg_preflights[this.opts.preflight];
        if (!pfs) {
            pfs = new Awaited();
            bwg_preflights[this.opts.preflight] = pfs;

            var req = new XMLHttpRequest();
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (req.status == 200) {
                        pfs.provide('success');
                    } else {
                        pfs.provide('failure');
                    }
                }
            };
            // req.setRequestHeader('cache-control', 'no-cache');    /* Doesn't work, not an allowed request header in CORS */
            req.open('get', this.opts.preflight + '?' + hex_sha1('salt' + Date.now()), true); // Instead, ensure we always preflight a unique URI.
            if (this.opts.credentials) {
                req.withCredentials = 'true';
            }
            req.send();
        }
        pfs.await(function (status) {
            if (status === 'success') {
                thisB.init();
            }
        });
    } else {
        thisB.init();
    }
}

BAMFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

BAMFeatureSource.prototype.init = function () {
    var thisB = this;
    var bamF, baiF;
    if (this.bamSource.bamBlob) {
        bamF = new BlobFetchable(this.bamSource.bamBlob);
        baiF = new BlobFetchable(this.bamSource.baiBlob);
    } else {
        bamF = new URLFetchable(this.bamSource.bamURI, { credentials: this.opts.credentials, resolver: this.opts.resolver });
        baiF = new URLFetchable(this.bamSource.baiURI || this.bamSource.bamURI + '.bai', { credentials: this.opts.credentials, resolver: this.opts.resolver });
    }
    makeBam(bamF, baiF, null, function (bam, err) {
        thisB.readiness = null;
        thisB.notifyReadiness();

        if (bam) {
            thisB.bamHolder.provide(bam);
        } else {
            thisB.error = err;
            thisB.bamHolder.provide(null);
        }
    });
};

BAMFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback) {
    var light = types && types.length == 1 && types[0] == 'density';

    var thisB = this;

    thisB.busy++;
    thisB.notifyActivity();

    this.bamHolder.await(function (bam) {
        if (!bam) {
            thisB.busy--;
            thisB.notifyActivity();
            return callback(thisB.error || "Couldn't fetch BAM");
        }

        bam.fetch(chr, min, max, function (bamRecords, error) {
            thisB.busy--;
            thisB.notifyActivity();

            if (error) {
                callback(error, null, null);
            } else {
                var features = [];
                for (var ri = 0; ri < bamRecords.length; ++ri) {
                    var r = bamRecords[ri];

                    var f = bamRecordToFeature(r, thisB.opts.bamGroup);
                    if (f) features.push(f);
                }
                callback(null, features, 1000000000);
            }
        }, { light: light });
    });
};

BAMFeatureSource.prototype.getScales = function () {
    return 1000000000;
};

BAMFeatureSource.prototype.getStyleSheet = function (callback) {
    this.bamHolder.await(function (bam) {
        var stylesheet = new DASStylesheet();

        var densStyle = new DASStyle();
        densStyle.glyph = 'HISTOGRAM';
        densStyle.COLOR1 = 'black';
        densStyle.COLOR2 = 'red';
        densStyle.HEIGHT = 30;
        stylesheet.pushStyle({ type: 'density' }, 'low', densStyle);
        stylesheet.pushStyle({ type: 'density' }, 'medium', densStyle);

        var wigStyle = new DASStyle();
        wigStyle.glyph = '__SEQUENCE';
        wigStyle.FGCOLOR = 'black';
        wigStyle.BGCOLOR = 'blue';
        wigStyle.HEIGHT = 8;
        wigStyle.BUMP = true;
        wigStyle.LABEL = false;
        wigStyle.ZINDEX = 20;
        stylesheet.pushStyle({ type: 'bam' }, 'high', wigStyle);

        return callback(stylesheet);
    });
};

function RemoteBAMFeatureSource(bamSource, worker) {
    FeatureSourceBase.call(this);

    var thisB = this;
    this.bamSource = bamSource;
    this.worker = worker;
    this.opts = { credentials: bamSource.credentials, preflight: bamSource.preflight, bamGroup: bamSource.bamGroup };
    this.keyHolder = new Awaited();

    if (bamSource.resolver) {
        this.resolverKey = browser.registerResolver(bamSource.resolver);
    }

    this.init();
}

RemoteBAMFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

RemoteBAMFeatureSource.prototype.init = function () {
    var thisB = this;
    var uri = this.bamSource.uri || this.bamSource.bamURI;
    var indexUri = this.bamSource.indexUri || this.bamSource.baiURI || uri + '.bai';

    var blob = this.bamSource.bamBlob || this.bamSource.blob;
    var indexBlob = this.bamSource.baiBlob || this.bamSource.indexBlob;

    var cnt = function cnt(result, err) {
        thisB.readiness = null;
        thisB.notifyReadiness();

        if (result) {
            thisB.keyHolder.provide(result);
        } else {
            thisB.error = err;
            thisB.keyHolder.provide(null);
        }
    };

    if (blob) {
        this.worker.postCommand({ command: 'connectBAM', blob: blob, indexBlob: indexBlob }, cnt);
    } else {
        this.worker.postCommand({
            command: 'connectBAM',
            uri: resolveUrlToPage(uri),
            resolver: this.resolverKey,
            indexUri: resolveUrlToPage(indexUri),
            credentials: this.bamSource.credentials,
            indexChunks: this.bamSource.indexChunks }, cnt);
    }
};

RemoteBAMFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback) {
    var light = types && types.length == 1 && types[0] == 'density';
    var thisB = this;

    thisB.busy++;
    thisB.notifyActivity();

    this.keyHolder.await(function (key) {
        if (!key) {
            thisB.busy--;
            thisB.notifyActivity();
            return callback(thisB.error || "Couldn't fetch BAM");
        }

        thisB.worker.postCommand({ command: 'fetch', connection: key, chr: chr, min: min, max: max, opts: { light: light } }, function (bamRecords, error) {
            // console.log('retrieved ' + bamRecords.length + ' via worker.');

            thisB.busy--;
            thisB.notifyActivity();

            if (error) {
                callback(error, null, null);
            } else {
                var features = [];
                for (var ri = 0; ri < bamRecords.length; ++ri) {
                    var r = bamRecords[ri];
                    var f = bamRecordToFeature(r, thisB.opts.bamGroup);
                    if (f) features.push(f);
                }
                callback(null, features, 1000000000);
            }
        });
    });
};

RemoteBAMFeatureSource.prototype.getScales = function () {
    return 1000000000;
};

RemoteBAMFeatureSource.prototype.getStyleSheet = function (callback) {
    this.keyHolder.await(function (bam) {
        var stylesheet = new DASStylesheet();

        var densStyle = new DASStyle();
        densStyle.glyph = 'HISTOGRAM';
        densStyle.COLOR1 = 'black';
        densStyle.COLOR2 = 'red';
        densStyle.HEIGHT = 30;
        stylesheet.pushStyle({ type: 'density' }, 'low', densStyle);
        stylesheet.pushStyle({ type: 'density' }, 'medium', densStyle);

        var wigStyle = new DASStyle();
        wigStyle.glyph = '__SEQUENCE';
        wigStyle.FGCOLOR = 'black';
        wigStyle.BGCOLOR = 'blue';
        wigStyle.HEIGHT = 8;
        wigStyle.BUMP = true;
        wigStyle.LABEL = false;
        wigStyle.ZINDEX = 20;
        stylesheet.pushStyle({ type: 'bam' }, 'high', wigStyle);
        return callback(stylesheet);
    });
};

function MappedFeatureSource(source, mapping) {
    this.source = source;
    this.mapping = mapping;

    this.activityListeners = [];
    this.busy = 0;
}

MappedFeatureSource.prototype.addActivityListener = function (listener) {
    this.activityListeners.push(listener);
};

MappedFeatureSource.prototype.removeActivityListener = function (listener) {
    var idx = arrayIndexOf(this.activityListeners, listener);
    if (idx >= 0) this.activityListeners.splice(idx, 0);
};

MappedFeatureSource.prototype.notifyActivity = function () {
    for (var li = 0; li < this.activityListeners.length; ++li) {
        try {
            this.activityListeners[li](this.busy);
        } catch (e) {
            console.log(e);
        }
    }
};

MappedFeatureSource.prototype.getStyleSheet = function (callback) {
    return this.source.getStyleSheet(callback);
};

MappedFeatureSource.prototype.getScales = function () {
    return this.source.getScales();
};

MappedFeatureSource.prototype.getDefaultFIPs = function (callback, tier) {
    if (this.source.getDefaultFIPs) return this.source.getDefaultFIPs(callback, tier);
};

MappedFeatureSource.prototype.simplifySegments = function (segs, minGap) {
    if (segs.length === 0) return segs;

    segs.sort(function (s1, s2) {
        var d = s1.name - s2.name;
        if (d) return d;
        d = s1.start - s2.start;
        if (d) return d;
        return s1.end - s2.end; // Should never come to this...?
    });

    var ssegs = [];
    var currentSeg = segs[0];
    for (var si = 0; si < segs.length; ++si) {
        var ns = segs[si];

        // console.log(ns.name + ' ' + ns.start + ' ' + ns.end);
        if (ns.name != currentSeg.name || ns.start > currentSeg.end + minGap) {
            ssegs.push(currentSeg);
            currentSeg = ns;
        } else {
            currentSeg = new DASSegment(currentSeg.name, Math.min(currentSeg.start, ns.start), Math.max(currentSeg.end, ns.end));
        }
    }
    ssegs.push(currentSeg);
    return ssegs;
};

MappedFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback, styleFilters) {
    var thisB = this;
    var fetchLength = max - min + 1;

    thisB.busy++;
    thisB.notifyActivity();

    this.mapping.sourceBlocksForRange(chr, min, max, function (mseg) {
        if (mseg.length === 0) {
            thisB.busy--;
            thisB.notifyActivity();

            callback("No mapping available for this regions", [], scale);
        } else {
            mseg = thisB.simplifySegments(mseg, Math.max(100, 0.05 * fetchLength));

            var mappedFeatures = [];
            var mappedLoc = null;
            var count = mseg.length;
            var finalStatus;

            mseg.map(function (seg) {
                thisB.source.fetch(seg.name, seg.start, seg.end, scale, types, pool, function (status, features, fscale) {
                    if (status && !finalStatus) finalStatus = status;

                    if (features) {
                        for (var fi = 0; fi < features.length; ++fi) {
                            var f = features[fi];
                            var sn = f.segment;
                            if (sn.indexOf('chr') === 0) {
                                sn = sn.substr(3);
                            }

                            var mappings = thisB.mapping.mapSegment(sn, f.min, f.max);

                            if (mappings.length === 0) {
                                if (f.parts && f.parts.length > 0) {
                                    mappedFeatures.push(f);
                                }
                            } else {
                                for (var mi = 0; mi < mappings.length; ++mi) {
                                    var m = mappings[mi];
                                    var mf = shallowCopy(f);
                                    mf.segment = m.segment;
                                    mf.min = m.min;
                                    mf.max = m.max;
                                    if (m.partialMin) mf.partialMin = m.partialMin;
                                    if (m.partialMax) mf.partialMax = m.partialMax;

                                    if (m.flipped) {
                                        if (f.orientation == '-') {
                                            mf.orientation = '+';
                                        } else if (f.orientation == '+') {
                                            mf.orientation = '-';
                                        }
                                    }
                                    mappedFeatures.push(mf);
                                }
                            }
                        }
                    }

                    var m1 = thisB.mapping.mapPoint(seg.name, seg.start);
                    var m2 = thisB.mapping.mapPoint(seg.name, seg.end);

                    if (m1 && m2) {
                        var segDestCoverage = new Range(m1.pos, m2.pos);
                        if (mappedLoc) mappedLoc = union(mappedLoc, segDestCoverage);else mappedLoc = segDestCoverage;
                    }

                    --count;
                    if (count === 0) {
                        thisB.busy--;
                        thisB.notifyActivity();
                        callback(finalStatus, mappedFeatures, fscale, mappedLoc);
                    }
                }, styleFilters);
            });
        }
    });
};

function DummyFeatureSource() {}

DummyFeatureSource.prototype.getScales = function () {
    return null;
};

DummyFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, cnt) {
    return cnt(null, [], 1000000000);
};

DummyFeatureSource.prototype.getStyleSheet = function (callback) {
    var stylesheet = new DASStylesheet();
    var defStyle = new DASStyle();
    defStyle.glyph = 'BOX';
    defStyle.BGCOLOR = 'blue';
    defStyle.FGCOLOR = 'black';
    stylesheet.pushStyle({ type: 'default' }, null, defStyle);
    return callback(stylesheet);
};

function DummySequenceSource() {}

DummySequenceSource.prototype.fetch = function (chr, min, max, pool, cnt) {
    return cnt(null, null);
};

function JBrowseFeatureSource(source) {
    this.store = new JBrowseStore(source.jbURI, source.jbQuery);
}

JBrowseFeatureSource.prototype.getScales = function () {
    return null;
};

JBrowseFeatureSource.prototype.getStyleSheet = function (callback) {
    var stylesheet = new DASStylesheet();

    var cdsStyle = new DASStyle();
    cdsStyle.glyph = 'BOX';
    cdsStyle.FGCOLOR = 'black';
    cdsStyle.BGCOLOR = 'red';
    cdsStyle.HEIGHT = 10;
    cdsStyle.BUMP = true;
    cdsStyle.ZINDEX = 20;
    stylesheet.pushStyle({ type: 'translation' }, null, cdsStyle);

    var tsStyle = new DASStyle();
    tsStyle.glyph = 'BOX';
    tsStyle.FGCOLOR = 'black';
    tsStyle.BGCOLOR = 'white';
    tsStyle.HEIGHT = 10;
    tsStyle.ZINDEX = 10;
    tsStyle.BUMP = true;
    tsStyle.LABEL = true;
    stylesheet.pushStyle({ type: 'transcript' }, null, tsStyle);

    var wigStyle = new DASStyle();
    wigStyle.glyph = 'BOX';
    wigStyle.FGCOLOR = 'black';
    wigStyle.BGCOLOR = 'green';
    wigStyle.HEIGHT = 8;
    wigStyle.BUMP = true;
    wigStyle.LABEL = true;
    wigStyle.ZINDEX = 20;
    stylesheet.pushStyle({ type: 'default' }, null, wigStyle);

    return callback(stylesheet);
};

JBrowseFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback) {
    if (types && types.length === 0) {
        callback(null, [], scale);
        return;
    }

    var fops = {};

    this.store.features(new DASSegment(chr, min, max), fops, function (features, status) {
        callback(status, features, 100000);
    });
};

Browser.prototype.sourceAdapterIsCapable = function (s, cap) {
    if (!s.capabilities) return false;else return s.capabilities()[cap];
};

if (typeof module !== 'undefined') {
    module.exports = {
        FeatureSourceBase: FeatureSourceBase,

        TwoBitSequenceSource: TwoBitSequenceSource,
        EnsemblSequenceSource: EnsemblSequenceSource,
        DASSequenceSource: DASSequenceSource,
        MappedFeatureSource: MappedFeatureSource,
        CachingFeatureSource: CachingFeatureSource,
        BWGFeatureSource: BWGFeatureSource,
        RemoteBWGFeatureSource: RemoteBWGFeatureSource,
        BAMFeatureSource: BAMFeatureSource,
        RemoteBAMFeatureSource: RemoteBAMFeatureSource,
        DummyFeatureSource: DummyFeatureSource,
        DummySequenceSource: DummySequenceSource,

        registerSourceAdapterFactory: dalliance_registerSourceAdapterFactory,
        registerParserFactory: dalliance_registerParserFactory,
        makeParser: dalliance_makeParser
    };

    // Standard set of plugins.
    require('./ensembljson');
    require('./tabix-source');
    require('./memstore');
    require('./bedwig');
    require('./vcf');
    require('./test-source');
}

},{"./bam":1,"./bedwig":2,"./bigwig":3,"./bin":4,"./cbrowser":6,"./chainset":7,"./cigar":8,"./das":10,"./encode":14,"./ensembljson":15,"./jbjson":24,"./memstore":27,"./overlay":30,"./spans":40,"./style":41,"./tabix-source":45,"./test-source":47,"./tier":51,"./twoBit":54,"./utils":55,"./vcf":56}],39:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2015
//
// sourcecompare.js
//


function sourceDataURI(conf) {
    if (conf.uri) {
        return conf.uri;
    } else if (conf.blob) {
        return 'file:' + conf.blob.name;
    } else if (conf.bwgBlob) {
        return 'file:' + conf.bwgBlob.name;
    } else if (conf.bamBlob) {
        return 'file:' + conf.bamBlob.name;
    } else if (conf.twoBitBlob) {
        return 'file:' + conf.twoBitBlob.name;
    }

    return conf.bwgURI || conf.bamURI || conf.jbURI || conf.twoBitURI || 'https://www.biodalliance.org/magic/no_uri';
}

function sourceStyleURI(conf) {
    if (conf.stylesheet_uri) return conf.stylesheet_uri;else if (conf.tier_type == 'sequence' || conf.twoBitURI || conf.twoBitBlob) return 'https://www.biodalliance.org/magic/sequence';else return sourceDataURI(conf);
}

function sourcesAreEqualModuloStyle(a, b) {
    if (sourceDataURI(a) != sourceDataURI(b)) return false;

    if (a.mapping != b.mapping) return false;

    if (a.tier_type != b.tier_type) return false;

    if (a.overlay) {
        if (!b.overlay || b.overlay.length != a.overlay.length) return false;
        for (var oi = 0; oi < a.overlay.length; ++oi) {
            if (!sourcesAreEqualModuloStyle(a.overlay[oi], b.overlay[oi])) return false;
        }
    } else {
        if (b.overlay) return false;
    }

    return true;
}

function sourcesAreEqual(a, b) {
    if (sourceDataURI(a) != sourceDataURI(b) || sourceStyleURI(a) != sourceStyleURI(b)) return false;

    if (a.mapping != b.mapping) return false;

    if (a.tier_type != b.tier_type) return false;

    if (a.overlay) {
        if (!b.overlay || b.overlay.length != a.overlay.length) return false;
        for (var oi = 0; oi < a.overlay.length; ++oi) {
            if (!sourcesAreEqual(a.overlay[oi], b.overlay[oi])) return false;
        }
    } else {
        if (b.overlay) return false;
    }

    return true;
}

if (typeof module !== 'undefined') {
    module.exports = {
        sourcesAreEqual: sourcesAreEqual,
        sourcesAreEqualModuloStyle: sourcesAreEqualModuloStyle,
        sourceDataURI: sourceDataURI,
        sourceStyleURI: sourceStyleURI
    };
}

},{}],40:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// spans.js: JavaScript Intset/Location port.
//

"use strict";

function Range(min, max) {
    if (typeof min != 'number' || typeof max != 'number') throw 'Bad range ' + min + ',' + max;
    this._min = min;
    this._max = max;
}

Range.prototype.min = function () {
    return this._min;
};

Range.prototype.max = function () {
    return this._max;
};

Range.prototype.contains = function (pos) {
    return pos >= this._min && pos <= this._max;
};

Range.prototype.isContiguous = function () {
    return true;
};

Range.prototype.ranges = function () {
    return [this];
};

Range.prototype._pushRanges = function (ranges) {
    ranges.push(this);
};

Range.prototype.toString = function () {
    return '[' + this._min + '-' + this._max + ']';
};

function _Compound(ranges) {
    // given: a set of unsorted possibly overlapping ranges
    // sort the input ranges
    var sorted = ranges.sort(_rangeOrder);
    // merge overlaps between adjacent ranges
    var merged = [];
    var current = sorted.shift();
    sorted.forEach(function (range) {
        if (range._min <= current._max) {
            if (range._max > current._max) {
                current._max = range._max;
            }
        } else {
            merged.push(current);
            current = range;
        }
    });
    merged.push(current);
    this._ranges = merged;
}

_Compound.prototype.min = function () {
    return this._ranges[0].min();
};

_Compound.prototype.max = function () {
    return this._ranges[this._ranges.length - 1].max();
};

// returns the index of the first range that is not less than pos
_Compound.prototype.lower_bound = function (pos) {
    // first check if pos is out of range
    var r = this.ranges();
    if (pos > this.max()) return r.length;
    if (pos < this.min()) return 0;
    // do a binary search
    var a = 0,
        b = r.length - 1;
    while (a <= b) {
        var m = Math.floor((a + b) / 2);
        if (pos > r[m]._max) {
            a = m + 1;
        } else if (pos < r[m]._min) {
            b = m - 1;
        } else {
            return m;
        }
    }
    return a;
};

_Compound.prototype.contains = function (pos) {
    var lb = this.lower_bound(pos);
    if (lb < this._ranges.length && this._ranges[lb].contains(pos)) {
        return true;
    }
    return false;
};

_Compound.prototype.insertRange = function (range) {
    var lb = this.lower_bound(range._min);
    if (lb === this._ranges.length) {
        // range follows this
        this._ranges.push(range);
        return;
    }

    var r = this.ranges();
    if (range._max < r[lb]._min) {
        // range preceeds lb
        this._ranges.splice(lb, 0, range);
        return;
    }

    // range overlaps lb (at least)
    if (r[lb]._min < range._min) range._min = r[lb]._min;
    var ub = lb + 1;
    while (ub < r.length && r[ub]._min <= range._max) {
        ub++;
    }
    ub--;
    // ub is the upper bound of the new range
    if (r[ub]._max > range._max) range._max = r[ub]._max;

    // splice range into this._ranges
    this._ranges.splice(lb, ub - lb + 1, range);
    return;
};

_Compound.prototype.isContiguous = function () {
    return this._ranges.length > 1;
};

_Compound.prototype.ranges = function () {
    return this._ranges;
};

_Compound.prototype._pushRanges = function (ranges) {
    for (var ri = 0; ri < this._ranges.length; ++ri) {
        ranges.push(this._ranges[ri]);
    }
};

_Compound.prototype.toString = function () {
    var s = '';
    for (var r = 0; r < this._ranges.length; ++r) {
        if (r > 0) {
            s = s + ',';
        }
        s = s + this._ranges[r].toString();
    }
    return s;
};

function union(s0, s1) {
    if (!(s0 instanceof _Compound)) {
        if (!(s0 instanceof Array)) s0 = [s0];
        s0 = new _Compound(s0);
    }

    if (s1) s0.insertRange(s1);

    return s0;
}

function intersection(s0, s1) {
    var r0 = s0.ranges();
    var r1 = s1.ranges();
    var l0 = r0.length,
        l1 = r1.length;
    var i0 = 0,
        i1 = 0;
    var or = [];

    while (i0 < l0 && i1 < l1) {
        var s0 = r0[i0],
            s1 = r1[i1];
        var lapMin = Math.max(s0.min(), s1.min());
        var lapMax = Math.min(s0.max(), s1.max());
        if (lapMax >= lapMin) {
            or.push(new Range(lapMin, lapMax));
        }
        if (s0.max() > s1.max()) {
            ++i1;
        } else {
            ++i0;
        }
    }

    if (or.length == 0) {
        return null; // FIXME
    } else if (or.length == 1) {
        return or[0];
    } else {
        return new _Compound(or);
    }
}

function coverage(s) {
    var tot = 0;
    var rl = s.ranges();
    for (var ri = 0; ri < rl.length; ++ri) {
        var r = rl[ri];
        tot += r.max() - r.min() + 1;
    }
    return tot;
}

function rangeOrder(a, b) {
    if (a.min() < b.min()) {
        return -1;
    } else if (a.min() > b.min()) {
        return 1;
    } else if (a.max() < b.max()) {
        return -1;
    } else if (b.max() > a.max()) {
        return 1;
    } else {
        return 0;
    }
}

function _rangeOrder(a, b) {
    if (a._min < b._min) {
        return -1;
    } else if (a._min > b._min) {
        return 1;
    } else if (a._max < b._max) {
        return -1;
    } else if (b._max > a._max) {
        return 1;
    } else {
        return 0;
    }
}

if (typeof module !== 'undefined') {
    module.exports = {
        Range: Range,
        union: union,
        intersection: intersection,
        coverage: coverage,
        rangeOver: rangeOrder,
        _rangeOrder: _rangeOrder
    };
}

},{}],41:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2014
//
// style.js
//

"use strict";

function StyleFilter(type, method, label) {
    this.type = type;
    this.method = method;
    this.label = label;
}

StyleFilter.prototype.equals = function (o) {
    return this.type == o.type && this.method == o.method && this.label == o.label;
};

StyleFilter.prototype.toString = function () {
    var fs = [];
    if (this.type) fs.push('type=' + this.type);
    if (this.method) fs.push('method=' + this.method);
    if (this.label) fs.push('label=' + this.label);
    return 'StyleFilter<' + fs.join(';') + '>';
};

function StyleFilterSet(filters) {
    this._filters = {};
    if (filters) {
        for (var fi = 0; fi < filters.length; ++fi) {
            this.add(filters[fi]);
        }
    }
}

StyleFilterSet.prototype.add = function (filter) {
    var fs = filter.toString();
    if (!this._filters[fs]) {
        this._filters[fs] = filter;
        this._list = null;
    }
};

StyleFilterSet.prototype.addAll = function (filterSet) {
    var l = filterSet.list();
    for (var fi = 0; fi < l.length; ++fi) {
        this.add(l[fi]);
    }
};

StyleFilterSet.prototype.doesNotContain = function (filterSet) {
    var l = filterSet.list();
    for (var fi = 0; fi < l.length; ++fi) {
        if (!this._filters[fi.toString()]) return true;
    }
    return false;
};

StyleFilterSet.prototype.list = function () {
    if (!this._list) {
        this._list = [];
        for (var k in this._filters) {
            if (this._filters.hasOwnProperty(k)) {
                this._list.push(this._filters[k]);
            }
        }
    }
    return this._list;
};

StyleFilterSet.prototype.typeList = function () {
    var types = [];
    var list = this.list();
    for (var fi = 0; fi < list.length; ++fi) {
        var filter = list[fi];
        var type = filter.type;
        if (!type || type == 'default') return null;
        if (types.indexOf(type) < 0) types.push(type);
    }
    return types;
};

if (typeof module !== 'undefined') {
    module.exports = {
        StyleFilter: StyleFilter,
        StyleFilterSet: StyleFilterSet
    };
}

},{}],42:[function(require,module,exports){
/* jshint esversion: 6 */
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.renderTier = renderTier;
exports.drawTier = drawTier;

/* To be used by tiers which are to be drawn in a multitier
   using the multi-renderer.

   Subtiers are configured by adding the following to a tier's source configuration:
       renderer: 'sub',
       sub: {
           multi_id: "multi_1",
           offset: 130,
           z: 2,
       }
   This would define a subtier that's to be rendered in the multi-tier with
   id "multi_1", with the top of the subtier at 130 pixels and at z-index 2.
 */

function renderTier(status, tier) {
    drawTier(tier);
    tier.updateStatus(status);
}

// drawTier is called when this tier's data has been fetched,
// so by refreshing the multiTier from here, we can be sure that
// there's something new worth drawing in it
function drawTier(tier) {
    var browser = tier.browser;

    var multiTier = browser.tiers.filter(function (t) {
        return t.dasSource.renderer === 'multi' && t.dasSource.multi.multi_id === tier.dasSource.sub.multi_id;
    });

    multiTier.forEach(function (t) {
        return browser.refreshTier(t);
    });
}

},{}],43:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// svg-export.js
//

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var makeElementNS = utils.makeElementNS;

    var VERSION = require('./version');

    var svgSeqTier = require('./sequence-draw').svgSeqTier;

    var svgu = require('./svg-utils');
    var NS_SVG = svgu.NS_SVG;
    var NS_XLINK = svgu.NS_XLINK;
    var SVGPath = svgu.SVGPath;

    var nf = require('./numformats');
    var formatQuantLabel = nf.formatQuantLabel;
    var formatLongInt = nf.formatLongInt;
}

Browser.prototype.makeSVG = function (opts) {
    opts = opts || {};
    var minTierHeight = opts.minTierHeight || 20;
    var padding = 3;
    var fpw = opts.width || this.featurePanelWidth;

    var backupFPW = this.featurePanelWidth;
    var backupScale = this.scale;
    this.featurePanelWidth = fpw;
    this.scale = this.featurePanelWidth / (this.viewEnd - this.viewStart);

    var b = this;
    var saveDoc = document.implementation.createDocument(NS_SVG, 'svg', null);

    var saveRoot = makeElementNS(NS_SVG, 'g', null, {
        fontFamily: 'helvetica',
        fontSize: '8pt'
    });
    saveDoc.documentElement.appendChild(saveRoot);

    var margin = 200;

    if (opts.banner) {
        var dallianceAnchor = makeElementNS(NS_SVG, 'a', makeElementNS(NS_SVG, 'text', 'Graphics from Biodalliance ' + VERSION, {
            x: b.featurePanelWidth + margin - 100,
            y: 35,
            strokeWidth: 0,
            fontSize: '12pt',
            textAnchor: 'end',
            fill: 'blue'
        }));
        dallianceAnchor.setAttribute('xmlns:xlink', NS_XLINK);
        dallianceAnchor.setAttribute('xlink:href', 'http://www.biodalliance.org/');

        saveRoot.appendChild(dallianceAnchor);
    }

    if (opts.region) {
        saveRoot.appendChild(makeElementNS(NS_SVG, 'text', this.chr + ':' + formatLongInt(this.viewStart) + '..' + formatLongInt(this.viewEnd), {
            x: margin + 100,
            y: 35,
            strokeWidth: 0,
            fontSize: '12pt',
            textAnchor: 'start'
        }));
    }

    var clipRect = makeElementNS(NS_SVG, 'rect', null, {
        x: margin,
        y: 50,
        width: b.featurePanelWidth,
        height: 100000
    });
    var clip = makeElementNS(NS_SVG, 'clipPath', clipRect, { id: 'featureClip' });
    saveRoot.appendChild(clip);

    var pos = 70;
    var tierHolder = makeElementNS(NS_SVG, 'g', null, {});

    for (var ti = 0; ti < b.tiers.length; ++ti) {
        var tier = b.tiers[ti];
        tier.backupSubtiers = tier.subtiers;
        tier.backupOriginHaxx = tier.originHaxx;
        tier.backupLayoutHeight = tier.layoutHeight;

        var renderer = b.getTierRenderer(tier);
        if (renderer && renderer.prepareSubtiers) {
            renderer.prepareSubtiers(tier, tier.viewport.getContext('2d'));
        }

        var tierSVG = makeElementNS(NS_SVG, 'g', null, { clipPath: 'url(#featureClip)', clipRule: 'nonzero' });
        var tierLabels = makeElementNS(NS_SVG, 'g');
        var tierTopPos = pos;

        var tierBackground = makeElementNS(NS_SVG, 'rect', null, { x: 0, y: tierTopPos, width: '10000', height: 50, fill: tier.background });
        tierSVG.appendChild(tierBackground);

        if (tier.sequenceSource) {
            var seqTrack = svgSeqTier(tier, tier.currentSequence);

            tierSVG.appendChild(makeElementNS(NS_SVG, 'g', seqTrack, { transform: 'translate(' + margin + ', ' + pos + ')' }));
            pos += 80;
        } else {
            if (!tier.subtiers) {
                continue;
            }

            var offset = (tier.glyphCacheOrigin - b.viewStart) * b.scale;
            var hasQuant = false;
            for (var sti = 0; sti < tier.subtiers.length; ++sti) {
                pos += padding;
                var subtier = tier.subtiers[sti];

                var glyphElements = [];
                for (var gi = 0; gi < subtier.glyphs.length; ++gi) {
                    var glyph = subtier.glyphs[gi];
                    glyphElements.push(glyph.toSVG());
                }

                tierSVG.appendChild(makeElementNS(NS_SVG, 'g', glyphElements, { transform: 'translate(' + (margin + offset) + ', ' + pos + ')' }));

                if (subtier.quant) {
                    hasQuant = true;
                    var q = subtier.quant;
                    var h = subtier.height;

                    var numTics = 2;
                    if (h > 40) {
                        numTics = 1 + (h / 20 | 0);
                    }
                    var ticSpacing = h / (numTics - 1);
                    var ticInterval = (q.max - q.min) / (numTics - 1);

                    var path = new SVGPath();
                    path.moveTo(margin + 5, pos);
                    path.lineTo(margin, pos);
                    path.lineTo(margin, pos + subtier.height);
                    path.lineTo(margin + 5, pos + subtier.height);
                    for (var t = 1; t < numTics - 1; ++t) {
                        var ty = t * ticSpacing;
                        path.moveTo(margin, pos + ty);
                        path.lineTo(margin + 3, pos + ty);
                    }

                    tierLabels.appendChild(makeElementNS(NS_SVG, 'path', null, { d: path.toPathData(), fill: 'none', stroke: 'black', strokeWidth: '2px' }));
                    tierLabels.appendChild(makeElementNS(NS_SVG, 'text', formatQuantLabel(q.max), { x: margin - 3, y: pos + 7, textAnchor: 'end' }));
                    tierLabels.appendChild(makeElementNS(NS_SVG, 'text', formatQuantLabel(q.min), { x: margin - 3, y: pos + subtier.height, textAnchor: 'end' }));
                    for (var t = 1; t < numTics - 1; ++t) {
                        var ty = t * ticSpacing;
                        tierLabels.appendChild(makeElementNS(NS_SVG, 'text', formatQuantLabel(1.0 * q.max - t * ticInterval), { x: margin - 3, y: pos + ty + 3, textAnchor: 'end' }));
                    }
                }

                pos += subtier.height + padding;
            }

            if (pos - tierTopPos < minTierHeight) {
                pos = tierTopPos + minTierHeight;
            }
        }

        var labelName;
        if (typeof tier.config.name === 'string') labelName = tier.config.name;else labelName = tier.dasSource.name;
        tierLabels.appendChild(makeElementNS(NS_SVG, 'text', labelName, { x: margin - (hasQuant ? 20 : 12), y: (pos + tierTopPos + 8) / 2, fontSize: '10pt', textAnchor: 'end' }));

        tierBackground.setAttribute('height', pos - tierTopPos);
        tierHolder.appendChild(makeElementNS(NS_SVG, 'g', [tierSVG, tierLabels]));

        tier.subtiers = tier.backupSubtiers;
        tier.originHaxx = tier.backupOriginHaxx;
        tier.layoutHeight = tier.backupLayoutHeight;
    }

    if (opts.highlights) {
        var highlights = this.highlights || [];
        for (var hi = 0; hi < highlights.length; ++hi) {
            var h = highlights[hi];
            if ((h.chr == this.chr || h.chr == 'chr' + this.chr) && h.min < this.viewEnd && h.max > this.viewStart) {
                var tmin = (Math.max(h.min, this.viewStart) - this.viewStart) * this.scale;
                var tmax = (Math.min(h.max, this.viewEnd) - this.viewStart) * this.scale;

                tierHolder.appendChild(makeElementNS(NS_SVG, 'rect', null, { x: margin + tmin, y: 70, width: tmax - tmin, height: pos - 70,
                    stroke: 'none', fill: this.defaultHighlightFill, fillOpacity: this.defaultHighlightAlpha }));
            }
        }
    }

    var rulerPos = -1;
    if (opts.ruler == 'center') {
        rulerPos = margin + (this.viewEnd - this.viewStart) * this.scale / 2;
    } else if (opts.ruler == 'left') {
        rulerPos = margin;
    } else if (opts.ruler == 'right') {
        rulerPos = margin + (this.viewEnd - this.viewStart) * this.scale;
    }
    if (rulerPos >= 0) {
        tierHolder.appendChild(makeElementNS(NS_SVG, 'line', null, { x1: rulerPos, y1: 70, x2: rulerPos, y2: pos,
            stroke: 'blue' }));
    }

    saveRoot.appendChild(tierHolder);
    saveDoc.documentElement.setAttribute('width', b.featurePanelWidth + 20 + margin);
    saveDoc.documentElement.setAttribute('height', pos + 50);

    this.featurePanelWidth = backupFPW;
    this.scale = backupScale;

    var svg = void 0;
    if (typeof XMLSerializer !== 'undefined') {
        svg = new XMLSerializer().serializeToString(saveDoc);
    } else {
        var root = saveDoc.documentElement;
        root.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        svg = root.outerHTML;
    }

    if (opts.output && opts.output === 'string') {
        return svg;
    } else {
        return new Blob([svg], { type: 'image/svg+xml' });
    }
};

},{"./cbrowser":6,"./numformats":29,"./sequence-draw":35,"./svg-utils":44,"./utils":55,"./version":57}],44:[function(require,module,exports){
'use strict';

/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// svg-utils.js
//

var NS_SVG = 'http://www.w3.org/2000/svg';
var NS_XLINK = 'http://www.w3.org/1999/xlink';

function SVGPath() {
    this.ops = [];
}

SVGPath.prototype.moveTo = function (x, y) {
    this.ops.push('M ' + x + ' ' + y);
};

SVGPath.prototype.lineTo = function (x, y) {
    this.ops.push('L ' + x + ' ' + y);
};

SVGPath.prototype.closePath = function () {
    this.ops.push('Z');
};

SVGPath.prototype.toPathData = function () {
    return this.ops.join(' ');
};

if (typeof module !== 'undefined') {
    module.exports = {
        NS_SVG: NS_SVG,
        NS_XLINK: NS_XLINK,
        SVGPath: SVGPath
    };
}

},{}],45:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// tabix-source.js
//

"use strict";

if (typeof require !== 'undefined') {
    var sa = require('./sourceadapters');
    var dalliance_registerSourceAdapterFactory = sa.registerSourceAdapterFactory;
    var dalliance_makeParser = sa.makeParser;
    var FeatureSourceBase = sa.FeatureSourceBase;

    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;
    var BlobFetchable = bin.BlobFetchable;

    var utils = require('./utils');
    var Awaited = utils.Awaited;

    var connectTabix = require('./tabix').connectTabix;
}

function TabixFeatureSource(source) {
    FeatureSourceBase.call(this);
    this.readiness = 'Connecting';
    this.source = source;

    this.tabixHolder = new Awaited();
    var thisB = this;

    var parser = dalliance_makeParser(source.payload);
    if (!parser) {
        throw 'Unsuported tabix payload ' + source.payload;
    } else {
        this.parser = parser;
    }

    var data, index;
    if (this.source.blob) {
        data = new BlobFetchable(this.source.blob);
        index = new BlobFetchable(this.source.indexBlob);
    } else {
        data = new URLFetchable(this.source.uri, { credentials: this.source.credentials, resolver: this.source.resolver });
        index = new URLFetchable(this.source.indexURI || this.source.uri + '.tbi', { credentials: this.source.credentials, resolver: this.source.resolver });
    }
    connectTabix(data, index, function (tabix, err) {
        thisB.tabixHolder.provide(tabix);
        tabix.fetchHeader(function (lines, err) {
            if (lines) {
                var session = parser.createSession(function () {/* Null sink because we shouldn't get records */});
                for (var li = 0; li < lines.length; ++li) {
                    session.parse(lines[li]);
                }
                session.flush();
            }
        });
        thisB.readiness = null;
        thisB.notifyReadiness();
    });
}

TabixFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

TabixFeatureSource.prototype.fetch = function (chr, min, max, scale, types, pool, callback) {
    var thisB = this;

    thisB.busy++;
    thisB.notifyActivity();

    this.tabixHolder.await(function (tabix) {
        tabix.fetch(chr, min, max, function (records, error) {
            thisB.busy--;
            thisB.notifyActivity();

            var features = [];
            var session = thisB.parser.createSession(function (f) {
                features.push(f);
            });
            for (var ri = 0; ri < records.length; ++ri) {
                var f = session.parse(records[ri]);
            }
            session.flush();
            callback(null, features, 1000000000);
        });
    });
};

TabixFeatureSource.prototype.getStyleSheet = function (callback) {
    if (this.parser && this.parser.getStyleSheet) this.parser.getStyleSheet(callback);
};

TabixFeatureSource.prototype.getDefaultFIPs = function (callback, tier) {
    if (this.parser && this.parser.getDefaultFIPs) this.parser.getDefaultFIPs(callback, tier);
};

dalliance_registerSourceAdapterFactory('tabix', function (source) {
    return { features: new TabixFeatureSource(source) };
});

},{"./bin":4,"./sourceadapters":38,"./tabix":46,"./utils":55}],46:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// tabix.js: basic support for tabix-indexed flatfiles
//

"use strict";

var TABIX_MAGIC = 0x01494254;

if (typeof require !== 'undefined') {
    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;

    var bin = require('./bin');
    var readInt = bin.readInt;
    var readShort = bin.readShort;
    var readByte = bin.readByte;
    var readInt64 = bin.readInt64;
    var readFloat = bin.readFloat;

    var lh3utils = require('./lh3utils');
    var readVob = lh3utils.readVob;
    var unbgzf = lh3utils.unbgzf;
    var reg2bins = lh3utils.reg2bins;
    var Chunk = lh3utils.Chunk;
}

function TabixFile() {}

function connectTabix(data, tbi, callback) {
    var tabix = new TabixFile();
    tabix.data = data;
    tabix.tbi = tbi;

    tabix.tbi.fetch(function (header) {
        // Do we really need to fetch the whole thing? :-(
        if (!header) {
            return callback(null, "Couldn't access Tabix");
        }

        var unchead = unbgzf(header, header.byteLength);
        var uncba = new Uint8Array(unchead);
        var magic = readInt(uncba, 0);
        if (magic != TABIX_MAGIC) {
            return callback(null, 'Not a tabix index');
        }

        var nref = readInt(uncba, 4);
        tabix.format = readInt(uncba, 8);
        tabix.colSeq = readInt(uncba, 12);
        tabix.colStart = readInt(uncba, 16);
        tabix.colEnd = readInt(uncba, 20);
        tabix.meta = readInt(uncba, 24);
        tabix.skip = readInt(uncba, 28);
        var nameLength = readInt(uncba, 32);

        tabix.indices = [];

        var p = 36;
        tabix.chrToIndex = {};
        tabix.indexToChr = [];
        for (var i = 0; i < nref; ++i) {
            var name = '';

            while (true) {
                var ch = uncba[p++];
                if (ch == 0) break;

                name += String.fromCharCode(ch);
            }

            tabix.chrToIndex[name] = i;
            if (name.indexOf('chr') == 0) {
                tabix.chrToIndex[name.substring(3)] = i;
            } else {
                tabix.chrToIndex['chr' + name] = i;
            }
            tabix.indexToChr.push(name);
        }

        var minBlockIndex = 1000000000;
        for (var ref = 0; ref < nref; ++ref) {
            var blockStart = p;
            var nbin = readInt(uncba, p);p += 4;
            for (var b = 0; b < nbin; ++b) {
                var bin = readInt(uncba, p);
                var nchnk = readInt(uncba, p + 4);
                p += 8 + nchnk * 16;
            }
            var nintv = readInt(uncba, p);p += 4;

            var q = p;
            for (var i = 0; i < nintv; ++i) {
                var v = readVob(uncba, q);q += 8;
                if (v) {
                    var bi = v.block;
                    if (v.offset > 0) bi += 65536;

                    if (bi < minBlockIndex) minBlockIndex = bi;
                    break;
                }
            }
            p += nintv * 8;

            var ub = uncba;
            if (nbin > 0) {
                tabix.indices[ref] = new Uint8Array(unchead, blockStart, p - blockStart);
            }
        }

        tabix.headerMax = minBlockIndex;

        callback(tabix);
    }, { timeout: 50000 });
}

// Copy-paste from BamFile

TabixFile.prototype.blocksForRange = function (refId, min, max) {
    var index = this.indices[refId];
    if (!index) {
        return [];
    }

    var intBinsL = reg2bins(min, max);
    var intBins = [];
    for (var i = 0; i < intBinsL.length; ++i) {
        intBins[intBinsL[i]] = true;
    }
    var leafChunks = [],
        otherChunks = [];

    var nbin = readInt(index, 0);
    var p = 4;
    for (var b = 0; b < nbin; ++b) {
        var bin = readInt(index, p);
        var nchnk = readInt(index, p + 4);
        p += 8;
        if (intBins[bin]) {
            for (var c = 0; c < nchnk; ++c) {
                var cs = readVob(index, p, true);
                var ce = readVob(index, p + 8, true);
                (bin < 4681 ? otherChunks : leafChunks).push(new Chunk(cs, ce));
                p += 16;
            }
        } else {
            p += nchnk * 16;
        }
    }

    var nintv = readInt(index, p);
    var lowest = null;
    var minLin = Math.min(min >> 14, nintv - 1),
        maxLin = Math.min(max >> 14, nintv - 1);
    for (var i = minLin; i <= maxLin; ++i) {
        var lb = readVob(index, p + 4 + i * 8);
        if (!lb) {
            continue;
        }
        if (!lowest || lb.block < lowest.block || lb.offset < lowest.offset) {
            lowest = lb;
        }
    }

    var prunedOtherChunks = [];
    if (lowest != null) {
        for (var i = 0; i < otherChunks.length; ++i) {
            var chnk = otherChunks[i];
            if (chnk.maxv.block >= lowest.block && chnk.maxv.offset >= lowest.offset) {
                prunedOtherChunks.push(chnk);
            }
        }
    }
    otherChunks = prunedOtherChunks;

    var intChunks = [];
    for (var i = 0; i < otherChunks.length; ++i) {
        intChunks.push(otherChunks[i]);
    }
    for (var i = 0; i < leafChunks.length; ++i) {
        intChunks.push(leafChunks[i]);
    }

    intChunks.sort(function (c0, c1) {
        var dif = c0.minv.block - c1.minv.block;
        if (dif != 0) {
            return dif;
        } else {
            return c0.minv.offset - c1.minv.offset;
        }
    });
    var mergedChunks = [];
    if (intChunks.length > 0) {
        var cur = intChunks[0];
        for (var i = 1; i < intChunks.length; ++i) {
            var nc = intChunks[i];
            if (nc.minv.block == cur.maxv.block /* && nc.minv.offset == cur.maxv.offset */) {
                    // no point splitting mid-block
                    cur = new Chunk(cur.minv, nc.maxv);
                } else {
                mergedChunks.push(cur);
                cur = nc;
            }
        }
        mergedChunks.push(cur);
    }

    return mergedChunks;
};

TabixFile.prototype.fetch = function (chr, min, max, callback) {
    var thisB = this;

    var chrId = this.chrToIndex[chr];
    if (chrId == undefined) return callback([]);

    var canonicalChr = this.indexToChr[chrId];

    var chunks;
    if (chrId === undefined) {
        chunks = [];
    } else {
        chunks = this.blocksForRange(chrId, min, max);
        if (!chunks) {
            callback(null, 'Error in index fetch');
        }
    }

    var records = [];
    var index = 0;
    var data;

    function tramp() {
        if (index >= chunks.length) {
            return callback(records);
        } else if (!data) {
            var c = chunks[index];
            var fetchMin = c.minv.block;
            var fetchMax = c.maxv.block + (1 << 16); // *sigh*
            thisB.data.slice(fetchMin, fetchMax - fetchMin).fetch(function (r) {
                data = unbgzf(r, c.maxv.block - c.minv.block + 1);
                return tramp();
            });
        } else {
            var ba = new Uint8Array(data);
            thisB.readRecords(ba, chunks[index].minv.offset, records, min, max, canonicalChr);
            data = null;
            ++index;
            return tramp();
        }
    }
    tramp();
};

TabixFile.prototype.readRecords = function (ba, offset, sink, min, max, chr) {
    LINE_LOOP: while (true) {
        var line = '';
        while (offset < ba.length) {
            var ch = ba[offset++];
            if (ch == 10) {
                var toks = line.split('\t');

                if (toks[this.colSeq - 1] == chr) {
                    var fmin = parseInt(toks[this.colStart - 1]);
                    var fmax = fmin;
                    if (this.colEnd > 0) fmax = parseInt(toks[this.colEnd - 1]);
                    if (this.format & 0x10000) ++fmin;

                    if (fmin <= max && fmax >= min) sink.push(line);
                }
                continue LINE_LOOP;
            } else {
                line += String.fromCharCode(ch);
            }
        }
        return;
    }
};

TabixFile.prototype.fetchHeader = function (callback) {
    var self = this;
    var fetchPtr = 0,
        ptr = 0,
        line = '';
    var lines = [];

    self.data.slice(0, self.headerMax).fetch(function (chnk) {
        if (!chnk) {
            return callback(null, "Fetch failed");
        }
        var ba = new Uint8Array(unbgzf(chnk, chnk.byteLength));
        var ptr = 0,
            line = '',
            lines = [];
        while (ptr < ba.length) {
            var ch = ba[ptr++];
            if (ch == 10) {
                if (line.charCodeAt(0) == self.meta) {
                    lines.push(line);
                    line = '';
                } else {
                    return callback(lines);
                }
            } else {
                line += String.fromCharCode(ch);
            }
        }
        callback(lines);
    });
};

if (typeof module !== 'undefined') {
    module.exports = {
        connectTabix: connectTabix,
        TABIX_MAGIC: TABIX_MAGIC
    };
}

},{"./bin":4,"./lh3utils":26,"./spans":40}],47:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _sourceadapters = require("./sourceadapters.js");

var _das = require("./das.js");

var _ramda = require("ramda");

var R = _interopRequireWildcard(_ramda);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint esversion: 6 */

/*
 Source that can be configured to produce any type of feature,
 useful for testing renderers.
 */

var TestSource = function (_FeatureSourceBase) {
    _inherits(TestSource, _FeatureSourceBase);

    function TestSource(source) {
        _classCallCheck(this, TestSource);

        var _this = _possibleConstructorReturn(this, (TestSource.__proto__ || Object.getPrototypeOf(TestSource)).call(this));

        _this.features = R.defaultTo([], source.features);
        return _this;
    }

    _createClass(TestSource, [{
        key: "genFeature",
        value: function genFeature(conf) {
            var feature = new _das.DASFeature();

            for (var key in conf) {
                feature[key] = conf[key];
            }
        }
    }, {
        key: "fetch",
        value: function fetch(chr, min, max, scale, types, pool, callback) {
            var features = R.forEach(this.genFeature, this.features);
            return callback(null, features, 1);
        }
    }]);

    return TestSource;
}(_sourceadapters.FeatureSourceBase);

(0, _sourceadapters.registerSourceAdapterFactory)('test-source', function (source) {
    return { features: new TestSource(source) };
});

},{"./das.js":10,"./sourceadapters.js":38,"ramda":62}],48:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// thub.js: support for track-hub style registries
//

"use strict";

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var textXHR = utils.textXHR;
    var relativeURL = utils.relativeURL;
    var shallowCopy = utils.shallowCopy;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
}

var THUB_STANZA_REGEXP = /\n\s*\n/;
var THUB_PARSE_REGEXP = /(\w+) +(.+)\n?/;
var THUB_SUBGROUP_REGEXP = /subGroup[1-9]/;

var THUB_PENNANT_PREFIX = 'http://genome.ucsc.edu/images/';

function resolveHubURL(base, relURL, forceProtocol) {
    var url = relativeURL(base, relURL);
    if (forceProtocol && url.startsWith(forceProtocol + ':') !== 0) {
        var protocolIdx = url.indexOf(':');
        if (protocolIdx > 0) {
            url = forceProtocol + url.substring(protocolIdx);
        }
    }
    return url;
}

function TrackHub(url) {
    this.genomes = {};
    this.url = url;
}

function TrackHubTrack() {}

TrackHubTrack.prototype.get = function (k) {
    if (this[k]) return this[k];else if (this._parent) return this._parent.get(k);
};

function TrackHubDB(hub, opts) {
    this.hub = hub;

    opts = opts || {};
    if (opts.credentials) {
        this.credentials = opts.credentials;
    }
    if (opts.forceProtocol) {
        this.forceProtocol = opts.forceProtocol;
    }
}

TrackHubDB.prototype.dataURL = function (relURL) {
    return resolveHubURL(this.absURL, relURL, this.forceProtocol);
};

TrackHubDB.prototype.getTracks = function (callback) {
    var thisB = this;
    if (this._tracks) {
        return callback(this._tracks);
    }

    textXHR(this.absURL, function (trackFile, err) {
        if (err) {
            return callback(null, err);
        }

        // trackFile = trackFile.replace(/\#.*/g, '');
        trackFile = trackFile.replace('\\\n', ' ');

        var tracks = [];
        var tracksById = {};
        var stanzas = trackFile.split(THUB_STANZA_REGEXP);
        for (var s = 0; s < stanzas.length; ++s) {
            var toks = stanzas[s].replace(/\#.*/g, '').split(THUB_PARSE_REGEXP);
            var track = new TrackHubTrack();
            track._db = thisB;
            for (var l = 0; l < toks.length - 2; l += 3) {
                var k = toks[l + 1],
                    v = toks[l + 2];
                if (k.match(THUB_SUBGROUP_REGEXP)) {
                    if (!track.subgroups) track.subgroups = {};
                    var sgtoks = v.split(/\s/);
                    var sgtag = sgtoks[0];
                    var sgrecord = { name: sgtoks[1], tags: [], titles: [] };
                    for (var sgti = 2; sgti < sgtoks.length; ++sgti) {
                        var grp = sgtoks[sgti].split(/=/);
                        sgrecord.tags.push(grp[0]);
                        sgrecord.titles.push(grp[1]);
                    }
                    track.subgroups[sgtag] = sgrecord;
                } else if (k === 'subGroups') {
                    var sgtoks = v.split(/(\w+)=(\w+)/);
                    track.sgm = {};
                    for (var sgti = 0; sgti < sgtoks.length - 2; sgti += 3) {
                        track.sgm[sgtoks[sgti + 1]] = sgtoks[sgti + 2];
                    }
                } else {
                    track[toks[l + 1]] = toks[l + 2];
                }
            }

            if (track.track && (track.type || track.container || track.view || track.bigDataUrl)) {
                tracks.push(track);
                tracksById[track.track] = track;
            } else {
                // console.log('skipping ', track);
            }
        }

        var toplevels = [];
        var composites = [];
        for (var ti = 0; ti < tracks.length; ++ti) {
            var track = tracks[ti];
            var top = true;
            if (track.parent) {
                var ptoks = track.parent.split(/\s+/);
                var parent = tracksById[ptoks[0]];
                if (parent) {
                    track._parent = parent;

                    if (!parent.children) parent.children = [];
                    parent.children.push(track);

                    if (parent) top = false;
                } else {
                    console.log("Couldn't find parent " + ptoks[0] + '(' + track.parent + ')');
                }
            }
            if (track.compositeTrack) {
                composites.push(track);
            } else if (top) {
                toplevels.push(track);
            }
        }

        for (var ci = 0; ci < composites.length; ++ci) {
            var comp = composites[ci];
            if (!comp.children) continue;

            var parentOfViews = false;
            for (var ki = 0; ki < comp.children.length; ++ki) {
                var k = comp.children[ki];
                if (k.view) {
                    k.shortLabel = comp.shortLabel + ": " + k.shortLabel;
                    toplevels.push(k);
                    parentOfViews = true;
                }
            }
            if (!parentOfViews) toplevels.push(comp);
        }

        thisB._tracks = toplevels;
        return callback(thisB._tracks, null);
    }, { credentials: this.credentials, salt: true });
};

function connectTrackHub(hubURL, callback, opts) {
    opts = opts || {};
    opts.salt = true;

    textXHR(hubURL, function (hubFile, err) {
        if (err) {
            return callback(null, err);
        }

        var toks = hubFile.split(THUB_PARSE_REGEXP);
        var hub = new TrackHub(hubURL);
        if (opts.credentials) {
            hub.credentials = opts.credentials;
        }
        for (var l = 0; l < toks.length - 2; l += 3) {
            hub[toks[l + 1]] = toks[l + 2];
        }

        if (hub.genomesFile) {
            var genURL = resolveHubURL(hubURL, hub.genomesFile, opts.forceProtocol);
            textXHR(genURL, function (genFile, err) {
                if (err) {
                    return callback(null, err);
                }

                var stanzas = genFile.split(THUB_STANZA_REGEXP);
                for (var s = 0; s < stanzas.length; ++s) {
                    var toks = stanzas[s].split(THUB_PARSE_REGEXP);
                    var gprops = new TrackHubDB(hub, opts);
                    // if (opts.credentials) {
                    //    gprops.credentials = opts.credentials;
                    //}

                    for (var l = 0; l < toks.length - 2; l += 3) {
                        gprops[toks[l + 1]] = toks[l + 2];
                    }

                    if (gprops.twoBitPath) {
                        gprops.twoBitPath = resolveHubURL(genURL, gprops.twoBitPath, opts.forceProtocol);
                    }

                    if (gprops.genome && gprops.trackDb) {
                        gprops.absURL = resolveHubURL(genURL, gprops.trackDb, opts.forceProtocol);
                        hub.genomes[gprops.genome] = gprops;
                    }
                }

                callback(hub);
            }, opts);
        } else {
            callback(null, 'No genomesFile');
        }
    }, opts);
}

TrackHubTrack.prototype.toDallianceSource = function () {
    var source = {
        name: this.shortLabel,
        desc: this.longLabel
    };
    if (this._db.mapping) {
        source.mapping = this._db.mapping;
    }

    var pennantIcon = this.get('pennantIcon');
    if (pennantIcon) {
        var ptoks = pennantIcon.split(/\s+/);
        source.pennant = THUB_PENNANT_PREFIX + ptoks[0];
    }

    var searchTrix = this.get('searchTrix');
    if (searchTrix) {
        source.trixURI = this._db.dataURL(searchTrix);
    }

    if (this.container == 'multiWig') {
        source.merge = 'concat';
        source.overlay = [];
        var children = this.children || [];
        source.style = [];
        source.noDownsample = true;

        for (var ci = 0; ci < children.length; ++ci) {
            var ch = children[ci];
            var cs = ch.toDallianceSource();
            source.overlay.push(cs);

            if (cs.style) {
                for (var si = 0; si < cs.style.length; ++si) {
                    var style = cs.style[si];
                    style.method = ch.shortLabel; // FIXME
                    if (this.aggregate == 'transparentOverlay') style.style.ALPHA = 0.5;
                    source.style.push(style);
                }
            }
        }
        return source;
    } else {
        var type = this.type;
        if (!type) {
            var p = this;
            while (p._parent && !p.type) {
                p = p._parent;
            }
            type = p.type;
        }
        if (!type) return;
        var typeToks = type.split(/\s+/);
        if (typeToks[0] == 'bigBed' && this.bigDataUrl) {
            var bedTokens = typeToks[1] | 0;
            var bedPlus = typeToks[2] == '+';

            source.bwgURI = this._db.dataURL(this.bigDataUrl);
            source.style = this.bigbedStyles();
            if (this._db.credentials) {
                source.credentials = true;
            }
            if (bedTokens >= 12 && bedPlus) source.collapseSuperGroups = true;
            return source;
        } else if (typeToks[0] == 'bigWig' && this.bigDataUrl) {
            source.bwgURI = this._db.dataURL(this.bigDataUrl);
            source.style = this.bigwigStyles();
            source.noDownsample = true; // FIXME seems like a blunt instrument...

            if (this.yLineOnOff && this.yLineOnOff == 'on') {
                source.quantLeapThreshold = this.yLineMark !== undefined ? 1.0 * this.yLineMark : 0.0;
            }

            if (this._db.credentials) {
                source.credentials = true;
            }

            return source;
        } else if (typeToks[0] == 'bam' && this.bigDataUrl) {
            source.bamURI = this._db.dataURL(this.bigDataUrl);
            if (this._db.credentials) {
                source.credentials = true;
            }
            return source;
        } else if (typeToks[0] == 'vcfTabix' && this.bigDataUrl) {
            source.uri = this._db.dataURL(this.bigDataUrl);
            source.tier_type = 'tabix';
            source.payload = 'vcf';
            if (this._db.credentials) {
                source.credentials = true;
            }
            return source;
        } else {
            console.log('Unsupported ' + this.type);
        }
    }
};

TrackHubTrack.prototype.bigwigStyles = function () {
    var type = this.type;
    if (!type) {
        var p = this;
        while (p._parent && !p.type) {
            p = p._parent;
        }
        type = p.type;
    }
    if (!type) return;
    var typeToks = type.split(/\s+/);

    var min, max;
    if (typeToks.length >= 3) {
        min = 1.0 * typeToks[1];
        max = 1.0 * typeToks[2];
    }

    var height;
    if (this.maxHeightPixels) {
        var mhpToks = this.maxHeightPixels.split(/:/);
        if (mhpToks.length == 3) {
            height = mhpToks[1] | 0;
        } else {
            console.log('maxHeightPixels should be of the form max:default:min');
        }
    }

    var gtype = 'bars';
    if (this.graphTypeDefault) {
        gtype = this.graphTypeDefault;
    }

    var color = 'black';
    var altColor = null;
    if (this.color) {
        color = 'rgb(' + this.color + ')';
    }
    if (this.altColor) {
        altColor = 'rgb(' + this.altColor + ')';
    }

    var stylesheet = new DASStylesheet();
    var wigStyle = new DASStyle();
    if (gtype == 'points') {
        wigStyle.glyph = 'POINT';
    } else {
        wigStyle.glyph = 'HISTOGRAM';
    }

    if (altColor) {
        wigStyle.COLOR1 = color;
        wigStyle.COLOR2 = altColor;
    } else {
        wigStyle.BGCOLOR = color;
    }
    wigStyle.HEIGHT = height || 30;
    if (min || max) {
        wigStyle.MIN = min;
        wigStyle.MAX = max;
    }
    stylesheet.pushStyle({ type: 'default' }, null, wigStyle);
    return stylesheet.styles;
};

TrackHubTrack.prototype.bigbedStyles = function () {
    var itemRgb = ('' + this.get('itemRgb')).toLowerCase() == 'on';
    var visibility = this.get('visibility') || 'full';
    var color = this.get('color');
    if (color) color = 'rgb(' + color + ')';else color = 'blue';

    var stylesheet = new DASStylesheet();
    var wigStyle = new DASStyle();
    wigStyle.glyph = 'BOX';
    wigStyle.FGCOLOR = 'black';
    wigStyle.BGCOLOR = color;
    wigStyle.HEIGHT = visibility == 'full' || visibility == 'pack' ? 12 : 8;
    wigStyle.BUMP = visibility == 'full' || visibility == 'pack';
    wigStyle.LABEL = visibility == 'full' || visibility == 'pack';
    wigStyle.ZINDEX = 20;
    if (itemRgb) wigStyle.BGITEM = true;

    var cbs = this.get('colorByStrand');
    if (cbs) {
        var cbsToks = cbs.split(/\s+/);

        var plus = shallowCopy(wigStyle);
        plus.BGCOLOR = 'rgb(' + cbsToks[0] + ')';
        stylesheet.pushStyle({ type: 'bigbed', orientation: '+' }, null, plus);

        var minus = shallowCopy(wigStyle);
        minus.BGCOLOR = 'rgb(' + cbsToks[1] + ')';
        stylesheet.pushStyle({ type: 'bigbed', orientation: '-' }, null, minus);
    } else {
        stylesheet.pushStyle({ type: 'bigbed' }, null, wigStyle);
    }

    var tlStyle = new DASStyle();
    tlStyle.glyph = 'BOX';
    tlStyle.FGCOLOR = 'black';
    if (itemRgb) tlStyle.BGITEM = true;
    tlStyle.BGCOLOR = 'red';
    tlStyle.HEIGHT = 10;
    tlStyle.BUMP = true;
    tlStyle.ZINDEX = 20;
    stylesheet.pushStyle({ type: 'translation' }, null, tlStyle);

    var tsStyle = new DASStyle();
    tsStyle.glyph = 'BOX';
    tsStyle.FGCOLOR = 'black';
    tsStyle.BGCOLOR = 'white';
    tsStyle.HEIGHT = 10;
    tsStyle.ZINDEX = 10;
    tsStyle.BUMP = true;
    tsStyle.LABEL = true;
    stylesheet.pushStyle({ type: 'transcript' }, null, tsStyle);

    return stylesheet.styles;
};

function THUB_COMPARE(g, h) {
    if (g.priority && h.priority) {
        return 1.0 * g.priority - 1.0 * h.priority;
    } else if (g.priority) {
        return 1;
    } else if (h.priority) {
        return -1;
    } else {
        return g.shortLabel.localeCompare(h.shortLabel);
    }
}

if (typeof module !== 'undefined') {
    module.exports = {
        connectTrackHub: connectTrackHub,
        THUB_COMPARE: THUB_COMPARE
    };
}

},{"./das":10,"./utils":55}],49:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// tier-actions.js
//

"use strict";

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;
}

Browser.prototype.mergeSelectedTiers = function () {
    var sources = [];
    var styles = [];

    for (var sti = 0; sti < this.selectedTiers.length; ++sti) {
        var tier = this.tiers[this.selectedTiers[sti]];
        sources.push(shallowCopy(tier.dasSource));
        var ss = tier.stylesheet.styles;
        for (var si = 0; si < ss.length; ++si) {
            var sh = ss[si];
            var nsh = shallowCopy(sh);
            nsh.method = tier.dasSource.name.replace(/[()+*?]/g, '\\$&');
            nsh._methodRE = null;
            nsh.style = shallowCopy(sh.style);
            if (nsh.style.ZINDEX === undefined) nsh.style.ZINDEX = sti;

            if (tier.forceMin) {
                nsh.style.MIN = tier.forceMin;
            }
            if (tier.forceMax) {
                nsh.style.MAX = tier.forceMax;
            }

            styles.push(nsh);
        }
    }

    this.addTier({ name: 'Merged',
        merge: 'concat',
        overlay: sources,
        noDownsample: true,
        style: styles });

    this.setSelectedTier(this.tiers.length - 1);
};

},{"./cbrowser":6,"./utils":55}],50:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// tier-edit.js
//

"use strict";

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var makeElement = utils.makeElement;

    var das = require('./das');
    var isDasBooleanTrue = das.isDasBooleanTrue;
    var isDasBooleanNotFalse = das.isDasBooleanNotFalse;
    var copyStylesheet = das.copyStylesheet;

    var color = require('./color');
    var dasColourForName = color.dasColourForName;

    var sourceDataURI = require('./sourcecompare').sourceDataURI;
}

var __dalliance_smallGlyphs = {
    DOT: true,
    EX: true,
    STAR: true,
    SQUARE: true,
    CROSS: true,
    TRIANGLE: true,
    PLIMSOLL: true
};

Browser.prototype.openTierPanel = function (tier) {
    var b = this;

    if (this.uiMode === 'tier' && this.manipulatingTier === tier) {
        this.hideToolPanel();
        this.setUiMode('none');
    } else if (!tier) {
        return;
    } else {
        var setStyleColors = function setStyleColors(style) {
            if (style.BGGRAD) return;

            if (numColors == 1) {
                if (style.glyph == 'LINEPLOT' || __dalliance_smallGlyphs[style.glyph]) {
                    style.FGCOLOR = tierColorField.value;
                } else {
                    style.BGCOLOR = tierColorField.value;
                }
                style.COLOR1 = style.COLOR2 = style.COLOR3 = null;
            } else {
                style.COLOR1 = tierColorField.value;
                style.COLOR2 = tierColorField2.value;
                if (numColors > 2) {
                    style.COLOR3 = tierColorField3.value;
                } else {
                    style.COLOR3 = null;
                }
            }
            style._gradient = null;
            style._plusColor = tierPlusColorField.value;
            style._minusColor = tierMinusColorField.value;
        };

        var mutateStylesheet = function mutateStylesheet(visitor) {
            var nss = copyStylesheet(tier.stylesheet);
            var ssScale = tier.browser.zoomForCurrentScale();

            for (var i = 0; i < nss.styles.length; ++i) {
                var sh = nss.styles[i];
                if (sh.zoom && sh.zoom != ssScale) {
                    continue;
                }

                visitor(sh.style);
            }

            return nss;
        };

        var changeColor = function changeColor(ev) {
            tier.mergeStylesheet(mutateStylesheet(setStyleColors));
        };

        this.manipulatingTier = tier;

        var tierForm = makeElement('div', null, { className: 'tier-edit' });

        var aboutBanner = makeElement('div', "About '" + (tier.config.Name || tier.dasSource.name) + "'", null, { background: 'gray', paddingBottom: '5px', marginBottom: '5px', textAlign: 'center' });
        tierForm.appendChild(aboutBanner);

        var about = makeElement('div', [makeElement('p', tier.dasSource.desc)]);
        var aboutNotes = [];
        var sduri = sourceDataURI(tier.dasSource);
        if (sduri && (sduri.indexOf('http://') == 0 || sduri.indexOf('https://') == 0 || sduri.indexOf('//') == 0) && sduri !== 'https://www.biodalliance.org/magic/no_uri') {
            aboutNotes.push(makeElement('li', makeElement('a', '(Download data)', { href: sduri })));
        }

        if (tier.dasSource.mapping) {
            var coords = this.chains[tier.dasSource.mapping].coords;
            aboutNotes.push(makeElement('li', 'Mapped from ' + coords.auth + coords.version));
        }

        if (aboutNotes.length > 0) {
            about.appendChild(makeElement('ul', aboutNotes));
        }

        tierForm.appendChild(about);

        var semanticBanner = makeElement('span', ' (styles for current zoom level)', null, { display: 'none' });
        var editBanner = makeElement('div', ['Edit', semanticBanner], null, { background: 'gray', paddingBottom: '5px', marginBottom: '5px', textAlign: 'center' });
        tierForm.appendChild(editBanner);

        var tierNameField = makeElement('input', null, { type: 'text' });
        var tierPinnedToggle = makeElement('input', null, { type: 'checkbox', disabled: this.disablePinning });

        var glyphField = makeElement('select');
        glyphField.appendChild(makeElement('option', 'Histogram', { value: 'HISTOGRAM' }));
        glyphField.appendChild(makeElement('option', 'Line Plot', { value: 'LINEPLOT' }));
        glyphField.appendChild(makeElement('option', 'Ribbon', { value: 'GRADIENT' }));
        glyphField.appendChild(makeElement('option', 'Scatter', { value: 'SCATTER' }));

        var tierColorField = makeElement('input', null, { type: 'text', value: '#dd00dd' });
        var tierColorField2 = makeElement('input', null, { type: 'text', value: '#dd00dd' });
        var tierColorField3 = makeElement('input', null, { type: 'text', value: '#dd00dd' });

        var tierPlusColorField = makeElement('input', null, { type: 'text', value: '#ffa07a' });
        var tierMinusColorField = makeElement('input', null, { type: 'text', value: '#87cefa' });

        try {
            tierColorField.type = tierColorField2.type = tierColorField3.type = 'color';
            tierPlusColorField.type = tierMinusColorField.type = 'color';
        } catch (e) {
            // IE throws if attempt to set type to 'color'.
        }

        var tierColorFields = [tierColorField, tierColorField2, tierColorField3];
        var colorListPlus = makeElement('i', null, { className: 'fa fa-plus-circle' });
        var colorListMinus = makeElement('i', null, { className: 'fa fa-minus-circle' });
        var numColors = 1;
        var colorListElement = makeElement('td', tierColorFields);
        var setNumColors = function setNumColors(n) {
            numColors = n;
            for (var i = 0; i < n; ++i) {
                tierColorFields[i].style.display = 'block';
            }for (var i = n; i < tierColorFields.length; ++i) {
                tierColorFields[i].style.display = 'none';
            }
        };
        colorListPlus.addEventListener('click', function (ev) {
            if (numColors < 3) {
                setNumColors(numColors + 1);
                changeColor(null);
            }
        }, false);
        colorListMinus.addEventListener('click', function (ev) {
            if (numColors > 1) {
                setNumColors(numColors - 1);
                changeColor(null);
            }
        }, false);

        var tierMinField = makeElement('input', null, { type: 'text', value: '0.0' });
        var tierMaxField = makeElement('input', null, { type: 'text', value: '10.0' });
        var tierMinToggle = makeElement('input', null, { type: 'checkbox' });
        var tierMaxToggle = makeElement('input', null, { type: 'checkbox' });

        var quantLeapToggle = makeElement('input', null, { type: 'checkbox', checked: tier.quantLeapThreshold !== undefined });
        var quantLeapThreshField = makeElement('input', null, { type: 'text', value: tier.quantLeapThreshold, disabled: !quantLeapToggle.checked });

        var tierHeightField = makeElement('input', null, { type: 'text', value: '50' });

        var bumpToggle = makeElement('input', null, { type: 'checkbox' });
        var bumpLimit = makeElement('input', null, { type: 'text' });
        var labelToggle = makeElement('input', null, { type: 'checkbox' });

        var mainStyle = null;
        if (tier.stylesheet.styles.length > 0) {
            var s = mainStyle = tier.stylesheet.styles[0].style;
        }

        var refresh = function refresh() {
            if (typeof tier.config.name === 'string') tierNameField.value = tier.config.name;else tierNameField.value = tier.dasSource.name;

            tierPinnedToggle.checked = tier.pinned;

            if (tier.forceHeight) {
                tierHeightField.value = '' + tier.forceHeight;
            } else if (mainStyle && mainStyle.HEIGHT) {
                tierHeightField.value = '' + mainStyle.HEIGHT;
            }

            if (typeof tier.quantLeapThreshold == 'number') {
                quantLeapToggle.checked = true;
                quantLeapThreshField.disabled = false;
                if (parseFloat(quantLeapThreshField.value) != tier.quantLeapThreshold) quantLeapThreshField.value = tier.quantLeapThreshold;
            } else {
                quantLeapToggle.checked = false;
                quantLeapThreshField.disabled = true;
            }

            if (typeof tier.subtierMax == 'number') {
                bumpLimit.value = '' + tier.subtierMax;
            } else {
                bumpLimit.value = '' + (tier.dasSource.subtierMax || tier.browser.defaultSubtierMax);
            }

            if (tier.stylesheet.styles.length > 0) {
                var s = null;
                var isQuantitative = false,
                    isSimpleQuantitative = false;
                var ssScale = tier.browser.zoomForCurrentScale();
                var activeStyleCount = 0;

                for (var si = 0; si < tier.stylesheet.styles.length; ++si) {
                    var sh = tier.stylesheet.styles[si];
                    if (sh.zoom && sh.zoom != ssScale) {
                        continue;
                    }
                    ++activeStyleCount;
                    var ss = tier.stylesheet.styles[si].style;

                    if (!s) {
                        s = mainStyle = ss;
                    }

                    if (ss.glyph == 'LINEPLOT' || ss.glyph == 'HISTOGRAM' || ss.glyph == 'GRADIENT' || isDasBooleanTrue(ss.SCATTER)) {
                        if (!isQuantitative) s = mainStyle = ss;
                        isQuantitative = true;
                    }
                }
                if (!s) {
                    return;
                }

                semanticBanner.style.display = activeStyleCount == tier.stylesheet.styles.length ? 'none' : 'inline';

                isSimpleQuantitative = isQuantitative && activeStyleCount == 1;
                var isGradient = s.COLOR2 || s.BGGRAD;

                if (isQuantitative) {
                    minRow.style.display = 'table-row';
                    maxRow.style.display = 'table-row';
                    bumpRow.style.display = 'none';
                    labelRow.style.display = 'none';
                } else {
                    minRow.style.display = 'none';
                    maxRow.style.display = 'none';
                    bumpRow.style.display = 'table-row';
                    bumpToggle.checked = isDasBooleanTrue(mainStyle.BUMP);
                    bumpLimit.disabled = !isDasBooleanTrue(mainStyle.BUMP);
                    labelRow.style.display = 'table-row';
                    labelToggle.checked = isDasBooleanTrue(mainStyle.LABEL);
                }

                if (isSimpleQuantitative) {
                    styleRow.style.display = 'table-row';
                    colorRow.style.display = 'table-row';
                } else {
                    styleRow.style.display = 'none';
                    colorRow.style.display = 'none';
                }

                var numColors = 1;
                if (s.COLOR1) {
                    tierColorField.value = dasColourForName(s.COLOR1).toHexString();
                    if (s.COLOR2) {
                        tierColorField2.value = dasColourForName(s.COLOR2).toHexString();
                        if (s.COLOR3) {
                            tierColorField3.value = dasColourForName(s.COLOR3).toHexString();
                            numColors = 3;
                        } else {
                            numColors = 2;
                        }
                    }
                } else {
                    if (s.glyph == 'LINEPLOT' || s.glyph == 'DOT' && s.FGCOLOR) {
                        tierColorField.value = dasColourForName(s.FGCOLOR).toHexString();
                    } else if (s.BGCOLOR) {
                        tierColorField.value = dasColourForName(s.BGCOLOR).toHexString();
                    }
                }
                setNumColors(numColors);

                if (s._plusColor) tierPlusColorField.value = dasColourForName(s._plusColor).toHexString() || s._plusColor;
                if (s._minusColor) tierMinusColorField.value = dasColourForName(s._minusColor).toHexString() || s._minusColor;
                if (isDasBooleanTrue(s.SCATTER)) {
                    glyphField.value = 'SCATTER';
                } else {
                    glyphField.value = s.glyph;
                }

                var setMinValue, setMaxValue;
                if (s.MIN !== undefined) {
                    var x = parseFloat(s.MIN);
                    if (!isNaN(x)) setMinValue = x;
                }
                if (!tier.forceMinDynamic && (s.MIN !== undefined || tier.forceMin !== undefined)) {
                    tierMinToggle.checked = true;
                    tierMinField.disabled = false;
                } else {
                    tierMinToggle.checked = false;
                    tierMinField.disabled = true;
                }

                if (s.MAX !== undefined) {
                    var x = parseFloat(s.MAX);
                    if (!isNaN(x)) setMaxValue = x;
                }
                if (!tier.forceMaxDynamic && (s.MAX !== undefined || tier.forceMax !== undefined)) {
                    tierMaxToggle.checked = true;
                    tierMaxField.disabled = false;
                } else {
                    tierMaxToggle.checked = false;
                    tierMaxField.disabled = true;
                }

                if (tier.forceMin != undefined) {
                    setMinValue = tier.forceMin;
                }
                if (tier.forceMax != undefined) {
                    setMaxValue = tier.forceMax;
                }
                if (typeof setMinValue == 'number' && setMinValue != parseFloat(tierMinField.value)) {
                    tierMinField.value = setMinValue;
                }
                if (typeof setMaxValue == 'number' && setMaxValue != parseFloat(tierMaxField.value)) {
                    tierMaxField.value = setMaxValue;
                }

                var seqStyle = getSeqStyle(tier.stylesheet);
                if (seqStyle) {
                    seqMismatchRow.style.display = 'table-row';
                    seqMismatchToggle.checked = seqStyle.__SEQCOLOR === 'mismatch';
                    seqInsertRow.style.display = 'table-row';
                    seqInsertToggle.checked = isDasBooleanTrue(seqStyle.__INSERTIONS);
                    seqIgnoreQualsRow.style.display = 'table-row';
                    seqIgnoreQualsToggle.checked = seqStyle.__disableQuals === undefined || seqStyle.__disableQuals === false;
                    console.log(seqStyle.__disableQuals);
                } else {
                    seqMismatchRow.style.display = 'none';
                    seqInsertRow.style.display = 'none';
                    seqIgnoreQualsRow.style.display = 'none';
                }

                if (seqStyle && seqMismatchToggle.checked && !isSimpleQuantitative) {
                    plusStrandColorRow.style.display = 'table-row';
                    minusStrandColorRow.style.display = 'table-row';
                } else {
                    plusStrandColorRow.style.display = 'none';
                    minusStrandColorRow.style.display = 'none';
                }
            }

            if (isQuantitative && tier.browser.sourceAdapterIsCapable(tier.featureSource, 'quantLeap')) quantLeapRow.style.display = 'table-row';else quantLeapRow.style.display = 'none';
        };

        var seqMismatchToggle = makeElement('input', null, { type: 'checkbox' });
        var seqMismatchRow = makeElement('tr', [makeElement('th', 'Highlight mismatches & strands'), makeElement('td', seqMismatchToggle)]);
        seqMismatchToggle.addEventListener('change', function (ev) {
            var nss = copyStylesheet(tier.stylesheet);
            var seqStyle = getSeqStyle(nss);
            seqStyle.__SEQCOLOR = seqMismatchToggle.checked ? 'mismatch' : 'base';
            tier.mergeStylesheet(nss);
        });

        var seqInsertToggle = makeElement('input', null, { type: 'checkbox' });
        var seqInsertRow = makeElement('tr', [makeElement('th', 'Show insertions'), makeElement('td', seqInsertToggle)]);
        seqInsertToggle.addEventListener('change', function (ev) {
            var nss = copyStylesheet(tier.stylesheet);
            var seqStyle = getSeqStyle(nss);
            seqStyle.__INSERTIONS = seqInsertToggle.checked ? 'yes' : 'no';
            tier.mergeStylesheet(nss);
        });

        var seqIgnoreQualsToggle = makeElement('input', null, { type: 'checkbox' });
        var seqIgnoreQualsRow = makeElement('tr', [makeElement('th', 'Reflect base quality as base color transparency'), makeElement('td', seqIgnoreQualsToggle)]);
        seqIgnoreQualsToggle.addEventListener('change', function (ev) {
            var nss = copyStylesheet(tier.stylesheet);
            var seqStyle = getSeqStyle(nss);
            seqStyle.__disableQuals = !seqIgnoreQualsToggle.checked;
            console.log(seqStyle.__disableQuals);
            tier.mergeStylesheet(nss);
        });

        var styleRow = makeElement('tr', [makeElement('th', 'Style'), makeElement('td', glyphField)]);
        var colorRow = makeElement('tr', [makeElement('th', ['Colour(s)', colorListPlus, colorListMinus]), colorListElement]);
        var plusStrandColorRow = makeElement('tr', [makeElement('th', 'Plus Strand Color'), makeElement('td', tierPlusColorField)]);
        var minusStrandColorRow = makeElement('tr', [makeElement('th', 'Minus Strand Color'), makeElement('td', tierMinusColorField)]);
        var minRow = makeElement('tr', [makeElement('th', 'Min value'), makeElement('td', [tierMinToggle, ' ', tierMinField])]);
        var maxRow = makeElement('tr', [makeElement('th', 'Max value'), makeElement('td', [tierMaxToggle, ' ', tierMaxField])]);
        var quantLeapRow = makeElement('tr', [makeElement('th', 'Threshold leap:'), makeElement('td', [quantLeapToggle, ' ', quantLeapThreshField])]);
        var bumpRow = makeElement('tr', [makeElement('th', 'Bump overlaps'), makeElement('td', [bumpToggle, ' limit: ', bumpLimit])]);
        var labelRow = makeElement('tr', [makeElement('th', 'Label features'), makeElement('td', labelToggle)]);

        var tierTable = makeElement('table', [makeElement('tr', [makeElement('th', 'Name', {}, { width: '150px', textAlign: 'right' }), tierNameField]), makeElement('tr', [makeElement('th', 'Pin to top'), tierPinnedToggle]), makeElement('tr', [makeElement('th', 'Height'), makeElement('td', tierHeightField)]), styleRow, colorRow, plusStrandColorRow, minusStrandColorRow, minRow, maxRow, quantLeapRow, bumpRow, labelRow, seqMismatchRow, seqInsertRow, seqIgnoreQualsRow]);

        refresh();

        tierForm.appendChild(tierTable);

        var resetButton = makeElement('button', 'Reset track', { className: 'btn' }, { marginLeft: 'auto', marginRight: 'auto', display: 'block' });
        resetButton.addEventListener('click', function (ev) {
            tier.setConfig({});
        }, false);
        tierForm.appendChild(resetButton);

        tierNameField.addEventListener('input', function (ev) {
            tier.mergeConfig({ name: tierNameField.value });
        }, false);

        tierPinnedToggle.addEventListener('change', function (ev) {
            tier.mergeConfig({ pinned: tierPinnedToggle.checked });
        }, false);

        for (var ci = 0; ci < tierColorFields.length; ++ci) {
            tierColorFields[ci].addEventListener('change', changeColor, false);
        }

        tierPlusColorField.addEventListener('change', changeColor, false);
        tierMinusColorField.addEventListener('change', changeColor, false);

        glyphField.addEventListener('change', function (ev) {
            var nss = mutateStylesheet(function (ts) {
                if (glyphField.value === 'SCATTER') {
                    ts.SCATTER = true;
                    ts.glyph = 'DOT';
                    ts.SIZE = '3';
                } else {
                    ts.glyph = glyphField.value;
                    ts.SCATTER = undefined;
                }
                setStyleColors(ts);
            });
            tier.mergeStylesheet(nss);
        }, false);

        tierMinToggle.addEventListener('change', function (ev) {
            var conf = { forceMinDynamic: !tierMinToggle.checked };
            tierMinField.disabled = !tierMinToggle.checked;
            var x = parseFloat(tierMinField.value);
            if (tierMinToggle.checked && typeof x == 'number' && !isNaN(x)) conf.forceMin = parseFloat(x);
            tier.mergeConfig(conf);
        });
        tierMinField.addEventListener('input', function (ev) {
            var x = parseFloat(tierMinField.value);
            if (typeof x == 'number' && !isNaN(x)) tier.mergeConfig({ forceMin: x });
        }, false);

        tierMaxToggle.addEventListener('change', function (ev) {
            var conf = { forceMaxDynamic: !tierMaxToggle.checked };
            tierMaxField.disabled = !tierMaxToggle.checked;
            var x = parseFloat(tierMaxField.value);
            if (tierMaxToggle.checked && typeof x == 'number' && !isNaN(x)) conf.forceMax = parseFloat(x);
            tier.mergeConfig(conf);
        });
        tierMaxField.addEventListener('input', function (ev) {
            var x = parseFloat(tierMaxField.value);
            if (typeof x == 'number' && !isNaN(x)) tier.mergeConfig({ forceMax: x });
        }, false);

        tierHeightField.addEventListener('input', function (ev) {
            var x = parseFloat(tierHeightField.value);
            if (typeof x == 'number' && !isNaN(x)) tier.mergeConfig({ height: Math.min(500, x | 0) });
        }, false);

        var updateQuant = function updateQuant() {
            quantLeapThreshField.disabled = !quantLeapToggle.checked;
            if (quantLeapToggle.checked) {
                var x = parseFloat(quantLeapThreshField.value);
                if (typeof x == 'number' && !isNaN(x)) {
                    tier.mergeConfig({ quantLeapThreshold: parseFloat(quantLeapThreshField.value) });
                }
            } else {
                tier.mergeConfig({ quantLeapThreshold: null });
            }
        };
        quantLeapToggle.addEventListener('change', function (ev) {
            updateQuant();
        }, false);
        quantLeapThreshField.addEventListener('input', function (ev) {
            updateQuant();
        }, false);

        labelToggle.addEventListener('change', function (ev) {
            var nss = mutateStylesheet(function (style) {
                style.LABEL = labelToggle.checked ? 'yes' : 'no';
            });
            tier.mergeStylesheet(nss);
        }, false);
        bumpToggle.addEventListener('change', function (ev) {
            var nss = mutateStylesheet(function (style) {
                style.BUMP = bumpToggle.checked ? 'yes' : 'no';
            });
            tier.mergeStylesheet(nss);
        }, false);
        bumpLimit.addEventListener('input', function (ev) {
            var x = parseInt(bumpLimit.value);
            if (typeof x == 'number' && x > 0) {
                tier.mergeConfig({ subtierMax: x });
            }
        }, false);

        this.showToolPanel(tierForm);
        this.setUiMode('tier');

        tier.addTierListener(refresh);

        var currentScale = tier.browser.scale;
        tier.browser.addViewListener(function () {
            if (tier.browser.scale != currentScale) {
                currentScale = tier.browser.scale;
                refresh();
            }
        });
    }
};

function getSeqStyle(stylesheet) {
    for (var si = 0; si < stylesheet.styles.length; ++si) {
        var ss = stylesheet.styles[si].style;
        if (ss.glyph === '__SEQUENCE') {
            return ss;
        }
    }
}

},{"./cbrowser":6,"./color":9,"./das":10,"./sourcecompare":39,"./utils":55}],51:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// tier.js: (try) to encapsulate the functionality of a browser tier.
//

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;
    var shallowCopy = utils.shallowCopy;
    var pushnew = utils.pushnew;
    var miniJSONify = utils.miniJSONify;
    var arrayIndexOf = utils.arrayIndexOf;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;

    var sha1 = require('./sha1');
    var b64_sha1 = sha1.b64_sha1;

    var style = require('./style');
    var StyleFilter = style.StyleFilter;
    var StyleFilterSet = style.StyleFilterSet;

    var sc = require('./sourcecompare');
    var sourceDataURI = sc.sourceDataURI;

    var Promise = require('es6-promise').Promise;

    var sortFeatures = require('./features').sortFeatures;
}

var __tier_idSeed = 0;

function DasTier(browser, source, config, background) {
    var _this = this;

    this.config = config || {};
    this.id = 'tier' + ++__tier_idSeed;
    this.browser = browser;
    this.dasSource = shallowCopy(source);
    this.background = background;

    this.viewport = makeElement('canvas', null, { width: '' + ((this.browser.featurePanelWidth | 0) + 2000),
        height: "30",
        className: 'viewport_12_5' }, { position: 'inline-block',
        margin: '0px', border: '0px' });
    this.viewportHolder = makeElement('div', this.viewport, { className: 'viewport-holder_12_5' }, { background: background,
        position: 'absolute',
        padding: '0px', margin: '0px',
        border: '0px',
        left: '-1000px',
        minHeight: '200px' });
    this.overlay = makeElement('canvas', null, { width: +(this.browser.featurePanelWidth | 0),
        height: "30",
        className: 'viewport-overlay' });

    this.notifier = makeElement('div', '', { className: 'notifier' });
    this.notifierHolder = makeElement('div', this.notifier, { className: 'notifier-holder' });
    this.quantOverlay = makeElement('canvas', null, { width: '50', height: "56",
        className: 'quant-overlay' });

    this.removeButton = makeElement('i', null, { className: 'fa fa-times' });
    this.bumpButton = makeElement('i', null, { className: 'fa fa-plus-circle' });
    this.loaderButton = browser.makeLoader(16);
    this.loaderButton.style.display = 'none';
    this.infoElement = makeElement('div', this.dasSource.desc, { className: 'track-label-info' });
    this.nameButton = makeElement('div', [], { className: 'tier-tab' });
    this.nameButton.appendChild(this.removeButton);
    if (source.pennant) {
        this.nameButton.appendChild(makeElement('img', null, { src: source.pennant, width: '16', height: '16' }));
    } else if (source.mapping) {
        var version = null;
        if (this.browser.chains[source.mapping]) version = this.browser.chains[source.mapping].coords.version;
        if (version) this.nameButton.appendChild(makeElement('span', '' + version, null, { fontSize: '8pt', background: 'black', color: 'white', paddingLeft: '3px', paddingRight: '3px', paddingTop: '1px', paddingBottom: '1px', marginLeft: '2px', borderRadius: '10px' }));
    }
    this.nameElement = makeElement('span', source.name);
    this.nameButton.appendChild(makeElement('span', [this.nameElement, this.infoElement], { className: 'track-name-holder' }));
    this.nameButton.appendChild(this.bumpButton);
    this.nameButton.appendChild(this.loaderButton);

    this.label = makeElement('span', [this.nameButton], { className: 'btn-group track-label' });

    var classes = 'tier' + (source.className ? ' ' + source.className : '');
    this.row = makeElement('div', [this.viewportHolder, this.overlay, this.quantOverlay], { className: classes });

    if (!background) {
        this.row.style.background = 'none';
    }

    if (!browser.noDefaultLabels) this.row.appendChild(this.label);
    this.row.appendChild(this.notifierHolder);

    this.layoutHeight = 25;
    this.bumped = true;
    this.styleIdSeed = 0;
    if (source.quantLeapThreshold) {
        this.quantLeapThreshold = source.quantLeapThreshold;
    }
    if (this.dasSource.collapseSuperGroups) {
        this.bumped = false;
    }
    this.layoutWasDone = false;

    if (source.featureInfoPlugin) {
        this.addFeatureInfoPlugin(source.featureInfoPlugin);
    }

    this.initSources();

    var thisB = this;

    if (this.featureSource && this.featureSource.addReadinessListener) {
        this.readinessListener = function (ready) {
            thisB.notify(ready, -1);
        };
        this.featureSource.addReadinessListener(this.readinessListener);
    }

    if (this.featureSource && this.featureSource.addActivityListener) {
        this.activityListener = function (busy) {
            if (busy > 0) {
                thisB.loaderButton.style.display = 'inline-block';
            } else {
                thisB.loaderButton.style.display = 'none';
            }
            thisB.browser.pingActivity();
        };
        this.featureSource.addActivityListener(this.activityListener);
    }

    this.listeners = [];
    this.featuresLoadedListeners = [];
    this.destroyListeners = [];
    this.firstRenderPromise = new Promise(function (resolve, reject) {
        return _this._resolveFirstRenderPromise = resolve;
    });

    if (this.featureSource && this.featureSource.getDefaultFIPs && !source.noSourceFeatureInfo) {
        this.featureSource.getDefaultFIPs(function (fip) {
            if (fip) thisB.addFeatureInfoPlugin(fip);
        }, this);
    }
}

DasTier.prototype.destroy = function () {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = this.destroyListeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var handler = _step.value;

            try {
                handler(this);
            } catch (ex) {
                console.log(ex);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    if (this.featureSource.removeReadinessListener) {
        this.featureSource.removeReadinessListener(this.readinessListener);
    }
    if (this.featureSource.removeActivityListener) {
        this.featureSource.removeActivityListener(this.activityListener);
    }
};

DasTier.prototype.setBackground = function (b) {
    this.background = b;
    this.viewportHolder.style.background = b;
};

DasTier.prototype.toString = function () {
    return this.id;
};

DasTier.prototype.addFeatureInfoPlugin = function (p) {
    if (!this.featureInfoPlugins) this.featureInfoPlugins = [];
    this.featureInfoPlugins.push(p);
};

DasTier.prototype.addDescriptionContent = function (content) {
    if (typeof content === 'string') {
        content = makeElement('div', content);
    }

    this.infoElement.appendChild(content);
};

DasTier.prototype.init = function () {
    var tier = this;
    return new Promise(function (resolve, reject) {

        if (tier.dasSource.style) {
            tier.setStylesheet({ styles: tier.dasSource.style });
            resolve(tier);
        } else {
            tier.status = 'Fetching stylesheet';
            tier.fetchStylesheet(function (ss, err) {
                if (err || !ss) {
                    tier.error = 'No stylesheet';
                    var ss = new DASStylesheet();
                    var defStyle = new DASStyle();
                    defStyle.glyph = 'BOX';
                    defStyle.BGCOLOR = 'blue';
                    defStyle.FGCOLOR = 'black';
                    ss.pushStyle({ type: 'default' }, null, defStyle);
                    tier.setStylesheet(ss);
                } else {
                    tier.setStylesheet(ss);
                    if (ss.geneHint) {
                        tier.dasSource.collapseSuperGroups = true;
                        tier.bumped = false;
                        tier.updateLabel();
                    }
                    tier._updateFromConfig();
                }
                resolve(tier);
            });
        }
    });
};

DasTier.prototype.setStylesheet = function (ss) {
    this.baseStylesheet = shallowCopy(ss);
    for (var si = 0; si < this.baseStylesheet.styles.length; ++si) {
        var sh = this.baseStylesheet.styles[si] = shallowCopy(this.baseStylesheet.styles[si]);
        sh._methodRE = sh._labelRE = sh._typeRE = null;
        sh.style = shallowCopy(sh.style);
        sh.style.id = 'style' + ++this.styleIdSeed;
    }
    this.baseStylesheetValidity = b64_sha1(miniJSONify(this.baseStylesheet));
    this._updateFromConfig();
};

DasTier.prototype.getSource = function () {
    return this.featureSource;
};

DasTier.prototype.getDesiredTypes = function (scale) {
    var sfs = this.getActiveStyleFilters(scale);
    if (sfs) return sfs.typeList();
};

DasTier.prototype.getActiveStyleFilters = function (scale) {
    var ssScale = this.browser.zoomForCurrentScale();

    if (this.stylesheet) {
        var styles = new StyleFilterSet();
        var ss = this.stylesheet.styles;
        for (var si = 0; si < ss.length; ++si) {
            var sh = ss[si];
            if (!sh.zoom || sh.zoom == ssScale) {
                styles.add(new StyleFilter(sh.type, sh.method, sh.label));
            }
        }
        return styles;
    }
};

DasTier.prototype.needsSequence = function (scale) {
    var sourceConfigNeedsSeq = function sourceConfigNeedsSeq(s) {
        if (s.bamURI || s.bamBlob || s.bwgURI || s.bwgBlob) {
            return true;
        } else if (s.overlay) {
            return s.overlay.some(sourceConfigNeedsSeq);
        } else {
            return false;
        }
    };

    if (this.sequenceSource && scale < 5) {
        return true;
    } else if (sourceConfigNeedsSeq(this.dasSource) && scale < 20) {
        return true;
    }
    return false;
};

DasTier.prototype.setFeatures = function (chr, coverage, scale, features, sequence) {
    this.currentFeatures = features;
    this.currentSequence = sequence;
    this.knownChr = chr;
    this.knownCoverage = coverage;

    // only notify features loaded, if they are valid
    if (features) {
        sortFeatures(this);
        this.notifyFeaturesLoaded();
    }
};

DasTier.prototype.draw = function () {
    console.log("Use browser.getTierRenderer(tier).drawTier(tier)");
};

DasTier.prototype.findNextFeature = function (chr, pos, dir, fedge, callback) {
    if (this.quantLeapThreshold) {
        var width = this.browser.viewEnd - this.browser.viewStart + 1;
        pos = pos + width * dir / 2 | 0;
        this.featureSource.quantFindNextFeature(chr, pos, dir, this.quantLeapThreshold, callback);
    } else {
        if (this.knownCoverage && pos >= this.knownCoverage.min() && pos <= this.knownCoverage.max()) {
            if (this.currentFeatures) {
                var bestFeature = null;
                for (var fi = 0; fi < this.currentFeatures.length; ++fi) {
                    var f = this.currentFeatures[fi];
                    if (!f.min || !f.max) {
                        continue;
                    }
                    if (f.parents && f.parents.length > 0) {
                        continue;
                    }
                    if (dir < 0) {
                        if (fedge == 1 && f.max >= pos && f.min < pos) {
                            if (!bestFeature || f.min > bestFeature.min || f.min == bestFeature.min && f.max < bestFeature.max) {
                                bestFeature = f;
                            }
                        } else if (f.max < pos) {
                            if (!bestFeature || f.max > bestFeature.max || f.max == bestFeature.max && f.min < bestFeature.min || f.min == bestFeature.mmin && bestFeature.max >= pos) {
                                bestFeature = f;
                            }
                        }
                    } else {
                        if (fedge == 1 && f.min <= pos && f.max > pos) {
                            if (!bestFeature || f.max < bestFeature.max || f.max == bestFeature.max && f.min > bestFeature.min) {
                                bestFeature = f;
                            }
                        } else if (f.min > pos) {
                            if (!bestFeature || f.min < bestFeature.min || f.min == bestFeature.min && f.max > bestFeature.max || f.max == bestFeature.max && bestFeature.min <= pos) {
                                bestFeature = f;
                            }
                        }
                    }
                }
                if (bestFeature) {
                    return callback(bestFeature);
                }
                if (dir < 0) {
                    pos = this.browser.knownSpace.min;
                } else {
                    pos = this.browser.knownSpace.max;
                }
            }
        }

        this.trySourceFNF(chr, pos, dir, callback);
    }
};

DasTier.prototype.trySourceFNF = function (chr, pos, dir, callback) {
    var self = this;
    this.featureSource.findNextFeature(chr, pos, dir, function (feature) {
        if (!feature) callback(feature);

        var ss = self.browser.getSequenceSource();
        if (!ss) // We're probably in trouble, but return anyway.
            callback(feature);

        ss.getSeqInfo(feature.segment, function (si) {
            if (si) callback(feature);else self.trySourceFNF(feature.segment, dir > 0 ? 10000000000 : 0, dir, callback);
        });
    });
};

DasTier.prototype.updateLabel = function () {
    this.bumpButton.className = this.bumped ? 'fa fa-minus-circle' : 'fa fa-plus-circle';
    if (this.dasSource.collapseSuperGroups) {
        this.bumpButton.style.display = 'inline-block';
    } else {
        this.bumpButton.style.display = 'none';
    }
};

DasTier.prototype.updateHeight = function () {
    this.currentHeight = Math.max(Math.max(this.layoutHeight, this.label.clientHeight + 2), this.browser.minTierHeight);
    this.row.style.height = '' + this.currentHeight + 'px';
    this.browser.updateHeight();
};

DasTier.prototype.drawOverlay = function () {
    var t = this;
    var b = this.browser;
    var retina = b.retina && window.devicePixelRatio > 1;
    var height = t.viewport.getBoundingClientRect().height;

    t.overlay.height = retina ? height * 2 : height;
    t.overlay.width = retina ? b.featurePanelWidth * 2 : b.featurePanelWidth;

    var g = t.overlay.getContext('2d');
    if (retina) {
        g.scale(2, 2);
    }

    var origin = b.viewStart;
    var visStart = b.viewStart;
    var visEnd = b.viewEnd;

    if (this.overlayLabelCanvas) {
        var offset = (this.glyphCacheOrigin - this.browser.viewStart) * this.browser.scale;
        g.save();
        g.translate(offset, 0);
        var drawStart = -offset + 2;
        if (this.dasSource.tierGroup) drawStart += 15;
        this.overlayLabelCanvas.draw(g, drawStart, b.featurePanelWidth - offset);
        g.restore();
    }

    for (var hi = 0; hi < b.highlights.length; ++hi) {
        var h = b.highlights[hi];
        if ((h.chr === b.chr || h.chr === 'chr' + b.chr) && h.min < visEnd && h.max > visStart) {
            g.globalAlpha = b.defaultHighlightAlpha;
            g.fillStyle = b.defaultHighlightFill;
            g.fillRect((h.min - origin) * b.scale, 0, (h.max - h.min) * b.scale, t.overlay.height);
        }
    }

    // t.oorigin = b.viewStart;
    t.overlay.style.width = b.featurePanelWidth;
    t.overlay.style.height = height + 'px';
    t.overlay.style.left = '0px';
};

DasTier.prototype.updateStatus = function (status) {
    var self = this;
    if (status) {
        this.status = status;
        this._notifierToStatus();
        var sd = sourceDataURI(this.dasSource);
        if (window.location.protocol === 'https:' && sourceDataURI(this.dasSource).indexOf('http:') == 0 && !this.checkedHTTP) {
            this.checkedHTTP = true;
            this.browser.canFetchPlainHTTP().then(function (can) {
                if (!can) {
                    self.warnHTTP = true;
                    self._notifierToStatus();
                }
            });
        }
    } else {
        if (this.status) {
            this.status = null;
            this._notifierToStatus();
        }
    }
};

DasTier.prototype.notify = function (message, timeout) {
    if (typeof timeout !== 'number') timeout = 2000;

    if (this.notifierFadeTimeout) {
        clearTimeout(this.notifierFadeTimeout);
        this.notifierFadeTimeout = null;
    }

    if (message) {
        this._notifierOn(message);
        if (timeout > 0) {
            var thisB = this;
            this.notifierFadeTimeout = setTimeout(function () {
                thisB._notifierToStatus();
            }, timeout);
        }
    } else {
        this._notifierToStatus();
    }
};

DasTier.prototype._notifierOn = function (message, warnHTTP) {
    removeChildren(this.notifier);
    if (warnHTTP) {
        this.notifier.appendChild(makeElement('span', [makeElement('a', '[HTTP Warning] ', { href: this.browser.httpWarningURL, target: "_blank" }), message]));
    } else {
        this.notifier.textContent = message;
    }
    this.notifier.style.opacity = 0.8;
};

DasTier.prototype._notifierOff = function () {
    this.notifier.style.opacity = 0;
};

DasTier.prototype._notifierToStatus = function () {
    if (this.status) {
        this._notifierOn(this.status, this.warnHTTP);
    } else {
        this._notifierOff();
    }
};

DasTier.prototype.setConfig = function (config) {
    this.config = config || {};
    this._updateFromConfig();
    this.notifyTierListeners();
};

DasTier.prototype.mergeStylesheet = function (newStyle) {
    this.mergeConfig({
        stylesheet: newStyle,
        stylesheetValidity: this.baseStylesheetValidity
    });
};

DasTier.prototype.mergeConfig = function (newConfig) {
    for (var k in newConfig) {
        this.config[k] = newConfig[k];
    }
    this._updateFromConfig();
    this.notifyTierListeners();
};

DasTier.prototype._updateFromConfig = function () {
    var needsRefresh = false;
    var needsReorder = false;

    if (typeof this.config.name === 'string') this.nameElement.textContent = this.config.name;else this.nameElement.textContent = this.dasSource.name;

    var wantedHeight = this.config.height || this.dasSource.forceHeight;
    if (wantedHeight != this.forceHeight) {
        this.forceHeight = wantedHeight;
        needsRefresh = true;
    }

    if (this.forceMinDynamic != this.config.forceMinDynamic) {
        this.forceMinDynamic = this.config.forceMinDynamic;
        needsRefresh = true;
    }

    var forceMin = this.config.forceMin != undefined ? this.config.forceMin : this.dasSource.forceMin;
    if (this.forceMin != forceMin) {
        this.forceMin = forceMin;
        needsRefresh = true;
    }

    if (this.forceMaxDynamic != this.config.forceMaxDynamic) {
        this.forceMaxDynamic = this.config.forceMaxDynamic;
        needsRefresh = true;
    }

    var forceMax = this.config.forceMax != undefined ? this.config.forceMax : this.dasSource.forceMax;
    if (this.forceMax != forceMax) {
        this.forceMax = forceMax;
        needsRefresh = true;
    }

    var quantLeapThreshold = null;
    if (this.config.quantLeapThreshold !== undefined) quantLeapThreshold = this.config.quantLeapThreshold;else if (this.dasSource.quantLeapThreshold !== undefined) quantLeapThreshold = this.dasSource.quantLeapThreshold;
    if (quantLeapThreshold != this.quantLeapThreshold) {
        this.quantLeapThreshold = quantLeapThreshold;
        needsRefresh = true;
    }

    // Possible FIXME -- are there cases where style IDs need to be reassigned?
    var stylesheet = null;
    if (this.config.stylesheetValidity == this.baseStylesheetValidity) stylesheet = this.config.stylesheet;
    stylesheet = stylesheet || this.baseStylesheet;
    if (this.stylesheet !== stylesheet) {
        this.stylesheet = stylesheet;
        needsRefresh = true;
    }

    var wantedPinned = this.config.pinned !== undefined ? this.config.pinned : this.dasSource.pinned;
    if (wantedPinned !== this.pinned) {
        this.pinned = wantedPinned;
        needsReorder = true;
    }

    var wantedSubtierMax = _typeof(this.config.subtierMax === 'number') ? this.config.subtierMax : this.dasSource.subtierMax || this.browser.defaultSubtierMax;
    if (wantedSubtierMax != this.subtierMax) {
        this.subtierMax = wantedSubtierMax;
        needsRefresh = true;
    }

    var wantedBumped;
    if (this.config.bumped !== undefined) {
        wantedBumped = this.config.bumped;
    } else if (this.dasSource.bumped !== undefined) {
        wantedBumped = this.dasSource.bumped;
    } else {
        wantedBumped = this.dasSource.collapseSuperGroups ? false : true;
    }
    if (wantedBumped !== this.bumped) {
        this.bumped = wantedBumped;
        needsRefresh = true;
        this.updateLabel();
    }

    if (needsRefresh) this.scheduleRedraw();

    if (needsReorder) this.browser.reorderTiers();
};

DasTier.prototype.scheduleRedraw = function () {
    if (!this.currentFeatures) return;

    var tier = this;

    if (!this.redrawTimeout) {
        this.redrawTimeout = setTimeout(function () {
            sortFeatures(tier); // Some render actions mutate the results of this,
            // => need to re-run before refreshing.
            var renderer = tier.browser.getTierRenderer(tier);
            renderer.drawTier(tier);
            tier.redrawTimeout = null;
        }, 10);
    }
};
DasTier.prototype.clearTierListeners = function () {
    this.listeners = [];
};

DasTier.prototype.addTierListener = function (l) {
    this.listeners.push(l);
};

DasTier.prototype.removeTierListener = function (l) {
    var idx = arrayIndexOf(this.listeners, l);
    if (idx >= 0) {
        this.listeners.splice(idx, 1);
    }
};

DasTier.prototype.notifyTierListeners = function (change) {
    for (var li = 0; li < this.listeners.length; ++li) {
        try {
            this.listeners[li](change);
        } catch (e) {
            console.log(e);
        }
    }
    this.browser.notifyTier();
};

DasTier.prototype.clearFeaturesLoadedListeners = function () {
    this.featuresLoadedListeners = [];
};

DasTier.prototype.addFeaturesLoadedListener = function (handler) {
    this.featuresLoadedListeners.push(handler);
};

DasTier.prototype.removeFeaturesLoadedListener = function (handler) {
    var idx = arrayIndexOf(this.featuresLoadedListeners, handler);
    if (idx >= 0) {
        this.featuresLoadedListeners.splice(idx, 1);
    }
};

DasTier.prototype.addDestroyListener = function (handler) {
    this.destroyListeners.push(handler);
};

DasTier.prototype.removeDestroyListener = function (handler) {
    var idx = arrayIndexOf(this.destroyListeners, handler);
    if (idx >= 0) {
        this.destroyListeners.splice(idx, 1);
    }
};

DasTier.prototype.notifyFeaturesLoaded = function () {
    for (var li = 0; li < this.featuresLoadedListeners.length; ++li) {
        try {
            this.featuresLoadedListeners[li].call(this);
        } catch (e) {
            console.log(e);
        }
    }
};

DasTier.prototype.wasRendered = function () {
    this._resolveFirstRenderPromise();
};

if (typeof module !== 'undefined') {
    module.exports = {
        DasTier: DasTier
    };

    // Imported for side effects
    var fd = require('./feature-draw');
}

},{"./das":10,"./feature-draw":20,"./features":22,"./sha1":37,"./sourcecompare":39,"./style":41,"./utils":55,"es6-promise":59}],52:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// track-adder.js
//

"use strict";

if (typeof require !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var sc = require('./sourcecompare');
    var sourcesAreEqual = sc.sourcesAreEqual;

    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;
    var Observed = utils.Observed;

    var thub = require('./thub');
    var THUB_COMPARE = thub.THUB_COMPARE;
    var connectTrackHub = thub.connectTrackHub;

    var domui = require('./domui');
    var makeTreeTableSection = domui.makeTreeTableSection;

    var probeResource = require('./probe').probeResource;

    // Most of this could disappear if we leave all probing to the probe module...
    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;
    var BlobFetchable = bin.BlobFetchable;
    var readInt = bin.readInt;

    var lh3utils = require('./lh3utils');
    var unbgzf = lh3utils.unbgzf;

    var bam = require('./bam');
    var BAM_MAGIC = bam.BAM_MAGIC;
    var BAI_MAGIC = bam.BAI_MAGIC;

    var tbi = require('./tabix');
    var TABIX_MAGIC = tbi.TABIX_MAGIC;

    var das = require('./das');
    var DASSource = das.DASSource;
    var DASSegment = das.DASSegment;
    var DASRegistry = das.DASRegistry;
    var coordsMatch = das.coordsMatch;

    var EncodeFetchable = require('./encode').EncodeFetchable;
}

Browser.prototype.currentlyActive = function (source) {
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        if (sourcesAreEqual(this.tiers[ti].dasSource, source)) return this.tiers[ti];
    }
    return false;
};

Browser.prototype.makeButton = function (name, tooltip) {
    var regButton = makeElement('a', name, { href: '#' });
    if (tooltip) {
        this.makeTooltip(regButton, tooltip);
    }
    return makeElement('li', regButton);
};

function activateButton(addModeButtons, which) {
    for (var i = 0; i < addModeButtons.length; ++i) {
        var b = addModeButtons[i];
        if (b === which) {
            b.classList.add('active');
        } else {
            b.classList.remove('active');
        }
    }
}

Browser.prototype.showTrackAdder = function (ev) {
    if (this.uiMode === 'add') {
        this.hideToolPanel();
        this.setUiMode('none');
        return;
    }

    var thisB = this;

    var popup = makeElement('div', null, { className: 'dalliance' }, { width: '100%', display: 'inline-block', boxSizing: 'border-box', MozBoxSizing: 'border-box', verticalAlign: 'top', paddingRight: '15px' });

    var addModeButtons = [];
    var makeStab, makeStabObserver;

    if (!this.noRegistryTabs) {
        var regButton = this.makeButton('Registry', 'Browse compatible datasources from the DAS registry');
        addModeButtons.push(regButton);

        for (var m in this.mappableSources) {
            var mf = function mf(mm) {
                var mapButton = thisB.makeButton(thisB.chains[mm].srcTag, 'Browse datasources mapped from ' + thisB.chains[mm].srcTag);
                addModeButtons.push(mapButton);
                mapButton.addEventListener('click', function (ev) {
                    ev.preventDefault();ev.stopPropagation();
                    activateButton(addModeButtons, mapButton);
                    makeStab(thisB.mappableSources[mm], mm);
                }, false);
            };mf(m);
        }
    }

    var groupedDefaults = {};
    for (var si = 0; si < this.defaultSources.length; ++si) {
        var s = this.defaultSources[si];
        var g = s.group || 'Defaults';
        if (groupedDefaults[g]) {
            groupedDefaults[g].push(s);
        } else {
            groupedDefaults[g] = [s];
        }
    }

    var makeHubButton = function makeHubButton(tdb) {
        var hub = tdb.hub;
        var hubMenuButton = makeElement('i', null, { className: 'fa fa-list-alt' }, { cursor: 'context-menu' });
        var label = hub.altLabel || hub.shortLabel || 'Unknown';
        if (tdb.mapping) label = label + ' (' + tdb.genome + ')';
        var hbContent = makeElement('span', [label, ' ', hubMenuButton]);
        var hubButton = thisB.makeButton(hbContent, hub.longLabel);
        hubButton.hub = tdb;
        addModeButtons.push(hubButton);

        hubButton.addEventListener('click', function (ev) {
            ev.preventDefault();ev.stopPropagation();
            activateButton(addModeButtons, hubButton);
            removeChildren(stabHolder);
            var loader = thisB.makeLoader(24);
            loader.style.marginLeft = 'auto';
            loader.style.marginRight = 'auto';
            loader.style.marginTop = '100px';
            stabHolder.appendChild(makeElement('div', loader, null, { textAlign: 'center' }));

            refreshButton.style.display = 'none';
            addButton.style.display = 'none';
            canButton.style.display = 'none';

            tdb.getTracks(function (tracks, err) {
                if (err) {
                    console.log(err);
                }

                makeHubStab(tracks);
            });
        }, false);

        hubMenuButton.addEventListener('click', function (ev) {
            ev.preventDefault();ev.stopPropagation();

            var removeHubItem = makeElement('li', makeElement('a', 'Remove hub'));
            var allOnItem = makeElement('li', makeElement('a', 'Enable all'));
            var allOffItem = makeElement('li', makeElement('a', 'Disable all'));
            var hubMenu = makeElement('ul', [removeHubItem, allOnItem, allOffItem], { className: 'dropdown-menu' }, { display: 'block' });

            var mx = ev.clientX,
                my = ev.clientY;
            mx += document.documentElement.scrollLeft || document.body.scrollLeft;
            my += document.documentElement.scrollTop || document.body.scrollTop;

            hubMenu.style.position = 'absolute';
            hubMenu.style.top = '' + (my + 10) + 'px';
            hubMenu.style.left = '' + (mx - 30) + 'px';
            thisB.hPopupHolder.appendChild(hubMenu);

            var clickCatcher = function clickCatcher(ev) {
                console.log('cc');
                document.body.removeEventListener('click', clickCatcher, true);
                thisB.hPopupHolder.removeChild(hubMenu);
            };
            document.body.addEventListener('click', clickCatcher, true);

            removeHubItem.addEventListener('click', function (ev) {
                for (var hi = 0; hi < thisB.hubObjects.length; ++hi) {
                    if (thisB.hubObjects[hi].absURL == tdb.absURL) {
                        thisB.hubObjects.splice(hi, 1);
                        break;
                    }
                }
                for (var hi = 0; hi < thisB.hubs.length; ++hi) {
                    var hc = thisB.hubs[hi];
                    if (typeof hc === 'string') hc = { url: hc };
                    if (hc.url == tdb.hub.url && !hc.genome || hc.genome == tdb.genome) {
                        thisB.hubs.splice(hi, 1);
                        break;
                    }
                }

                thisB.notifyTier();

                modeButtonHolder.removeChild(hubButton);
                activateButton(addModeButtons, addHubButton);
                switchToHubConnectMode();
            }, false);

            allOnItem.addEventListener('click', function (ev) {
                tdb.getTracks(function (tracks, err) {
                    if (err) {
                        console.log(err);
                    }

                    for (var ti = 0; ti < tracks.length; ++ti) {
                        var ds = tracks[ti].toDallianceSource();
                        if (!thisB.currentlyActive(ds)) {
                            thisB.addTier(ds);
                        }
                    }
                });
            }, false);

            allOffItem.addEventListener('click', function (ev) {
                tdb.getTracks(function (tracks, err) {
                    if (err) {
                        console.log(err);
                    }

                    for (var ti = 0; ti < tracks.length; ++ti) {
                        var ds = tracks[ti].toDallianceSource();
                        if (thisB.currentlyActive(ds)) {
                            thisB.removeTier(ds);
                        }
                    }
                });
            }, false);
        }, false);

        return hubButton;
    };

    var firstDefButton = null;
    var firstDefSources = null;
    for (var g in groupedDefaults) {
        (function (g, ds) {
            var defButton = thisB.makeButton(g, 'Browse the default set of data for this browser');
            defButton.addEventListener('click', function (ev) {
                ev.preventDefault();ev.stopPropagation();
                activateButton(addModeButtons, defButton);
                makeStab(new Observed(ds));
            }, false);
            addModeButtons.push(defButton);

            if (!firstDefButton || thisB.defaultTrackAdderTab && thisB.defaultTrackAdderTab == g) {
                firstDefButton = defButton;
                firstDefSources = ds;
            }
        })(g, groupedDefaults[g]);
    }
    var custButton = this.makeButton('DAS', 'Add data using the DAS protocol');
    addModeButtons.push(custButton);
    var binButton = this.makeButton('Files', 'Add data from files on disk or the web');
    addModeButtons.push(binButton);

    for (var hi = 0; hi < this.hubObjects.length; ++hi) {
        var hub = this.hubObjects[hi];
        makeHubButton(hub);
    }

    var addHubButton = this.makeButton('+', 'Connect to a new track-hub');
    addModeButtons.push(addHubButton);

    var modeButtonHolder = makeElement('ul', addModeButtons, { className: 'nav nav-tabs' }, { marginBottom: '0px' });
    popup.appendChild(modeButtonHolder);

    var custURL, custName, custCS, custQuant, custFile, custUser, custPass;
    var customMode = false;
    var dataToFinalize = null;

    var asform = makeElement('form', null, {}, { display: 'inline-block', width: '100%' });
    asform.addEventListener('submit', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        doAdd();
        return false;
    }, true);
    var stabHolder = makeElement('div');
    stabHolder.style.position = 'relative';
    stabHolder.style.overflow = 'scroll';
    // stabHolder.style.height = '500px';
    asform.appendChild(stabHolder);

    var __mapping;
    var __sourceHolder;

    makeStab = function makeStab(msources, mapping) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'none';
        canButton.style.display = 'none';
        if (__sourceHolder) {
            __sourceHolder.removeListener(makeStabObserver);
        }
        __mapping = mapping;
        __sourceHolder = msources;
        __sourceHolder.addListenerAndFire(makeStabObserver);
    };

    makeStabObserver = function makeStabObserver(msources) {
        customMode = false;
        var buttons = [];
        removeChildren(stabHolder);
        if (!msources) {
            stabHolder.appendChild(makeElement('p', 'Dalliance was unable to retrieve data source information from the DAS registry, please try again later'));
            return;
        }

        var stabBody = makeElement('tbody', null, { className: 'table table-striped table-condensed' }, { width: '100%' });
        var stab = makeElement('table', stabBody, { className: 'table table-striped table-condensed' }, { width: '100%', tableLayout: 'fixed' });
        var idx = 0;

        var sources = [];
        for (var i = 0; i < msources.length; ++i) {
            sources.push(msources[i]);
        }

        sources.sort(function (a, b) {
            return a.name.toLowerCase().trim().localeCompare(b.name.toLowerCase().trim());
        });

        for (var i = 0; i < sources.length; ++i) {
            var source = sources[i];
            var r = makeElement('tr');

            var bd = makeElement('td', null, {}, { width: '30px' });
            bd.style.textAlign = 'center';
            if (!source.props || source.props.cors) {
                var b = makeElement('input');
                b.type = 'checkbox';
                b.dalliance_source = source;
                b.id = 'sourcecb' + i;
                if (__mapping) {
                    b.dalliance_mapping = __mapping;
                }
                // b.checked = thisB.currentlyActive(source);
                bd.appendChild(b);
                buttons.push(b);
                b.addEventListener('change', function (ev) {
                    if (ev.target.checked) {
                        thisB.addTier(ev.target.dalliance_source);
                    } else {
                        thisB.removeTier(ev.target.dalliance_source);
                    }
                });
            } else {
                bd.appendChild(document.createTextNode('!'));
                thisB.makeTooltip(bd, "This data source isn't accessible because it doesn't support CORS");
            }
            r.appendChild(bd);
            var ld = makeElement('label', null, { htmlFor: 'sourcecb' + i });
            ld.appendChild(document.createTextNode(source.name));
            if (source.desc && source.desc.length > 0) {
                thisB.makeTooltip(ld, source.desc);
            }
            r.appendChild(makeElement('td', ld));
            stabBody.appendChild(r);
            ++idx;
        }

        var setChecks = function setChecks() {
            for (var bi = 0; bi < buttons.length; ++bi) {
                var b = buttons[bi];
                var t = thisB.currentlyActive(b.dalliance_source);
                if (t) {
                    b.checked = true;
                } else {
                    b.checked = false;
                }
            }
        };
        setChecks();
        thisB.addTierListener(function (l) {
            setChecks();
        });

        stabHolder.appendChild(stab);
    };

    function makeHubStab(tracks) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'none';
        canButton.style.display = 'none';

        customMode = false;
        removeChildren(stabHolder);

        var buttonIdSeed = 0;

        var ttab = makeElement('div', null, {}, { width: '100%' });
        var sources = [];
        for (var i = 0; i < tracks.length; ++i) {
            sources.push(tracks[i]);
        }

        sources.sort(function (a, b) {
            return a.shortLabel.toLowerCase().trim().localeCompare(b.shortLabel.toLowerCase().trim());
        });

        var groups = [];
        var tops = [];

        for (var ti = 0; ti < sources.length; ++ti) {
            var track = sources[ti];
            if (track.children && track.children.length > 0 && track.container != 'multiWig') {
                groups.push(track);
            } else {
                tops.push(track);
            }
        }
        if (tops.length > 0) {
            groups.push({
                shortLabel: 'Others',
                priority: -100000000,
                children: tops });
        }

        groups.sort(THUB_COMPARE);

        var buttons = [];
        for (var gi = 0; gi < groups.length; ++gi) {
            var group = groups[gi];
            var dg = group;
            if (!dg.dimensions && dg._parent && dg._parent.dimensions) dg = dg._parent;

            var dprops = {};
            if (dg.dimensions) {
                var dtoks = dg.dimensions.split(/(\w+)=(\w+)/);
                for (var dti = 0; dti < dtoks.length - 2; dti += 3) {
                    dprops[dtoks[dti + 1]] = dtoks[dti + 2];
                }
            }

            if (dprops.dimX && dprops.dimY) {
                var dimX = dprops.dimX,
                    dimY = dprops.dimY;
                var sgX = dg.subgroups[dimX];
                var sgY = dg.subgroups[dimY];

                var trks = {};
                for (var ci = 0; ci < group.children.length; ++ci) {
                    var child = group.children[ci];
                    var vX = child.sgm[dimX],
                        vY = child.sgm[dimY];
                    if (!trks[vX]) trks[vX] = {};
                    trks[vX][vY] = child;
                }

                var matrix = makeElement('table', null, { className: 'table table-striped table-condensed' }, { tableLayout: 'fixed' });
                {
                    var header = makeElement('tr');
                    header.appendChild(makeElement('th', null, {}, { width: '150px', height: '100px' })); // blank corner element
                    for (var si = 0; si < sgX.titles.length; ++si) {
                        var h = makeElement('th', makeElement('div', sgX.titles[si], {}, { transform: 'rotate(-60deg)',
                            transformOrigin: '0% 100%',
                            webkitTransform: 'rotate(-60deg) translate(20px,10px)',
                            webkitTransformOrigin: '0% 100%',
                            textAlign: 'left' }), {}, { width: '35px',
                            height: '100px',
                            verticalAlign: 'bottom' });
                        header.appendChild(h);
                    }
                    matrix.appendChild(header);
                }

                var mbody = makeElement('tbody', null, { className: 'table table-striped table-condensed' });
                for (var yi = 0; yi < sgY.titles.length; ++yi) {
                    var vY = sgY.tags[yi];
                    var row = makeElement('tr');
                    row.appendChild(makeElement('th', sgY.titles[yi]), {});

                    for (var xi = 0; xi < sgX.titles.length; ++xi) {
                        var vX = sgX.tags[xi];
                        var cell = makeElement('td');
                        if (trks[vX] && trks[vX][vY]) {
                            var track = trks[vX][vY];
                            var ds = track.toDallianceSource();
                            if (!ds) continue;

                            var r = makeElement('tr');
                            var bd = makeElement('td');
                            bd.style.textAlign = 'center';

                            var b = makeElement('input');
                            b.type = 'checkbox';
                            b.dalliance_source = ds;
                            if (__mapping) {
                                b.dalliance_mapping = __mapping;
                            }
                            buttons.push(b);
                            cell.appendChild(b);
                            b.addEventListener('change', function (ev) {
                                if (ev.target.checked) {
                                    thisB.addTier(ev.target.dalliance_source);
                                } else {
                                    thisB.removeTier(ev.target.dalliance_source);
                                }
                            });
                        }
                        row.appendChild(cell);
                    }
                    mbody.appendChild(row);
                }
                matrix.appendChild(mbody);
                ttab.appendChild(makeTreeTableSection(group.shortLabel, matrix, thisB.noDefaultHubGroupShow ? false : gi == 0));
            } else {
                var stabBody = makeElement('tbody', null, { className: 'table table-striped table-condensed' });
                var stab = makeElement('table', stabBody, { className: 'table table-striped table-condensed' }, { width: '100%', tableLayout: 'fixed' });
                var idx = 0;

                group.children.sort(THUB_COMPARE);
                for (var i = 0; i < group.children.length; ++i) {
                    var buttonId = 'hb' + ++buttonIdSeed;

                    var track = group.children[i];
                    var ds = track.toDallianceSource();
                    if (!ds) continue;

                    var r = makeElement('tr');
                    var bd = makeElement('td', null, {}, { width: '30px' });
                    bd.style.textAlign = 'center';

                    var b = makeElement('input');
                    b.type = 'checkbox';
                    b.dalliance_source = ds;
                    b.id = buttonId;
                    if (__mapping) {
                        b.dalliance_mapping = __mapping;
                    }
                    buttons.push(b);
                    bd.appendChild(b);
                    b.addEventListener('change', function (ev) {
                        if (ev.target.checked) {
                            thisB.addTier(ev.target.dalliance_source);
                        } else {
                            thisB.removeTier(ev.target.dalliance_source);
                        }
                    });

                    r.appendChild(bd);
                    var ld = makeElement('label', null, { htmlFor: buttonId });
                    ld.appendChild(document.createTextNode(track.shortLabel));
                    if (track.longLabel && track.longLabel.length > 0) {
                        thisB.makeTooltip(ld, track.longLabel);
                    }
                    r.appendChild(makeElement('td', ld));
                    stabBody.appendChild(r);
                    ++idx;
                }

                if (groups.length > 1 || group.shortLabel !== 'Others') {
                    ttab.appendChild(makeTreeTableSection(group.shortLabel, stab, thisB.noDefaultHubGroupShow ? false : gi == 0));
                } else {
                    ttab.appendChild(stab);
                }
            }
        }

        var setChecks = function setChecks() {
            for (var bi = 0; bi < buttons.length; ++bi) {
                var b = buttons[bi];
                var t = thisB.currentlyActive(b.dalliance_source);
                if (t) {
                    b.checked = true;
                    b.disabled = t.sequenceSource != null;
                } else {
                    b.checked = false;
                }
            }
        };
        setChecks();
        thisB.addTierListener(function (l) {
            setChecks();
        });

        stabHolder.appendChild(ttab);
    }

    if (regButton) {
        regButton.addEventListener('click', function (ev) {
            ev.preventDefault();ev.stopPropagation();
            activateButton(addModeButtons, regButton);
            makeStab(thisB.availableSources);
        }, false);
    }

    binButton.addEventListener('click', function (ev) {
        ev.preventDefault();ev.stopPropagation();
        switchToBinMode();
    }, false);
    addHubButton.addEventListener('click', function (ev) {
        ev.preventDefault();ev.stopPropagation();
        switchToHubConnectMode();
    }, false);

    function switchToBinMode() {
        activateButton(addModeButtons, binButton);
        customMode = 'bin';

        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'none';

        removeChildren(stabHolder);
        var pageHolder = makeElement('div', null, {}, { paddingLeft: '10px', paddingRight: '10px' });
        pageHolder.appendChild(makeElement('h3', 'Add custom URL-based data'));
        pageHolder.appendChild(makeElement('p', ['You can add indexed binary data hosted on an web server that supports CORS (', makeElement('a', 'full details', { href: 'http://www.biodalliance.org/bin.html' }), ').  Currently supported formats are bigwig, bigbed, and indexed BAM.']));

        pageHolder.appendChild(makeElement('br'));
        pageHolder.appendChild(document.createTextNode('URL: '));
        custURL = makeElement('input', '', { size: 80, value: 'http://www.biodalliance.org/datasets/ensGene.bb' }, { width: '100%' });
        pageHolder.appendChild(custURL);

        pageHolder.appendChild(makeElement('br'));
        pageHolder.appendChild(makeElement('b', '- or -'));
        pageHolder.appendChild(makeElement('br'));
        pageHolder.appendChild(document.createTextNode('File: '));
        custFile = makeElement('input', null, { type: 'file', multiple: 'multiple' });
        pageHolder.appendChild(custFile);

        pageHolder.appendChild(makeElement('p', 'Clicking the "Add" button below will initiate a series of test queries.'));

        stabHolder.appendChild(pageHolder);
        custURL.focus();
    }

    function switchToHubConnectMode() {
        activateButton(addModeButtons, addHubButton);
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'none';

        customMode = 'hub-connect';
        refreshButton.style.visibility = 'hidden';

        removeChildren(stabHolder);

        var pageHolder = makeElement('div', null, {}, { paddingLeft: '10px', paddingRight: '10px' });
        pageHolder.appendChild(makeElement('h3', 'Connect to a track hub.'));
        pageHolder.appendChild(makeElement('p', ['Enter the top-level URL (usually points to a file called "hub.txt") of a UCSC-style track hub']));

        custURL = makeElement('input', '', { size: 120, value: 'http://www.biodalliance.org/datasets/testhub/hub.txt' }, { width: '100%' });
        pageHolder.appendChild(custURL);

        stabHolder.appendChild(pageHolder);

        custURL.focus();
    }

    custButton.addEventListener('click', function (ev) {
        ev.preventDefault();ev.stopPropagation();
        switchToCustomMode();
    }, false);

    function switchToCustomMode() {
        activateButton(addModeButtons, custButton);
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'none';

        customMode = 'das';

        removeChildren(stabHolder);

        var customForm = makeElement('div', null, {}, { paddingLeft: '10px', paddingRight: '10px' });
        customForm.appendChild(makeElement('h3', 'Add custom DAS data'));
        customForm.appendChild(makeElement('p', 'This interface is intended for adding custom or lab-specific data.  Public data can be added more easily via the registry interface.'));

        customForm.appendChild(document.createTextNode('URL: '));
        customForm.appendChild(makeElement('br'));
        custURL = makeElement('input', '', { size: 80, value: 'http://www.derkholm.net:8080/das/medipseq_reads/' }, { width: '100%' });
        customForm.appendChild(custURL);

        customForm.appendChild(makeElement('p', 'Clicking the "Add" button below will initiate a series of test queries.  If the source is password-protected, you may be prompted to enter credentials.'));
        stabHolder.appendChild(customForm);

        custURL.focus();
    }

    var addButton = makeElement('button', 'Add', { className: 'btn btn-primary' });
    addButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        doAdd();
    }, false);

    function doAdd() {
        if (customMode) {
            if (customMode === 'das') {
                var curi = custURL.value.trim();
                if (!/^.+:\/\//.exec(curi)) {
                    curi = 'http://' + curi;
                }
                var nds = new DASSource({ name: 'temporary', uri: curi });
                tryAddDAS(nds);
            } else if (customMode === 'bin') {
                var fileList = custFile.files;

                if (fileList && fileList.length > 0) {
                    tryAddMultiple(fileList);
                } else {
                    var curi = custURL.value.trim();
                    if (!/^.+:\/\//.exec(curi)) {
                        curi = 'http://' + curi;
                    }
                    var source = { uri: curi };
                    var lcuri = curi.toLowerCase();
                    if (lcuri.indexOf("https://www.encodeproject.org/") == 0 && lcuri.indexOf("@@download") >= 0) {
                        source.transport = 'encode';
                    }
                    tryAddBin(source);
                }
            } else if (customMode === 'reset') {
                switchToCustomMode();
            } else if (customMode === 'reset-bin') {
                switchToBinMode();
            } else if (customMode === 'reset-hub') {
                switchToHubConnectMode();
            } else if (customMode === 'prompt-bai') {
                var fileList = custFile.files;
                if (fileList && fileList.length > 0 && fileList[0]) {
                    dataToFinalize.baiBlob = fileList[0];
                    completeBAM(dataToFinalize);
                } else {
                    promptForBAI(dataToFinalize);
                }
            } else if (customMode === 'prompt-tbi') {
                var fileList = custFile.files;
                if (fileList && fileList.length > 0 && fileList[0]) {
                    dataToFinalize.indexBlob = fileList[0];
                    completeTabixVCF(dataToFinalize);
                } else {
                    promptForTabix(dataToFinalize);
                }
            } else if (customMode === 'finalize' || customMode === 'finalize-bin') {
                dataToFinalize.name = custName.value;
                var m = custCS.value;
                if (m != '__default__') {
                    dataToFinalize.mapping = m;
                } else {
                    dataToFinalize.mapping = undefined;
                }
                if (custQuant) {
                    dataToFinalize.maxbins = custQuant.checked;
                }

                if (custUser.value.length > 1 && custPass.value.length > 1) {
                    dataToFinalize.xUser = custUser.value;
                    dataToFinalize.xPass = custPass.value;
                }

                thisB.addTier(dataToFinalize);

                if (customMode == 'finalize-bin') switchToBinMode();else switchToCustomMode();
            } else if (customMode === 'hub-connect') {
                var curi = custURL.value.trim();
                if (!/^.+:\/\//.exec(curi)) {
                    curi = 'http://' + curi;
                }

                tryAddHub(curi);
            } else if (customMode === 'multiple') {
                for (var mi = 0; mi < multipleSet.length; ++mi) {
                    var s = multipleSet[mi];
                    if (s.hidden) continue;

                    if (s.tier_type == 'bam' && !s.indexBlob && !s.indexUri) continue;
                    if (s.tier_type == 'tabix' && !s.indexBlob && !s.indexUri) continue;

                    var nds = makeSourceConfig(s);
                    if (nds) {
                        nds.noPersist = true;
                        thisB.addTier(nds);
                    }
                }

                switchToBinMode();
            }
        } else {
            thisB.removeAllPopups();
        }
    };

    function tryAddHub(curi, opts, retry) {
        opts = opts || {};
        for (var hi = 0; hi < thisB.hubObjects.length; ++hi) {
            var h = thisB.hubObjects[hi];
            if (h.hub.url == curi) {
                for (var bi = 0; bi < addModeButtons.length; ++bi) {
                    if (addModeButtons[bi].hub == h) {
                        activateButton(addModeButtons, addModeButtons[bi]);
                    }
                }
                h.getTracks(function (tracks, err) {
                    if (err) {
                        console.log(err);
                    }
                    makeHubStab(tracks);
                });
                return;
            }
        }

        connectTrackHub(curi, function (hub, err) {
            if (err) {
                if (!retry) {
                    return tryAddHub(curi, { credentials: true }, true);
                }
                removeChildren(stabHolder);
                stabHolder.appendChild(makeElement('h2', 'Error connecting to track hub'));
                stabHolder.appendChild(makeElement('p', err));
                customMode = 'reset-hub';
                return;
            } else {
                var bestHub = null;
                var bestHubButton = null;
                for (var genome in hub.genomes) {
                    var mapping = null;
                    var okay = false;

                    if (genome == thisB.coordSystem.ucscName) {
                        okay = true;
                    } else {
                        for (var mid in thisB.chains) {
                            var m = thisB.chains[mid];
                            if (genome == m.coords.ucscName) {
                                mapping = mid;
                                okay = true;
                            }
                        }
                    }

                    if (okay) {
                        var hc = { url: curi, genome: genome };
                        if (opts.credentials) hc.credentials = true;
                        if (mapping) {
                            hc.mapping = mapping;
                            hub.genomes[genome].mapping = mapping;
                        }
                        thisB.hubs.push(hc);
                        thisB.hubObjects.push(hub.genomes[genome]);

                        var hubButton = makeHubButton(hub.genomes[genome]);
                        modeButtonHolder.appendChild(hubButton);

                        if (!mapping || !bestHub) {
                            bestHub = hub.genomes[genome];
                            bestHubButton = hubButton;
                        }
                    }
                }

                if (bestHub) {
                    thisB.notifyTier();
                    activateButton(addModeButtons, bestHubButton);
                    bestHub.getTracks(function (tracks, err) {
                        makeHubStab(tracks);
                    });
                } else {
                    removeChildren(stabHolder);
                    stabHolder.appendChild(makeElement('h2', 'No data for this genome'));
                    stabHolder.appendChild(makeElement('p', 'This URL appears to be a valid track-hub, but it doesn\'t contain any data for the coordinate system of this browser'));
                    stabHolder.appendChild(makeElement('p', 'coordSystem.ucscName = ' + thisB.coordSystem.ucscName));
                    customMode = 'reset-hub';
                    return;
                }
            }
        }, opts);
    }

    var tryAddDAS = function tryAddDAS(nds, retry) {
        var knownSpace = thisB.knownSpace;
        if (!knownSpace) {
            alert("Can't confirm track-addition to an uninit browser.");
            return;
        }
        var tsm = Math.max(knownSpace.min, (knownSpace.min + knownSpace.max - 100) / 2) | 0;
        var testSegment = new DASSegment(knownSpace.chr, tsm, Math.min(tsm + 99, knownSpace.max));
        nds.features(testSegment, {}, function (features, status) {
            if (status) {
                if (!retry) {
                    nds.credentials = true;
                    tryAddDAS(nds, true);
                } else {
                    removeChildren(stabHolder);
                    stabHolder.appendChild(makeElement('h2', 'Custom data not found'));
                    stabHolder.appendChild(makeElement('p', 'DAS uri: ' + nds.uri + ' is not answering features requests'));
                    customMode = 'reset';
                    return;
                }
            } else {
                var nameExtractPattern = new RegExp('/([^/]+)/?$');
                var match = nameExtractPattern.exec(nds.uri);
                if (match) {
                    nds.name = match[1];
                }

                tryAddDASxSources(nds);
                return;
            }
        });
    };

    function tryAddDASxSources(nds, retry) {
        var uri = nds.uri;
        if (retry) {
            var match = /(.+)\/[^\/]+\/?/.exec(uri);
            if (match) {
                uri = match[1] + '/sources';
            }
        }
        function sqfail() {
            if (!retry) {
                return tryAddDASxSources(nds, true);
            } else {
                return addDasCompletionPage(nds);
            }
        }
        new DASRegistry(uri, { credentials: nds.credentials }).sources(function (sources) {
            if (!sources || sources.length == 0) {
                return sqfail();
            }

            var fs = null;
            if (sources.length == 1) {
                fs = sources[0];
            } else {
                for (var i = 0; i < sources.length; ++i) {
                    if (sources[i].uri === nds.uri) {
                        fs = sources[i];
                        break;
                    }
                }
            }

            var coordsDetermined = false,
                quantDetermined = false;
            if (fs) {
                nds.name = fs.name;
                nds.desc = fs.desc;
                if (fs.maxbins) {
                    nds.maxbins = true;
                } else {
                    nds.maxbins = false;
                }
                if (fs.capabilities) {
                    nds.capabilities = fs.capabilities;
                }
                quantDetermined = true;

                if (fs.coords && fs.coords.length == 1) {
                    var coords = fs.coords[0];
                    if (coordsMatch(coords, thisB.coordSystem)) {
                        coordsDetermined = true;
                    } else if (thisB.chains) {
                        for (var k in thisB.chains) {
                            if (coordsMatch(coords, thisB.chains[k].coords)) {
                                nds.mapping = k;
                                coordsDetermined = true;
                            }
                        }
                    }
                }
            }
            return addDasCompletionPage(nds, coordsDetermined, quantDetermined);
        }, function () {
            return sqfail();
        });
    }

    var makeSourceConfig = function makeSourceConfig(s) {
        var nds = { name: s.name };
        if (s.credentials) nds.credentials = s.credentials;

        if (s.mapping && s.mapping != '__default__') nds.mapping = s.mapping;

        if (s.transport) nds.transport = s.transport;

        if (s.tier_type == 'bwg') {
            if (s.blob) nds.bwgBlob = s.blob;else if (s.uri) nds.bwgURI = s.uri;
            return nds;
        } else if (s.tier_type == 'bam') {
            if (s.blob) {
                nds.bamBlob = s.blob;
                nds.baiBlob = s.indexBlob;
            } else {
                nds.bamURI = s.uri;
                nds.baiURI = s.indexUri;
            }
            return nds;
        } else if (s.tier_type == 'tabix') {
            nds.tier_type = 'tabix';
            nds.payload = s.payload;
            if (s.blob) {
                nds.blob = s.blob;
                nds.indexBlob = s.indexBlob;
            } else {
                nds.uri = s.uri;
                nds.indexUri = s.indexUri;
            }
            return nds;
        } else if (s.tier_type == 'memstore') {
            nds.tier_type = 'memstore';
            nds.payload = s.payload;
            if (s.blob) nds.blob = s.blob;else nds.uri = s.uri;
            return nds;
        }
    };

    var tryAddBin = function tryAddBin(source) {
        probeResource(source, function (source, err) {
            if (err) {
                removeChildren(stabHolder);
                var tabError = makeElement('div');
                tabError.appendChild(makeElement('h2', "Couldn't access custom data"));
                tabError.appendChild(makeElement('p', '' + err));
                stabHolder.appendChild(tabError);
                console.log(source);
                if (window.location.protocol === 'https:' && source.uri.indexOf('http:') == 0) {
                    thisB.canFetchPlainHTTP().then(function (can) {
                        if (!can) {
                            tabError.appendChild(makeElement('p', [makeElement('strong', 'HTTP warning: '), 'you may not be able to access HTTP resources from an instance of Biodalliance which you are accessing via HTTPS.', makeElement('a', '[More info]', { href: thisB.httpWarningURL, target: "_blank" })]));
                        }
                    });
                }
                customMode = 'reset-bin';
            } else {
                var nds = makeSourceConfig(source);
                if (source.tier_type == 'bam') {
                    return completeBAM(nds);
                } else if (source.tier_type == 'tabix') {
                    return completeTabixVCF(nds);
                } else {
                    return addDasCompletionPage(nds, false, false, true);
                }
            }
        });
    };

    function promptForBAI(nds) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'inline';

        removeChildren(stabHolder);
        customMode = 'prompt-bai';
        stabHolder.appendChild(makeElement('h2', 'Select an index file'));
        stabHolder.appendChild(makeElement('p', 'Dalliance requires a BAM index (.bai) file when displaying BAM data.  These normally accompany BAM files.  For security reasons, web applications like Dalliance can only access local files which you have explicity selected.  Please use the file chooser below to select the appropriate BAI file'));

        stabHolder.appendChild(document.createTextNode('Index file: '));
        custFile = makeElement('input', null, { type: 'file' });
        stabHolder.appendChild(custFile);
        dataToFinalize = nds;
    }

    function promptForTabix(nds) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'inline';

        removeChildren(stabHolder);
        customMode = 'prompt-tbi';
        stabHolder.appendChild(makeElement('h2', 'Select an index file'));
        stabHolder.appendChild(makeElement('p', 'Dalliance requires a Tabix index (.tbi) file when displaying VCF data.  For security reasons, web applications like Dalliance can only access local files which you have explicity selected.  Please use the file chooser below to select the appropriate BAI file'));

        stabHolder.appendChild(document.createTextNode('Index file: '));
        custFile = makeElement('input', null, { type: 'file' });
        stabHolder.appendChild(custFile);
        dataToFinalize = nds;
    }

    function completeBAM(nds) {
        var indexF;
        if (nds.baiBlob) indexF = new BlobFetchable(nds.baiBlob);else if (nds.transport == 'encode') indexF = new EncodeFetchable(nds.bamURI + '.bai');else indexF = new URLFetchable(nds.bamURI + '.bai', { credentials: nds.credentials });

        indexF.slice(0, 256).fetch(function (r) {
            var hasBAI = false;
            if (r) {
                var ba = new Uint8Array(r);
                var magic2 = readInt(ba, 0);
                hasBAI = magic2 == BAI_MAGIC;
            }
            if (hasBAI) {
                return addDasCompletionPage(nds, false, false, true);
            } else {
                return binFormatErrorPage('You have selected a valid BAM file, but a corresponding index (.bai) file was not found.  Please index your BAM (samtools index) and place the BAI file in the same directory');
            }
        });
    }

    function completeTabixVCF(nds) {
        var indexF;
        if (nds.indexBlob) {
            indexF = new BlobFetchable(nds.indexBlob);
        } else {
            indexF = new URLFetchable(nds.uri + '.tbi');
        }
        indexF.slice(0, 1 << 16).fetch(function (r) {
            var hasTabix = false;
            if (r) {
                var ba = new Uint8Array(r);
                if (ba[0] == 31 || ba[1] == 139) {
                    var unc = unbgzf(r);
                    ba = new Uint8Array(unc);
                    var m2 = readInt(ba, 0);
                    hasTabix = m2 == TABIX_MAGIC;
                }
            }
            if (hasTabix) {
                return addDasCompletionPage(nds, false, false, true);
            } else {
                return binFormatErrorPage('You have selected a valid VCF file, but a corresponding index (.tbi) file was not found.  Please index your VCF ("tabix -p vcf -f myfile.vcf.gz") and place the .tbi file in the same directory');
            }
        });
    }

    function binFormatErrorPage(message) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'inline';

        removeChildren(stabHolder);
        message = message || 'Custom data format not recognized';
        stabHolder.appendChild(makeElement('h2', 'Error adding custom data'));
        stabHolder.appendChild(makeElement('p', message));
        stabHolder.appendChild(makeElement('p', 'Currently supported formats are bigBed, bigWig, and BAM.'));
        customMode = 'reset-bin';
        return;
    }

    var addDasCompletionPage = function addDasCompletionPage(nds, coordsDetermined, quantDetermined, quantIrrelevant) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'inline';

        removeChildren(stabHolder);
        stabHolder.appendChild(makeElement('h2', 'Add custom data: step 2'));
        stabHolder.appendChild(document.createTextNode('Label: '));
        custName = makeElement('input', '', { value: nds.name });
        stabHolder.appendChild(custName);

        // stabHolder.appendChild(document.createTextNode('User: '));
        custUser = makeElement('input', '');
        // stabHolder.appendChild(custUser);
        //stabHolder.appendChild(document.createTextNode('Pass: '));
        custPass = makeElement('input', '');
        // stabHolder.appendChild(custPass);


        stabHolder.appendChild(makeElement('br'));
        stabHolder.appendChild(makeElement('br'));
        stabHolder.appendChild(makeElement('h4', 'Coordinate system: '));
        custCS = makeElement('select', null);
        custCS.appendChild(makeElement('option', thisB.nameForCoordSystem(thisB.coordSystem), { value: '__default__' }));
        if (thisB.chains) {
            for (var csk in thisB.chains) {
                var cs = thisB.chains[csk].coords;
                custCS.appendChild(makeElement('option', thisB.nameForCoordSystem(cs), { value: csk }));
            }
        }
        custCS.value = nds.mapping || '__default__';
        stabHolder.appendChild(custCS);

        if (coordsDetermined) {
            stabHolder.appendChild(makeElement('p', "(Based on server response, probably doesn't need changing.)"));
        } else {
            stabHolder.appendChild(makeElement('p', [makeElement('b', 'Warning: '), "unable to determine the correct value from server responses.  Please check carefully."]));
            stabHolder.appendChild(makeElement('p', "If you don't see the mapping you're looking for, please contact thomas@biodalliance.org"));
        }

        if (!quantIrrelevant) {
            stabHolder.appendChild(document.createTextNode('Quantitative: '));
            custQuant = makeElement('input', null, { type: 'checkbox', checked: true });
            if (typeof nds.maxbins !== 'undefined') {
                custQuant.checked = nds.maxbins;
            }
            stabHolder.appendChild(custQuant);
            if (quantDetermined) {
                stabHolder.appendChild(makeElement('p', "(Based on server response, probably doesn't need changing.)"));
            } else {
                stabHolder.appendChild(makeElement('p', [makeElement('b', "Warning: "), "unable to determine correct value.  If in doubt, leave checked."]));
            }
        }

        if (nds.bwgBlob) {
            stabHolder.appendChild(makeElement('p', [makeElement('b', 'Warning: '), 'data added from local file.  Due to the browser security model, the track will disappear if you reload Dalliance.']));
        }

        custName.focus();

        if (customMode === 'bin' || customMode === 'prompt-bai' || customMode === 'prompt-tbi') customMode = 'finalize-bin';else customMode = 'finalize';
        dataToFinalize = nds;
    };

    var multipleSet = null;
    var tryAddMultiple = function tryAddMultiple(fileList) {
        var newSources = multipleSet = [];
        customMode = 'multiple';
        for (var fi = 0; fi < fileList.length; ++fi) {
            var f = fileList[fi];
            if (f) {
                newSources.push({ blob: f });
            }
        }

        for (var fi = 0; fi < newSources.length; ++fi) {
            probeMultiple(newSources[fi]);
        }
        updateMultipleStatus();
    };

    var probeMultiple = function probeMultiple(ns) {
        probeResource(ns, function (source, err) {
            if (err) {
                source.error = err;
                console.log(err);
            }

            var usedIndices = [];
            var bams = {},
                tabixes = {};
            for (var si = 0; si < multipleSet.length; ++si) {
                var s = multipleSet[si];
                if (s.tier_type == 'bam' && !s.indexBlob) {
                    bams[s.blob.name] = s;
                }
                if (s.tier_type == 'tabix' && !s.indexBlob) {
                    tabixes[s.blob.name] = s;
                }
            }

            for (var si = 0; si < multipleSet.length; ++si) {
                var s = multipleSet[si];
                if (s.tier_type === 'bai') {
                    var baiPattern = new RegExp('(.+)\\.bai$');
                    var match = baiPattern.exec(s.blob.name);
                    if (match && bams[match[1]]) {
                        bams[match[1]].indexBlob = s.blob;
                        usedIndices.push(si);
                    }
                } else if (s.tier_type === 'tabix-index') {
                    var tbiPattern = new RegExp('(.+)\\.tbi$');
                    var match = tbiPattern.exec(s.blob.name);
                    if (match && tabixes[match[1]]) {
                        tabixes[match[1]].indexBlob = s.blob;
                        usedIndices.push(si);
                    }
                }
            }

            for (var bi = usedIndices.length - 1; bi >= 0; --bi) {
                multipleSet.splice(usedIndices[bi], 1);
            }

            updateMultipleStatus();
        });
    };

    var updateMultipleStatus = function updateMultipleStatus() {
        removeChildren(stabHolder);
        var needsIndex = false;
        var multTable = makeElement('table', multipleSet.filter(function (s) {
            return !s.hidden;
        }).map(function (s) {
            var row = makeElement('tr');
            row.appendChild(makeElement('td', s.name || s.blob.name));
            var typeContent;
            if (s.error) {
                typeContent = makeElement('span', 'Error', null, { color: 'red' });
            } else if (s.tier_type) {
                typeContent = s.payload || s.tier_type;
            } else {
                typeContent = thisB.makeLoader(16);
            }

            var ccs;
            var state = 'unknown';
            if (s.tier_type == 'bwg' || s.tier_type == 'memstore') {
                state = 'okay';
            } else if (s.tier_type == 'bam') {
                state = s.indexBlob ? 'okay' : 'needs-index';
            } else if (s.tier_type == 'tabix') {
                state = s.indexBlob ? 'okay' : 'needs-index';
            }

            if (state == 'okay') {
                ccs = makeElement('select', null, null, { width: '150px' });
                ccs.appendChild(makeElement('option', thisB.nameForCoordSystem(thisB.coordSystem), { value: '__default__' }));
                if (thisB.chains) {
                    for (var csk in thisB.chains) {
                        var cs = thisB.chains[csk].coords;
                        ccs.appendChild(makeElement('option', thisB.nameForCoordSystem(cs), { value: csk }));
                    }
                }
                ccs.value = s.mapping || '__default__';

                ccs.addEventListener('change', function (ev) {
                    s.mapping = ccs.value;
                    console.log(s);
                }, false);
            } else if (state == 'needs-index') {
                ccs = makeElement('span', 'Needs index', {}, { color: 'red' });
                needsIndex = true;
            }

            return makeElement('tr', [makeElement('td', s.name || s.blob.name), makeElement('td', typeContent), makeElement('td', ccs)]);
        }), { className: 'table table-striped table-condensed' });
        stabHolder.appendChild(multTable);

        if (needsIndex) {
            stabHolder.appendChild(makeElement('p', 'Some of these files are missing required index (.bai or .tbi) files.  For security reasons, web applications like Dalliance can only access local files which you have explicity selected.  Please use the file chooser below to select the appropriate index file'));
            stabHolder.appendChild(document.createTextNode('Index file(s): '));
            var indexFile = makeElement('input', null, { type: 'file', multiple: 'multiple' });
            stabHolder.appendChild(indexFile);
            indexFile.addEventListener('change', function (ev) {
                console.log('fileset changed');
                var fileList = indexFile.files || [];
                for (var fi = 0; fi < fileList.length; ++fi) {
                    var f = fileList[fi];
                    if (f) {
                        var ns = { blob: f, hidden: true };
                        multipleSet.push(ns);
                        probeMultiple(ns);
                    }
                }
            }, false);
        }
    };

    var canButton = makeElement('button', 'Cancel', { className: 'btn' });
    canButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        if (customMode === 'finalize-bin') switchToBinMode();else switchToCustomMode();
    }, false);

    var refreshButton = makeElement('button', 'Refresh', { className: 'btn' });
    refreshButton.addEventListener('click', function (ev) {
        ev.stopPropagation();ev.preventDefault();
        thisB.queryRegistry(__mapping);
    }, false);
    this.makeTooltip(refreshButton, 'Click to re-fetch data from the DAS registry');

    var buttonHolder = makeElement('div', [addButton, ' ', canButton, ' ', refreshButton]);
    buttonHolder.style.margin = '10px';
    asform.appendChild(buttonHolder);

    popup.appendChild(asform);
    makeStab(thisB.availableSources);

    this.showToolPanel(popup);
    this.setUiMode('add');

    if (firstDefButton) {
        activateButton(addModeButtons, firstDefButton);
        makeStab(new Observed(firstDefSources));
    }
};

},{"./bam":1,"./bin":4,"./cbrowser":6,"./das":10,"./domui":12,"./encode":14,"./lh3utils":26,"./probe":31,"./sourcecompare":39,"./tabix":46,"./thub":48,"./utils":55}],53:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// trix.js: UCSC-style free text indices
//

"use strict";

function connectTrix(ix, ixx, callback) {
    ixx.fetchAsText(function (ixxData) {
        if (!ixxData) return callback(null, "Couldn't fetch index-index");

        var toks = ixxData.split(/(.+)([0-9A-F]{10})\n/);

        var keys = [];
        var offsets = [];
        for (var ti = 1; ti < toks.length; ti += 3) {
            keys.push(toks[ti]);
            offsets.push(parseInt(toks[ti + 1], 16));
        }

        return callback(new TrixIndex(keys, offsets, ix));
    });
}

function TrixIndex(keys, offsets, ix) {
    this.keys = keys;
    this.offsets = offsets;
    this.ix = ix;
}

TrixIndex.prototype.lookup = function (query, callback) {
    var ixslice;

    var qtag = (query + '     ').substring(0, 5).toLowerCase();
    for (var i = 0; i < this.keys.length; ++i) {
        if (qtag.localeCompare(this.keys[i]) < 0) {
            ixslice = this.ix.slice(this.offsets[i - 1], this.offsets[i] - this.offsets[i - 1]);
            break;
        }
    }

    if (!ixslice) {
        ixslice = this.ix.slice(this.offsets[this.offsets.length - 1]);
    }

    ixslice.fetchAsText(function (ist) {
        var lines = ist.split('\n');
        for (var li = 0; li < lines.length; ++li) {
            if (lines[li].indexOf(query.toLowerCase() + ' ') == 0) {
                return callback(lines[li].split(' '));
            }
        }
        return callback(null);
    });
};

if (typeof module !== 'undefined') {
    module.exports = {
        connectTrix: connectTrix
    };
}

},{}],54:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// twoBit.js: packed-binary reference sequences
//

"use strict";

if (typeof require !== 'undefined') {
    var bin = require('./bin');
    var readInt = bin.readInt;
    var readIntBE = bin.readIntBE;
    var readInt64BE = bin.readInt64BE,
        readInt64LE = bin.readInt64LE;

    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;
}

var TWOBIT_MAGIC = 0x1a412743;
var TWOBIT_MAGIC_BE = 0x4327411a;
var HEADER_BLOCK_SIZE = 12500;

function TwoBitFile() {}

function makeTwoBit(fetchable, cnt) {
    var tb = new TwoBitFile();
    tb.data = fetchable;
    var headerBlockSize = HEADER_BLOCK_SIZE;
    var headerBlocksFetched = 0;

    tb.data.slice(0, headerBlockSize).fetch(function (r) {
        if (!r) {
            return cnt(null, "Couldn't access data");
        }
        var ba = new Uint8Array(r);
        var magic = readInt(ba, 0);
        if (magic == TWOBIT_MAGIC) {
            tb.readInt = readInt;
            tb.readInt64 = readInt64LE;
        } else if (magic == TWOBIT_MAGIC_BE) {
            tb.readInt = readIntBE;
            tb.readInt64 = readInt64BE;
        } else {
            return cnt(null, "Not a .2bit file, magic=0x" + magic.toString(16));
        }

        tb.version = tb.readInt(ba, 4);
        if (tb.version < 0 || tb.version > 1) {
            return cnt(null, 'Unsupported version ' + tb.version);
        }

        tb.seqCount = tb.readInt(ba, 8);
        tb.seqDict = {};

        var p = 16,
            i = 0;
        var o = 0; // Offset of the current block if we need to fetch multiple header blocks.

        var parseSeqInfo = function parseSeqInfo() {
            while (i < tb.seqCount) {
                var ns = ba[p];
                if (p + ns + 2 + (tb.version == 0 ? 4 : 8) >= ba.length) {
                    headerBlocksFetched += headerBlockSize;
                    headerBlockSize = Math.max(HEADER_BLOCK_SIZE, Math.floor(headerBlocksFetched * tb.seqCount / i));
                    return tb.data.slice(o + p, headerBlockSize).fetch(function (r) {
                        o += p;
                        p = 0;
                        ba = new Uint8Array(r);
                        parseSeqInfo();
                    });
                } else {
                    ++p;
                    var name = '';
                    for (var j = 1; j <= ns; ++j) {
                        name += String.fromCharCode(ba[p++]);
                    }
                    if (tb.version == 0) {
                        var offset = tb.readInt(ba, p);
                        p += 4;
                    } else {
                        var offset = tb.readInt64(ba, p);
                        p += 8;
                    }
                    tb.seqDict[name] = new TwoBitSeq(tb, offset);
                    ++i;
                }
            }
            return cnt(tb);
        };

        parseSeqInfo();
    });
}

TwoBitFile.prototype.getSeq = function (chr) {
    var seq = this.seqDict[chr];
    if (!seq) {
        seq = this.seqDict['chr' + chr];
    }
    return seq;
};

TwoBitFile.prototype.fetch = function (chr, min, max, cnt) {
    var seq = this.getSeq(chr);
    if (!seq) {
        return cnt(null, "Couldn't find " + chr);
    } else if (max <= min) {
        return cnt('');
    } else {
        seq.fetch(min, max, cnt);
    }
};

function TwoBitSeq(tbf, offset) {
    this.tbf = tbf;
    this.offset = offset;
}

TwoBitSeq.prototype.init = function (cnt) {
    if (this.seqOffset) {
        return cnt();
    }

    var thisB = this;
    thisB.tbf.data.slice(thisB.offset, 8).fetch(function (r1) {
        if (!r1) {
            return cnt('Fetch failed');
        }
        var ba = new Uint8Array(r1);
        thisB._length = thisB.tbf.readInt(ba, 0);
        thisB.nBlockCnt = thisB.tbf.readInt(ba, 4);
        thisB.tbf.data.slice(thisB.offset + 8, thisB.nBlockCnt * 8 + 4).fetch(function (r2) {
            if (!r2) {
                return cnt('Fetch failed');
            }
            var ba = new Uint8Array(r2);
            var nbs = null;
            for (var b = 0; b < thisB.nBlockCnt; ++b) {
                var nbMin = thisB.tbf.readInt(ba, b * 4);
                var nbLen = thisB.tbf.readInt(ba, (b + thisB.nBlockCnt) * 4);
                var nb = new Range(nbMin, nbMin + nbLen - 1);
                if (!nbs) {
                    nbs = nb;
                } else {
                    nbs = union(nbs, nb);
                }
            }
            thisB.nBlocks = nbs;
            thisB.mBlockCnt = thisB.tbf.readInt(ba, thisB.nBlockCnt * 8);
            thisB.seqLength = (thisB._length + 3) / 4 | 0;
            thisB.seqOffset = thisB.offset + 16 + (thisB.nBlockCnt + thisB.mBlockCnt) * 8;
            return cnt();
        });
    });
};

var TWOBIT_TABLE = ['T', 'C', 'A', 'G'];

TwoBitSeq.prototype.fetch = function (min, max, cnt) {
    --min;--max; // Switch to zero-based.
    var thisB = this;
    this.init(function (error) {
        if (error) {
            return cnt(null, error);
        }

        var fetchMin = min >> 2;
        var fetchMax = max + 3 >> 2;
        if (fetchMin < 0 || fetchMax > thisB.seqLength) {
            return cnt('Coordinates out of bounds: ' + min + ':' + max);
        }

        thisB.tbf.data.slice(thisB.seqOffset + fetchMin, fetchMax - fetchMin).salted().fetch(function (r) {
            if (r == null) {
                return cnt('SeqFetch failed');
            }
            var seqData = new Uint8Array(r);

            var nSpans = [];
            if (thisB.nBlocks) {
                var intr = intersection(new Range(min, max), thisB.nBlocks);
                if (intr) {
                    nSpans = intr.ranges();
                }
            }

            var seqstr = '';
            var ptr = min;
            function fillSeq(fsm) {
                while (ptr <= fsm) {
                    var bb = (ptr >> 2) - fetchMin;
                    var ni = ptr & 0x3;
                    var bv = seqData[bb];
                    var n;
                    if (ni == 0) {
                        n = bv >> 6 & 0x3;
                    } else if (ni == 1) {
                        n = bv >> 4 & 0x3;
                    } else if (ni == 2) {
                        n = bv >> 2 & 0x3;
                    } else {
                        n = bv & 0x3;
                    }
                    seqstr += TWOBIT_TABLE[n];
                    ++ptr;
                }
            }

            for (var b = 0; b < nSpans.length; ++b) {
                var nb = nSpans[b];
                if (ptr > nb.min()) {
                    throw 'N mismatch...';
                }
                if (ptr < nb.min()) {
                    fillSeq(nb.min() - 1);
                }
                while (ptr <= nb.max()) {
                    seqstr += 'N';
                    ++ptr;
                }
            }
            if (ptr <= max) {
                fillSeq(max);
            }
            return cnt(seqstr);
        });
    });
};

TwoBitSeq.prototype.length = function (cnt) {
    var thisB = this;
    this.init(function (error) {
        if (error) {
            return cnt(null, error);
        } else {
            return cnt(thisB._length);
        }
    });
};

if (typeof module !== 'undefined') {
    module.exports = {
        makeTwoBit: makeTwoBit
    };
}

},{"./bin":4,"./spans":40}],55:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// utils.js: odds, sods, and ends.
//

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (typeof require !== 'undefined') {
    var sha1 = require('./sha1');
    var b64_sha1 = sha1.b64_sha1;
}

var NUM_REGEXP = new RegExp('[0-9]+');

function stringToNumbersArray(str) {
    var nums = new Array();
    var m;
    while (m = NUM_REGEXP.exec(str)) {
        nums.push(m[0]);
        str = str.substring(m.index + m[0].length);
    }
    return nums;
}

var STRICT_NUM_REGEXP = new RegExp('^[0-9]+$');

function stringToInt(str) {
    str = str.replace(new RegExp(',', 'g'), '');
    if (!STRICT_NUM_REGEXP.test(str)) {
        return null;
    }
    return str | 0;
}

function pushnew(a, v) {
    for (var i = 0; i < a.length; ++i) {
        if (a[i] == v) {
            return;
        }
    }
    a.push(v);
}

function pusho(obj, k, v) {
    if (obj[k]) {
        obj[k].push(v);
    } else {
        obj[k] = [v];
    }
}

function pushnewo(obj, k, v) {
    var a = obj[k];
    if (a) {
        for (var i = 0; i < a.length; ++i) {
            // indexOf requires JS16 :-(.
            if (a[i] == v) {
                return;
            }
        }
        a.push(v);
    } else {
        obj[k] = [v];
    }
}

function pick(a, b, c, d) {
    if (a) {
        return a;
    } else if (b) {
        return b;
    } else if (c) {
        return c;
    } else if (d) {
        return d;
    }
}

function pushnew(l, o) {
    for (var i = 0; i < l.length; ++i) {
        if (l[i] == o) {
            return;
        }
    }
    l.push(o);
}

function arrayEquals(a, b) {
    if (!a || !b || a.length !== b.length) return false;

    for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i]) return false;
    }

    return true;
}

function arrayIndexOf(a, x) {
    if (!a) {
        return -1;
    }

    for (var i = 0; i < a.length; ++i) {
        if (a[i] === x) {
            return i;
        }
    }
    return -1;
}

function arrayRemove(a, x) {
    var i = arrayIndexOf(a, x);
    if (i >= 0) {
        a.splice(i, 1);
        return true;
    }
    return false;
}

//
// DOM utilities
//


function makeElement(tag, children, attribs, styles) {
    var ele = document.createElement(tag);
    if (children) {
        if (!(children instanceof Array)) {
            children = [children];
        }
        for (var i = 0; i < children.length; ++i) {
            var c = children[i];
            if (c) {
                if (typeof c == 'string') {
                    c = document.createTextNode(c);
                } else if (typeof c == 'number') {
                    c = document.createTextNode('' + c);
                }
                ele.appendChild(c);
            }
        }
    }

    if (attribs) {
        for (var l in attribs) {
            try {
                ele[l] = attribs[l];
            } catch (e) {
                console.log('error setting ' + l);
                throw e;
            }
        }
    }
    if (styles) {
        for (var l in styles) {
            ele.style[l] = styles[l];
        }
    }
    return ele;
}

function makeElementNS(namespace, tag, children, attribs) {
    var ele = document.createElementNS(namespace, tag);
    if (children) {
        if (!(children instanceof Array)) {
            children = [children];
        }
        for (var i = 0; i < children.length; ++i) {
            var c = children[i];
            if (typeof c == 'string') {
                c = document.createTextNode(c);
            }
            ele.appendChild(c);
        }
    }

    setAttrs(ele, attribs);
    return ele;
}

var attr_name_cache = {};

function setAttr(node, key, value) {
    var attr = attr_name_cache[key];
    if (!attr) {
        var _attr = '';
        for (var c = 0; c < key.length; ++c) {
            var cc = key.substring(c, c + 1);
            var lcc = cc.toLowerCase();
            if (lcc != cc) {
                _attr = _attr + '-' + lcc;
            } else {
                _attr = _attr + cc;
            }
        }
        attr_name_cache[key] = _attr;
        attr = _attr;
    }
    node.setAttribute(attr, value);
}

function setAttrs(node, attribs) {
    if (attribs) {
        for (var l in attribs) {
            setAttr(node, l, attribs[l]);
        }
    }
}

function removeChildren(node) {
    if (!node || !node.childNodes) {
        return;
    }

    while (node.childNodes.length > 0) {
        node.removeChild(node.firstChild);
    }
}

//
// WARNING: not for general use!
//

function miniJSONify(o, exc) {
    if (typeof o === 'undefined') {
        return 'undefined';
    } else if (o == null) {
        return 'null';
    } else if (typeof o == 'string') {
        return "'" + o + "'";
    } else if (typeof o == 'number') {
        return "" + o;
    } else if (typeof o == 'boolean') {
        return "" + o;
    } else if ((typeof o === 'undefined' ? 'undefined' : _typeof(o)) == 'object') {
        if (o instanceof Array) {
            var s = null;
            for (var i = 0; i < o.length; ++i) {
                s = (s == null ? '' : s + ', ') + miniJSONify(o[i], exc);
            }
            return '[' + (s ? s : '') + ']';
        } else {
            exc = exc || {};
            var s = null;
            for (var k in o) {
                if (exc[k]) continue;
                if (k != undefined && typeof o[k] != 'function') {
                    s = (s == null ? '' : s + ', ') + k + ': ' + miniJSONify(o[k], exc);
                }
            }
            return '{' + (s ? s : '') + '}';
        }
    } else {
        return typeof o === 'undefined' ? 'undefined' : _typeof(o);
    }
}

function shallowCopy(o) {
    var n = {};
    for (var k in o) {
        n[k] = o[k];
    }
    return n;
}

function Observed(x) {
    this.value = x;
    this.listeners = [];
}

Observed.prototype.addListener = function (f) {
    this.listeners.push(f);
};

Observed.prototype.addListenerAndFire = function (f) {
    this.listeners.push(f);
    f(this.value);
};

Observed.prototype.removeListener = function (f) {
    arrayRemove(this.listeners, f);
};

Observed.prototype.get = function () {
    return this.value;
};

Observed.prototype.set = function (x) {
    this.value = x;
    for (var i = 0; i < this.listeners.length; ++i) {
        this.listeners[i](x);
    }
};

function Awaited() {
    this.queue = [];
}

Awaited.prototype.provide = function (x) {
    if (this.res !== undefined) {
        throw "Resource has already been provided.";
    }

    this.res = x;
    for (var i = 0; i < this.queue.length; ++i) {
        this.queue[i](x);
    }
    this.queue = null; // avoid leaking closures.
};

Awaited.prototype.await = function (f) {
    if (this.res !== undefined) {
        f(this.res);
        return this.res;
    } else {
        this.queue.push(f);
    }
};

var __dalliance_saltSeed = 0;

function saltURL(url) {
    return url + '?salt=' + b64_sha1('' + Date.now() + ',' + ++__dalliance_saltSeed);
}

function textXHR(url, callback, opts) {
    if (opts && opts.salt) url = saltURL(url);

    try {
        var timeout;
        if (opts && opts.timeout) {
            timeout = setTimeout(function () {
                console.log('timing out ' + url);
                req.abort();
                return callback(null, 'Timeout');
            }, opts.timeout);
        }

        var req = new XMLHttpRequest();
        req.onreadystatechange = function () {
            if (req.readyState == 4) {
                if (timeout) clearTimeout(timeout);
                if (req.status < 200 || req.status >= 300) {
                    callback(null, 'Error code ' + req.status);
                } else {
                    callback(req.responseText);
                }
            }
        };

        req.open('GET', url, true);
        req.responseType = 'text';

        if (opts && opts.credentials) {
            req.withCredentials = true;
        }
        req.send();
    } catch (e) {
        callback(null, 'Exception ' + e);
    }
}

function relativeURL(base, rel) {
    // FIXME quite naive -- good enough for trackhubs?

    if (rel.indexOf('http:') === 0 || rel.indexOf('https:') === 0 || rel.indexOf('ftp:') === 0) {
        return rel;
    }

    var li = base.lastIndexOf('/');
    if (li >= 0) {
        return base.substr(0, li + 1) + rel;
    } else {
        return rel;
    }
}

var AMINO_ACID_TRANSLATION = {
    'TTT': 'F',
    'TTC': 'F',
    'TTA': 'L',
    'TTG': 'L',
    'CTT': 'L',
    'CTC': 'L',
    'CTA': 'L',
    'CTG': 'L',
    'ATT': 'I',
    'ATC': 'I',
    'ATA': 'I',
    'ATG': 'M',
    'GTT': 'V',
    'GTC': 'V',
    'GTA': 'V',
    'GTG': 'V',
    'TCT': 'S',
    'TCC': 'S',
    'TCA': 'S',
    'TCG': 'S',
    'CCT': 'P',
    'CCC': 'P',
    'CCA': 'P',
    'CCG': 'P',
    'ACT': 'T',
    'ACC': 'T',
    'ACA': 'T',
    'ACG': 'T',
    'GCT': 'A',
    'GCC': 'A',
    'GCA': 'A',
    'GCG': 'A',
    'TAT': 'Y',
    'TAC': 'Y',
    'TAA': '*', // stop
    'TAG': '*', // stop
    'CAT': 'H',
    'CAC': 'H',
    'CAA': 'Q',
    'CAG': 'Q',
    'AAT': 'N',
    'AAC': 'N',
    'AAA': 'K',
    'AAG': 'K',
    'GAT': 'D',
    'GAC': 'D',
    'GAA': 'E',
    'GAG': 'E',
    'TGT': 'C',
    'TGC': 'C',
    'TGA': '*', // stop
    'TGG': 'W',
    'CGT': 'R',
    'CGC': 'R',
    'CGA': 'R',
    'CGG': 'R',
    'AGT': 'S',
    'AGC': 'S',
    'AGA': 'R',
    'AGG': 'R',
    'GGT': 'G',
    'GGC': 'G',
    'GGA': 'G',
    'GGG': 'G'
};

function resolveUrlToPage(rel) {
    return makeElement('a', null, { href: rel }).href;
}

//
// Missing APIs
// 

if (!('trim' in String.prototype)) {
    String.prototype.trim = function () {
        return this.replace(/^\s+/, '').replace(/\s+$/, '');
    };
}

if (typeof module !== 'undefined') {
    module.exports = {
        textXHR: textXHR,
        relativeURL: relativeURL,
        resolveUrlToPage: resolveUrlToPage,
        shallowCopy: shallowCopy,
        pusho: pusho,
        pushnew: pushnew,
        pushnewo: pushnewo,
        arrayIndexOf: arrayIndexOf,
        arrayEquals: arrayEquals,
        pick: pick,

        makeElement: makeElement,
        makeElementNS: makeElementNS,
        removeChildren: removeChildren,

        miniJSONify: miniJSONify,

        Observed: Observed,
        Awaited: Awaited,

        AMINO_ACID_TRANSLATION: AMINO_ACID_TRANSLATION
    };
}

},{"./sha1":37}],56:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// vcf.js
//

"use strict";

if (typeof require !== 'undefined') {
    var sa = require('./sourceadapters');
    var dalliance_registerParserFactory = sa.registerParserFactory;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;
}

function VCFParser() {
    this.info = [];
}

var VCF_INFO_RE = /([^;=]+)(=([^;]+))?;?/;
var VCF_INFO_HEADER = /##INFO=<([^>]+)>/;
var VCF_INFO_HEADER_TOK = /([^,=]+)=([^,]+|"[^"]+"),?/;

VCFParser.prototype.createSession = function (sink) {
    return new VCFParseSession(this, sink);
};

function VCFParseSession(parser, sink) {
    this.parser = parser;
    this.sink = sink;
}

VCFParseSession.prototype.parse = function (line) {
    if (line.length == 0) return;
    if (line[0] == '#') {
        if (line.length > 1 && line[1] == '#') {
            var m = VCF_INFO_HEADER.exec(line);
            if (m) {
                var toks = m[1].split(VCF_INFO_HEADER_TOK);
                var id = null,
                    desc = null;
                for (var ti = 0; ti < toks.length - 1; ti += 3) {
                    var key = toks[ti + 1];
                    var value = toks[ti + 2].replace(/"/g, '');
                    if (key == 'ID') {
                        id = value;
                    } else if (key == 'Description') {
                        desc = value;
                    }
                }
                if (id && desc) {
                    this.parser.info.push({ id: id,
                        desc: desc });
                }
            }
            return;
        } else {
            return;
        }
    }

    var toks = line.split('\t');
    var f = new DASFeature();
    f.segment = toks[0];
    f.id = toks[2];
    f.refAllele = toks[3];
    f.altAlleles = toks[4].split(',');
    f.min = parseInt(toks[1]);
    f.max = f.min + f.refAllele.length - 1;

    var infoToks = toks[7].split(VCF_INFO_RE);
    f.info = {};
    for (var ti = 0; ti < infoToks.length; ti += 4) {
        f.info[infoToks[ti + 1]] = infoToks[ti + 3];
    }

    var alt = f.altAlleles[0];
    var ref = f.refAllele;
    if (alt.length > ref.length) {
        f.type = "insertion";
        if (alt.indexOf(ref) == 0) {
            f.insertion = alt.substr(ref.length);
            f.min += ref.length;
            f.max = f.min - 1; // Effectively "between" bases.
        } else {
            f.insertion = alt;
        }
    } else if (alt.length < ref.length) {
        f.type = "deletion";
    } else {
        f.type = 'substitution';
    }

    this.sink(f);
};

VCFParseSession.prototype.flush = function () {};

VCFParser.prototype.getStyleSheet = function (callback) {
    var stylesheet = new DASStylesheet();

    {
        var varStyle = new DASStyle();
        varStyle.glyph = '__INSERTION';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.FGCOLOR = 'rgb(50,80,255)';
        varStyle.BGCOLOR = '#888888';
        varStyle.STROKECOLOR = 'black';
        stylesheet.pushStyle({ type: 'insertion' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'PLIMSOLL';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.FGCOLOR = 'rgb(255, 60, 60)';
        varStyle.BGCOLOR = '#888888';
        varStyle.STROKECOLOR = 'black';
        stylesheet.pushStyle({ type: 'deletion' }, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'PLIMSOLL';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.FGCOLOR = 'rgb(50,80,255)';
        varStyle.BGCOLOR = '#888888';
        varStyle.STROKECOLOR = 'black';
        stylesheet.pushStyle({ type: 'default' }, null, varStyle);
    }

    return callback(stylesheet);
};

VCFParser.prototype.getDefaultFIPs = function (callback) {
    var self = this;
    var fip = function fip(feature, featureInfo) {
        featureInfo.add("Ref. allele", feature.refAllele);
        featureInfo.add("Alt. alleles", feature.altAlleles.join(','));

        if (feature.info) {
            for (var ii = 0; ii < self.info.length; ++ii) {
                var info = self.info[ii];
                var val = feature.info[info.id];
                if (val !== undefined) {
                    featureInfo.add(info.desc, val);
                }
            }
        }
    };
    callback(fip);
};

dalliance_registerParserFactory('vcf', function () {
    return new VCFParser();
});

},{"./das":10,"./sourceadapters":38}],57:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// version.js
//

"use strict";

var VERSION = {
    CONFIG: 5,
    MAJOR: 0,
    MINOR: 13,
    MICRO: 7,
    BRANCH: 'dev'
};

VERSION.toString = function () {
    var vs = '' + this.MAJOR + '.' + this.MINOR + '.' + this.MICRO;
    if (this.PATCH) {
        vs = vs + this.PATCH;
    }
    if (this.BRANCH && this.BRANCH != '') {
        vs = vs + '-' + this.BRANCH;
    }
    return vs;
};

if (typeof module !== 'undefined') {
    module.exports = VERSION;
}

},{}],58:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// zoomslider.js: custom slider component
//


"use strict";

if (typeof require !== 'undefined') {
    var utils = require('./utils');
    var makeElement = utils.makeElement;
}

function makeZoomSlider(opts) {
    opts = opts || {};

    var minPos = 0,
        maxPos = opts.width || 200;
    var min = 0,
        max = 200;
    var pos = 50,
        pos2 = 100;
    var labels = [];
    var track = makeElement('hr', null, { className: 'slider-track' }, { width: '' + (maxPos | 0) + 'px' });
    var thumb = makeElement('hr', null, { className: 'slider-thumb active' });
    var thumb2 = makeElement('hr', null, { className: 'slider-thumb' });
    var slider = makeElement('div', [track, thumb, thumb2], { className: 'slider' }, { width: '' + ((maxPos | 0) + 10) + 'px' });

    slider.removeLabels = function () {
        for (var li = 0; li < labels.length; ++li) {
            slider.removeChild(labels[li]);
        }
        labels = [];
    };

    slider.addLabel = function (val, txt) {
        var pos = minPos + (val - min) * (maxPos - minPos) / (max - min) | 0;
        var label = makeElement('div', txt, { className: 'slider-label' }, {
            left: '' + (minPos + (val - min) * (maxPos - minPos) / (max - min) | 0) + 'px'
        });
        slider.appendChild(label);
        labels.push(label);
    };

    var onChange = document.createEvent('HTMLEvents');
    onChange.initEvent('change', true, false);

    function setPos(np) {
        np = Math.min(np, maxPos);
        np = Math.max(np, minPos);
        pos = np;
        thumb.style.left = '' + pos + 'px';
    }

    function setPos2(np) {
        np = Math.min(np, maxPos);
        np = Math.max(np, minPos);
        pos2 = np;
        thumb2.style.left = '' + pos2 + 'px';
    }

    Object.defineProperty(slider, 'value', {
        get: function get() {
            return min + (pos - minPos) * (max - min) / (maxPos - minPos);
        },
        set: function set(v) {
            var np = minPos + (v - min) * (maxPos - minPos) / (max - min);
            setPos(np);
        }
    });

    Object.defineProperty(slider, 'value2', {
        get: function get() {
            return min + (pos2 - minPos) * (max - min) / (maxPos - minPos);
        },
        set: function set(v) {
            var np = minPos + (v - min) * (maxPos - minPos) / (max - min);
            setPos2(np);
        }
    });

    Object.defineProperty(slider, 'active', {
        get: function get() {
            return thumb.classList.contains('active') ? 1 : 2;
        },
        set: function set(x) {
            if (x == 1) {
                thumb.classList.add('active');
                thumb2.classList.remove('active');
            } else {
                thumb2.classList.add('active');
                thumb.classList.remove('active');
            }
        }
    });

    Object.defineProperty(slider, 'min', {
        get: function get() {
            return min;
        },
        set: function set(v) {
            min = v;
        }
    });

    Object.defineProperty(slider, 'max', {
        get: function get() {
            return max;
        },
        set: function set(v) {
            max = v;
        }
    });

    var offset;
    var which;

    var thumbMouseDown = function thumbMouseDown(ev) {
        which = this == thumb ? 1 : 2;
        if (which != slider.active) {
            slider.active = which;
            slider.dispatchEvent(onChange);
        }
        ev.stopPropagation();ev.preventDefault();
        window.addEventListener('mousemove', thumbDragHandler, false);
        window.addEventListener('mouseup', thumbDragEndHandler, false);
        offset = ev.clientX - (which == 1 ? pos : pos2);
    };

    thumb.addEventListener('mousedown', thumbMouseDown, false);
    thumb2.addEventListener('mousedown', thumbMouseDown, false);

    var thumbDragHandler = function thumbDragHandler(ev) {
        if (which == 1) setPos(ev.clientX - offset);else setPos2(ev.clientX - offset);
        slider.dispatchEvent(onChange);
    };

    var thumbDragEndHandler = function thumbDragEndHandler(ev) {
        window.removeEventListener('mousemove', thumbDragHandler, false);
        window.removeEventListener('mouseup', thumbDragEndHandler, false);
    };

    return slider;
}

if (typeof module !== 'undefined') {
    module.exports = makeZoomSlider;
}

},{"./utils":55}],59:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   3.0.2
 */

(function() {
    "use strict";
    function lib$es6$promise$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$es6$promise$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$es6$promise$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$es6$promise$utils$$_isArray;
    if (!Array.isArray) {
      lib$es6$promise$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$es6$promise$utils$$_isArray = Array.isArray;
    }

    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
    var lib$es6$promise$asap$$len = 0;
    var lib$es6$promise$asap$$toString = {}.toString;
    var lib$es6$promise$asap$$vertxNext;
    var lib$es6$promise$asap$$customSchedulerFn;

    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
      lib$es6$promise$asap$$len += 2;
      if (lib$es6$promise$asap$$len === 2) {
        // If len is 2, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        if (lib$es6$promise$asap$$customSchedulerFn) {
          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
        } else {
          lib$es6$promise$asap$$scheduleFlush();
        }
      }
    }

    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
    }

    function lib$es6$promise$asap$$setAsap(asapFn) {
      lib$es6$promise$asap$$asap = asapFn;
    }

    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$es6$promise$asap$$useNextTick() {
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // see https://github.com/cujojs/when/issues/410 for details
      return function() {
        process.nextTick(lib$es6$promise$asap$$flush);
      };
    }

    // vertx
    function lib$es6$promise$asap$$useVertxTimer() {
      return function() {
        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
      };
    }

    function lib$es6$promise$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$es6$promise$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$es6$promise$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$es6$promise$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$es6$promise$asap$$flush, 1);
      };
    }

    var lib$es6$promise$asap$$queue = new Array(1000);
    function lib$es6$promise$asap$$flush() {
      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
        var callback = lib$es6$promise$asap$$queue[i];
        var arg = lib$es6$promise$asap$$queue[i+1];

        callback(arg);

        lib$es6$promise$asap$$queue[i] = undefined;
        lib$es6$promise$asap$$queue[i+1] = undefined;
      }

      lib$es6$promise$asap$$len = 0;
    }

    function lib$es6$promise$asap$$attemptVertx() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$es6$promise$asap$$useVertxTimer();
      } catch(e) {
        return lib$es6$promise$asap$$useSetTimeout();
      }
    }

    var lib$es6$promise$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$es6$promise$asap$$isNode) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
    } else if (lib$es6$promise$asap$$isWorker) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
    } else {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }

    function lib$es6$promise$$internal$$noop() {}

    var lib$es6$promise$$internal$$PENDING   = void 0;
    var lib$es6$promise$$internal$$FULFILLED = 1;
    var lib$es6$promise$$internal$$REJECTED  = 2;

    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$selfFulfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function lib$es6$promise$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$es6$promise$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
        return lib$es6$promise$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
       lib$es6$promise$asap$$asap(function(promise) {
        var sealed = false;
        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$es6$promise$$internal$$resolve(promise, value);
          } else {
            lib$es6$promise$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$es6$promise$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$es6$promise$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, thenable._result);
      } else {
        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = lib$es6$promise$$internal$$getThen(maybeThenable);

        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$es6$promise$utils$$isFunction(then)) {
          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$es6$promise$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
      } else {
        lib$es6$promise$$internal$$fulfill(promise, value);
      }
    }

    function lib$es6$promise$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      lib$es6$promise$$internal$$publish(promise);
    }

    function lib$es6$promise$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$es6$promise$$internal$$FULFILLED;

      if (promise._subscribers.length !== 0) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
      }
    }

    function lib$es6$promise$$internal$$reject(promise, reason) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
      promise._state = lib$es6$promise$$internal$$REJECTED;
      promise._result = reason;

      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
    }

    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onerror = null;

      subscribers[length] = child;
      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
      }
    }

    function lib$es6$promise$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$es6$promise$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$es6$promise$$internal$$tryCatch(callback, detail);

        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$es6$promise$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$es6$promise$$internal$$reject(promise, error);
      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, value);
      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, value);
      }
    }

    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$es6$promise$$internal$$reject(promise, e);
      }
    }

    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
      var enumerator = this;

      enumerator._instanceConstructor = Constructor;
      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (enumerator._validateInput(input)) {
        enumerator._input     = input;
        enumerator.length     = input.length;
        enumerator._remaining = input.length;

        enumerator._init();

        if (enumerator.length === 0) {
          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
        } else {
          enumerator.length = enumerator.length || 0;
          enumerator._enumerate();
          if (enumerator._remaining === 0) {
            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
          }
        }
      } else {
        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
      }
    }

    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return lib$es6$promise$utils$$isArray(input);
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;

    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
      var enumerator = this;

      var length  = enumerator.length;
      var promise = enumerator.promise;
      var input   = enumerator._input;

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        enumerator._eachEntry(input[i], i);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var enumerator = this;
      var c = enumerator._instanceConstructor;

      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
          entry._onerror = null;
          enumerator._settledAt(entry._state, i, entry._result);
        } else {
          enumerator._willSettleAt(c.resolve(entry), i);
        }
      } else {
        enumerator._remaining--;
        enumerator._result[i] = entry;
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var enumerator = this;
      var promise = enumerator.promise;

      if (promise._state === lib$es6$promise$$internal$$PENDING) {
        enumerator._remaining--;

        if (state === lib$es6$promise$$internal$$REJECTED) {
          lib$es6$promise$$internal$$reject(promise, value);
        } else {
          enumerator._result[i] = value;
        }
      }

      if (enumerator._remaining === 0) {
        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
      });
    };
    function lib$es6$promise$promise$all$$all(entries) {
      return new lib$es6$promise$enumerator$$default(this, entries).promise;
    }
    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
    function lib$es6$promise$promise$race$$race(entries) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (!lib$es6$promise$utils$$isArray(entries)) {
        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$es6$promise$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$es6$promise$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
    function lib$es6$promise$promise$resolve$$resolve(object) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
    function lib$es6$promise$promise$reject$$reject(reason) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

    var lib$es6$promise$promise$$counter = 0;

    function lib$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function lib$es6$promise$promise$$Promise(resolver) {
      this._id = lib$es6$promise$promise$$counter++;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if (lib$es6$promise$$internal$$noop !== resolver) {
        if (!lib$es6$promise$utils$$isFunction(resolver)) {
          lib$es6$promise$promise$$needsResolver();
        }

        if (!(this instanceof lib$es6$promise$promise$$Promise)) {
          lib$es6$promise$promise$$needsNew();
        }

        lib$es6$promise$$internal$$initializePromise(this, resolver);
      }
    }

    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

    lib$es6$promise$promise$$Promise.prototype = {
      constructor: lib$es6$promise$promise$$Promise,

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection) {
        var parent = this;
        var state = parent._state;

        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
          return this;
        }

        var child = new this.constructor(lib$es6$promise$$internal$$noop);
        var result = parent._result;

        if (state) {
          var callback = arguments[state - 1];
          lib$es6$promise$asap$$asap(function(){
            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    function lib$es6$promise$polyfill$$polyfill() {
      var local;

      if (typeof global !== 'undefined') {
          local = global;
      } else if (typeof self !== 'undefined') {
          local = self;
      } else {
          try {
              local = Function('return this')();
          } catch (e) {
              throw new Error('polyfill failed because global object is unavailable in this environment');
          }
      }

      var P = local.Promise;

      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
        return;
      }

      local.Promise = lib$es6$promise$promise$$default;
    }
    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

    var lib$es6$promise$umd$$ES6Promise = {
      'Promise': lib$es6$promise$promise$$default,
      'polyfill': lib$es6$promise$polyfill$$default
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$es6$promise$umd$$ES6Promise; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
    }

    lib$es6$promise$polyfill$$default();
}).call(this);


}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":61}],60:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Javascript ZLib
// By Thomas Down 2010-2011
//
// Based very heavily on portions of jzlib (by ymnk@jcraft.com), who in
// turn credits Jean-loup Gailly and Mark Adler for the original zlib code.
//
// inflate.js: ZLib inflate code
//

//
// Shared constants
//

var MAX_WBITS=15; // 32K LZ77 window
var DEF_WBITS=MAX_WBITS;
var MAX_MEM_LEVEL=9;
var MANY=1440;
var BMAX = 15;

// preset dictionary flag in zlib header
var PRESET_DICT=0x20;

var Z_NO_FLUSH=0;
var Z_PARTIAL_FLUSH=1;
var Z_SYNC_FLUSH=2;
var Z_FULL_FLUSH=3;
var Z_FINISH=4;

var Z_DEFLATED=8;

var Z_OK=0;
var Z_STREAM_END=1;
var Z_NEED_DICT=2;
var Z_ERRNO=-1;
var Z_STREAM_ERROR=-2;
var Z_DATA_ERROR=-3;
var Z_MEM_ERROR=-4;
var Z_BUF_ERROR=-5;
var Z_VERSION_ERROR=-6;

var METHOD=0;   // waiting for method byte
var FLAG=1;     // waiting for flag byte
var DICT4=2;    // four dictionary check bytes to go
var DICT3=3;    // three dictionary check bytes to go
var DICT2=4;    // two dictionary check bytes to go
var DICT1=5;    // one dictionary check byte to go
var DICT0=6;    // waiting for inflateSetDictionary
var BLOCKS=7;   // decompressing blocks
var CHECK4=8;   // four check bytes to go
var CHECK3=9;   // three check bytes to go
var CHECK2=10;  // two check bytes to go
var CHECK1=11;  // one check byte to go
var DONE=12;    // finished check, done
var BAD=13;     // got an error--stay here

var inflate_mask = [0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff];

var IB_TYPE=0;  // get type bits (3, including end bit)
var IB_LENS=1;  // get lengths for stored
var IB_STORED=2;// processing stored block
var IB_TABLE=3; // get table lengths
var IB_BTREE=4; // get bit lengths tree for a dynamic block
var IB_DTREE=5; // get length, distance trees for a dynamic block
var IB_CODES=6; // processing fixed or dynamic block
var IB_DRY=7;   // output remaining window bytes
var IB_DONE=8;  // finished last block, done
var IB_BAD=9;   // ot a data error--stuck here

var fixed_bl = 9;
var fixed_bd = 5;

var fixed_tl = [
    96,7,256, 0,8,80, 0,8,16, 84,8,115,
    82,7,31, 0,8,112, 0,8,48, 0,9,192,
    80,7,10, 0,8,96, 0,8,32, 0,9,160,
    0,8,0, 0,8,128, 0,8,64, 0,9,224,
    80,7,6, 0,8,88, 0,8,24, 0,9,144,
    83,7,59, 0,8,120, 0,8,56, 0,9,208,
    81,7,17, 0,8,104, 0,8,40, 0,9,176,
    0,8,8, 0,8,136, 0,8,72, 0,9,240,
    80,7,4, 0,8,84, 0,8,20, 85,8,227,
    83,7,43, 0,8,116, 0,8,52, 0,9,200,
    81,7,13, 0,8,100, 0,8,36, 0,9,168,
    0,8,4, 0,8,132, 0,8,68, 0,9,232,
    80,7,8, 0,8,92, 0,8,28, 0,9,152,
    84,7,83, 0,8,124, 0,8,60, 0,9,216,
    82,7,23, 0,8,108, 0,8,44, 0,9,184,
    0,8,12, 0,8,140, 0,8,76, 0,9,248,
    80,7,3, 0,8,82, 0,8,18, 85,8,163,
    83,7,35, 0,8,114, 0,8,50, 0,9,196,
    81,7,11, 0,8,98, 0,8,34, 0,9,164,
    0,8,2, 0,8,130, 0,8,66, 0,9,228,
    80,7,7, 0,8,90, 0,8,26, 0,9,148,
    84,7,67, 0,8,122, 0,8,58, 0,9,212,
    82,7,19, 0,8,106, 0,8,42, 0,9,180,
    0,8,10, 0,8,138, 0,8,74, 0,9,244,
    80,7,5, 0,8,86, 0,8,22, 192,8,0,
    83,7,51, 0,8,118, 0,8,54, 0,9,204,
    81,7,15, 0,8,102, 0,8,38, 0,9,172,
    0,8,6, 0,8,134, 0,8,70, 0,9,236,
    80,7,9, 0,8,94, 0,8,30, 0,9,156,
    84,7,99, 0,8,126, 0,8,62, 0,9,220,
    82,7,27, 0,8,110, 0,8,46, 0,9,188,
    0,8,14, 0,8,142, 0,8,78, 0,9,252,
    96,7,256, 0,8,81, 0,8,17, 85,8,131,
    82,7,31, 0,8,113, 0,8,49, 0,9,194,
    80,7,10, 0,8,97, 0,8,33, 0,9,162,
    0,8,1, 0,8,129, 0,8,65, 0,9,226,
    80,7,6, 0,8,89, 0,8,25, 0,9,146,
    83,7,59, 0,8,121, 0,8,57, 0,9,210,
    81,7,17, 0,8,105, 0,8,41, 0,9,178,
    0,8,9, 0,8,137, 0,8,73, 0,9,242,
    80,7,4, 0,8,85, 0,8,21, 80,8,258,
    83,7,43, 0,8,117, 0,8,53, 0,9,202,
    81,7,13, 0,8,101, 0,8,37, 0,9,170,
    0,8,5, 0,8,133, 0,8,69, 0,9,234,
    80,7,8, 0,8,93, 0,8,29, 0,9,154,
    84,7,83, 0,8,125, 0,8,61, 0,9,218,
    82,7,23, 0,8,109, 0,8,45, 0,9,186,
    0,8,13, 0,8,141, 0,8,77, 0,9,250,
    80,7,3, 0,8,83, 0,8,19, 85,8,195,
    83,7,35, 0,8,115, 0,8,51, 0,9,198,
    81,7,11, 0,8,99, 0,8,35, 0,9,166,
    0,8,3, 0,8,131, 0,8,67, 0,9,230,
    80,7,7, 0,8,91, 0,8,27, 0,9,150,
    84,7,67, 0,8,123, 0,8,59, 0,9,214,
    82,7,19, 0,8,107, 0,8,43, 0,9,182,
    0,8,11, 0,8,139, 0,8,75, 0,9,246,
    80,7,5, 0,8,87, 0,8,23, 192,8,0,
    83,7,51, 0,8,119, 0,8,55, 0,9,206,
    81,7,15, 0,8,103, 0,8,39, 0,9,174,
    0,8,7, 0,8,135, 0,8,71, 0,9,238,
    80,7,9, 0,8,95, 0,8,31, 0,9,158,
    84,7,99, 0,8,127, 0,8,63, 0,9,222,
    82,7,27, 0,8,111, 0,8,47, 0,9,190,
    0,8,15, 0,8,143, 0,8,79, 0,9,254,
    96,7,256, 0,8,80, 0,8,16, 84,8,115,
    82,7,31, 0,8,112, 0,8,48, 0,9,193,

    80,7,10, 0,8,96, 0,8,32, 0,9,161,
    0,8,0, 0,8,128, 0,8,64, 0,9,225,
    80,7,6, 0,8,88, 0,8,24, 0,9,145,
    83,7,59, 0,8,120, 0,8,56, 0,9,209,
    81,7,17, 0,8,104, 0,8,40, 0,9,177,
    0,8,8, 0,8,136, 0,8,72, 0,9,241,
    80,7,4, 0,8,84, 0,8,20, 85,8,227,
    83,7,43, 0,8,116, 0,8,52, 0,9,201,
    81,7,13, 0,8,100, 0,8,36, 0,9,169,
    0,8,4, 0,8,132, 0,8,68, 0,9,233,
    80,7,8, 0,8,92, 0,8,28, 0,9,153,
    84,7,83, 0,8,124, 0,8,60, 0,9,217,
    82,7,23, 0,8,108, 0,8,44, 0,9,185,
    0,8,12, 0,8,140, 0,8,76, 0,9,249,
    80,7,3, 0,8,82, 0,8,18, 85,8,163,
    83,7,35, 0,8,114, 0,8,50, 0,9,197,
    81,7,11, 0,8,98, 0,8,34, 0,9,165,
    0,8,2, 0,8,130, 0,8,66, 0,9,229,
    80,7,7, 0,8,90, 0,8,26, 0,9,149,
    84,7,67, 0,8,122, 0,8,58, 0,9,213,
    82,7,19, 0,8,106, 0,8,42, 0,9,181,
    0,8,10, 0,8,138, 0,8,74, 0,9,245,
    80,7,5, 0,8,86, 0,8,22, 192,8,0,
    83,7,51, 0,8,118, 0,8,54, 0,9,205,
    81,7,15, 0,8,102, 0,8,38, 0,9,173,
    0,8,6, 0,8,134, 0,8,70, 0,9,237,
    80,7,9, 0,8,94, 0,8,30, 0,9,157,
    84,7,99, 0,8,126, 0,8,62, 0,9,221,
    82,7,27, 0,8,110, 0,8,46, 0,9,189,
    0,8,14, 0,8,142, 0,8,78, 0,9,253,
    96,7,256, 0,8,81, 0,8,17, 85,8,131,
    82,7,31, 0,8,113, 0,8,49, 0,9,195,
    80,7,10, 0,8,97, 0,8,33, 0,9,163,
    0,8,1, 0,8,129, 0,8,65, 0,9,227,
    80,7,6, 0,8,89, 0,8,25, 0,9,147,
    83,7,59, 0,8,121, 0,8,57, 0,9,211,
    81,7,17, 0,8,105, 0,8,41, 0,9,179,
    0,8,9, 0,8,137, 0,8,73, 0,9,243,
    80,7,4, 0,8,85, 0,8,21, 80,8,258,
    83,7,43, 0,8,117, 0,8,53, 0,9,203,
    81,7,13, 0,8,101, 0,8,37, 0,9,171,
    0,8,5, 0,8,133, 0,8,69, 0,9,235,
    80,7,8, 0,8,93, 0,8,29, 0,9,155,
    84,7,83, 0,8,125, 0,8,61, 0,9,219,
    82,7,23, 0,8,109, 0,8,45, 0,9,187,
    0,8,13, 0,8,141, 0,8,77, 0,9,251,
    80,7,3, 0,8,83, 0,8,19, 85,8,195,
    83,7,35, 0,8,115, 0,8,51, 0,9,199,
    81,7,11, 0,8,99, 0,8,35, 0,9,167,
    0,8,3, 0,8,131, 0,8,67, 0,9,231,
    80,7,7, 0,8,91, 0,8,27, 0,9,151,
    84,7,67, 0,8,123, 0,8,59, 0,9,215,
    82,7,19, 0,8,107, 0,8,43, 0,9,183,
    0,8,11, 0,8,139, 0,8,75, 0,9,247,
    80,7,5, 0,8,87, 0,8,23, 192,8,0,
    83,7,51, 0,8,119, 0,8,55, 0,9,207,
    81,7,15, 0,8,103, 0,8,39, 0,9,175,
    0,8,7, 0,8,135, 0,8,71, 0,9,239,
    80,7,9, 0,8,95, 0,8,31, 0,9,159,
    84,7,99, 0,8,127, 0,8,63, 0,9,223,
    82,7,27, 0,8,111, 0,8,47, 0,9,191,
    0,8,15, 0,8,143, 0,8,79, 0,9,255
];
var fixed_td = [
    80,5,1, 87,5,257, 83,5,17, 91,5,4097,
    81,5,5, 89,5,1025, 85,5,65, 93,5,16385,
    80,5,3, 88,5,513, 84,5,33, 92,5,8193,
    82,5,9, 90,5,2049, 86,5,129, 192,5,24577,
    80,5,2, 87,5,385, 83,5,25, 91,5,6145,
    81,5,7, 89,5,1537, 85,5,97, 93,5,24577,
    80,5,4, 88,5,769, 84,5,49, 92,5,12289,
    82,5,13, 90,5,3073, 86,5,193, 192,5,24577
];

  // Tables for deflate from PKZIP's appnote.txt.
  var cplens = [ // Copy lengths for literal codes 257..285
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
  ];

  // see note #13 above about 258
  var cplext = [ // Extra bits for literal codes 257..285
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112  // 112==invalid
  ];

 var cpdist = [ // Copy offsets for distance codes 0..29
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577
  ];

  var cpdext = [ // Extra bits for distance codes
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
        12, 12, 13, 13];

//
// ZStream.java
//

function ZStream() {
}


ZStream.prototype.inflateInit = function(w, nowrap) {
    if (!w) {
	w = DEF_WBITS;
    }
    if (nowrap) {
	nowrap = false;
    }
    this.istate = new Inflate();
    return this.istate.inflateInit(this, nowrap?-w:w);
}

ZStream.prototype.inflate = function(f) {
    if(this.istate==null) return Z_STREAM_ERROR;
    return this.istate.inflate(this, f);
}

ZStream.prototype.inflateEnd = function(){
    if(this.istate==null) return Z_STREAM_ERROR;
    var ret=istate.inflateEnd(this);
    this.istate = null;
    return ret;
}
ZStream.prototype.inflateSync = function(){
    // if(istate == null) return Z_STREAM_ERROR;
    return istate.inflateSync(this);
}
ZStream.prototype.inflateSetDictionary = function(dictionary, dictLength){
    // if(istate == null) return Z_STREAM_ERROR;
    return istate.inflateSetDictionary(this, dictionary, dictLength);
}

/*

  public int deflateInit(int level){
    return deflateInit(level, MAX_WBITS);
  }
  public int deflateInit(int level, boolean nowrap){
    return deflateInit(level, MAX_WBITS, nowrap);
  }
  public int deflateInit(int level, int bits){
    return deflateInit(level, bits, false);
  }
  public int deflateInit(int level, int bits, boolean nowrap){
    dstate=new Deflate();
    return dstate.deflateInit(this, level, nowrap?-bits:bits);
  }
  public int deflate(int flush){
    if(dstate==null){
      return Z_STREAM_ERROR;
    }
    return dstate.deflate(this, flush);
  }
  public int deflateEnd(){
    if(dstate==null) return Z_STREAM_ERROR;
    int ret=dstate.deflateEnd();
    dstate=null;
    return ret;
  }
  public int deflateParams(int level, int strategy){
    if(dstate==null) return Z_STREAM_ERROR;
    return dstate.deflateParams(this, level, strategy);
  }
  public int deflateSetDictionary (byte[] dictionary, int dictLength){
    if(dstate == null)
      return Z_STREAM_ERROR;
    return dstate.deflateSetDictionary(this, dictionary, dictLength);
  }

*/

/*
  // Flush as much pending output as possible. All deflate() output goes
  // through this function so some applications may wish to modify it
  // to avoid allocating a large strm->next_out buffer and copying into it.
  // (See also read_buf()).
  void flush_pending(){
    int len=dstate.pending;

    if(len>avail_out) len=avail_out;
    if(len==0) return;

    if(dstate.pending_buf.length<=dstate.pending_out ||
       next_out.length<=next_out_index ||
       dstate.pending_buf.length<(dstate.pending_out+len) ||
       next_out.length<(next_out_index+len)){
      System.out.println(dstate.pending_buf.length+", "+dstate.pending_out+
			 ", "+next_out.length+", "+next_out_index+", "+len);
      System.out.println("avail_out="+avail_out);
    }

    System.arraycopy(dstate.pending_buf, dstate.pending_out,
		     next_out, next_out_index, len);

    next_out_index+=len;
    dstate.pending_out+=len;
    total_out+=len;
    avail_out-=len;
    dstate.pending-=len;
    if(dstate.pending==0){
      dstate.pending_out=0;
    }
  }

  // Read a new buffer from the current input stream, update the adler32
  // and total number of bytes read.  All deflate() input goes through
  // this function so some applications may wish to modify it to avoid
  // allocating a large strm->next_in buffer and copying from it.
  // (See also flush_pending()).
  int read_buf(byte[] buf, int start, int size) {
    int len=avail_in;

    if(len>size) len=size;
    if(len==0) return 0;

    avail_in-=len;

    if(dstate.noheader==0) {
      adler=_adler.adler32(adler, next_in, next_in_index, len);
    }
    System.arraycopy(next_in, next_in_index, buf, start, len);
    next_in_index  += len;
    total_in += len;
    return len;
  }

  public void free(){
    next_in=null;
    next_out=null;
    msg=null;
    _adler=null;
  }
}
*/


//
// Inflate.java
//

function Inflate() {
    this.was = [0];
}

Inflate.prototype.inflateReset = function(z) {
    if(z == null || z.istate == null) return Z_STREAM_ERROR;
    
    z.total_in = z.total_out = 0;
    z.msg = null;
    z.istate.mode = z.istate.nowrap!=0 ? BLOCKS : METHOD;
    z.istate.blocks.reset(z, null);
    return Z_OK;
}

Inflate.prototype.inflateEnd = function(z){
    if(this.blocks != null)
      this.blocks.free(z);
    this.blocks=null;
    return Z_OK;
}

Inflate.prototype.inflateInit = function(z, w){
    z.msg = null;
    this.blocks = null;

    // handle undocumented nowrap option (no zlib header or check)
    nowrap = 0;
    if(w < 0){
      w = - w;
      nowrap = 1;
    }

    // set window size
    if(w<8 ||w>15){
      this.inflateEnd(z);
      return Z_STREAM_ERROR;
    }
    this.wbits=w;

    z.istate.blocks=new InfBlocks(z, 
				  z.istate.nowrap!=0 ? null : this,
				  1<<w);

    // reset state
    this.inflateReset(z);
    return Z_OK;
  }

Inflate.prototype.inflate = function(z, f){
    var r, b;

    if(z == null || z.istate == null || z.next_in == null)
      return Z_STREAM_ERROR;
    f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
    r = Z_BUF_ERROR;
    while (true){
      switch (z.istate.mode){
      case METHOD:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        if(((z.istate.method = z.next_in[z.next_in_index++])&0xf)!=Z_DEFLATED){
          z.istate.mode = BAD;
          z.msg="unknown compression method";
          z.istate.marker = 5;       // can't try inflateSync
          break;
        }
        if((z.istate.method>>4)+8>z.istate.wbits){
          z.istate.mode = BAD;
          z.msg="invalid window size";
          z.istate.marker = 5;       // can't try inflateSync
          break;
        }
        z.istate.mode=FLAG;
      case FLAG:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        b = (z.next_in[z.next_in_index++])&0xff;

        if((((z.istate.method << 8)+b) % 31)!=0){
          z.istate.mode = BAD;
          z.msg = "incorrect header check";
          z.istate.marker = 5;       // can't try inflateSync
          break;
        }

        if((b&PRESET_DICT)==0){
          z.istate.mode = BLOCKS;
          break;
        }
        z.istate.mode = DICT4;
      case DICT4:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000;
        z.istate.mode=DICT3;
      case DICT3:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000;
        z.istate.mode=DICT2;
      case DICT2:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00;
        z.istate.mode=DICT1;
      case DICT1:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need += (z.next_in[z.next_in_index++]&0xff);
        z.adler = z.istate.need;
        z.istate.mode = DICT0;
        return Z_NEED_DICT;
      case DICT0:
        z.istate.mode = BAD;
        z.msg = "need dictionary";
        z.istate.marker = 0;       // can try inflateSync
        return Z_STREAM_ERROR;
      case BLOCKS:

        r = z.istate.blocks.proc(z, r);
        if(r == Z_DATA_ERROR){
          z.istate.mode = BAD;
          z.istate.marker = 0;     // can try inflateSync
          break;
        }
        if(r == Z_OK){
          r = f;
        }
        if(r != Z_STREAM_END){
          return r;
        }
        r = f;
        z.istate.blocks.reset(z, z.istate.was);
        if(z.istate.nowrap!=0){
          z.istate.mode=DONE;
          break;
        }
        z.istate.mode=CHECK4;
      case CHECK4:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000;
        z.istate.mode=CHECK3;
      case CHECK3:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000;
        z.istate.mode = CHECK2;
      case CHECK2:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00;
        z.istate.mode = CHECK1;
      case CHECK1:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=(z.next_in[z.next_in_index++]&0xff);

        if(((z.istate.was[0])) != ((z.istate.need))){
          z.istate.mode = BAD;
          z.msg = "incorrect data check";
          z.istate.marker = 5;       // can't try inflateSync
          break;
        }

        z.istate.mode = DONE;
      case DONE:
        return Z_STREAM_END;
      case BAD:
        return Z_DATA_ERROR;
      default:
        return Z_STREAM_ERROR;
      }
    }
  }


Inflate.prototype.inflateSetDictionary = function(z,  dictionary, dictLength) {
    var index=0;
    var length = dictLength;
    if(z==null || z.istate == null|| z.istate.mode != DICT0)
      return Z_STREAM_ERROR;

    if(z._adler.adler32(1, dictionary, 0, dictLength)!=z.adler){
      return Z_DATA_ERROR;
    }

    z.adler = z._adler.adler32(0, null, 0, 0);

    if(length >= (1<<z.istate.wbits)){
      length = (1<<z.istate.wbits)-1;
      index=dictLength - length;
    }
    z.istate.blocks.set_dictionary(dictionary, index, length);
    z.istate.mode = BLOCKS;
    return Z_OK;
  }

//  static private byte[] mark = {(byte)0, (byte)0, (byte)0xff, (byte)0xff};
var mark = [0, 0, 255, 255]

Inflate.prototype.inflateSync = function(z){
    var n;       // number of bytes to look at
    var p;       // pointer to bytes
    var m;       // number of marker bytes found in a row
    var r, w;   // temporaries to save total_in and total_out

    // set up
    if(z == null || z.istate == null)
      return Z_STREAM_ERROR;
    if(z.istate.mode != BAD){
      z.istate.mode = BAD;
      z.istate.marker = 0;
    }
    if((n=z.avail_in)==0)
      return Z_BUF_ERROR;
    p=z.next_in_index;
    m=z.istate.marker;

    // search
    while (n!=0 && m < 4){
      if(z.next_in[p] == mark[m]){
        m++;
      }
      else if(z.next_in[p]!=0){
        m = 0;
      }
      else{
        m = 4 - m;
      }
      p++; n--;
    }

    // restore
    z.total_in += p-z.next_in_index;
    z.next_in_index = p;
    z.avail_in = n;
    z.istate.marker = m;

    // return no joy or set up to restart on a new block
    if(m != 4){
      return Z_DATA_ERROR;
    }
    r=z.total_in;  w=z.total_out;
    this.inflateReset(z);
    z.total_in=r;  z.total_out = w;
    z.istate.mode = BLOCKS;
    return Z_OK;
}

  // Returns true if inflate is currently at the end of a block generated
  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
  // implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
  // but removes the length bytes of the resulting empty stored block. When
  // decompressing, PPP checks that at the end of input packet, inflate is
  // waiting for these length bytes.
Inflate.prototype.inflateSyncPoint = function(z){
    if(z == null || z.istate == null || z.istate.blocks == null)
      return Z_STREAM_ERROR;
    return z.istate.blocks.sync_point();
}


//
// InfBlocks.java
//

var INFBLOCKS_BORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

function InfBlocks(z, checkfn, w) {
    this.hufts=new Int32Array(MANY*3);
    this.window=new Uint8Array(w);
    this.end=w;
    this.checkfn = checkfn;
    this.mode = IB_TYPE;
    this.reset(z, null);

    this.left = 0;            // if STORED, bytes left to copy 

    this.table = 0;           // table lengths (14 bits) 
    this.index = 0;           // index into blens (or border) 
    this.blens = null;         // bit lengths of codes 
    this.bb=new Int32Array(1); // bit length tree depth 
    this.tb=new Int32Array(1); // bit length decoding tree 

    this.codes = new InfCodes();

    this.last = 0;            // true if this block is the last block 

  // mode independent information 
    this.bitk = 0;            // bits in bit buffer 
    this.bitb = 0;            // bit buffer 
    this.read = 0;            // window read pointer 
    this.write = 0;           // window write pointer 
    this.check = 0;          // check on output 

    this.inftree=new InfTree();
}




InfBlocks.prototype.reset = function(z, c){
    if(c) c[0]=this.check;
    if(this.mode==IB_CODES){
      this.codes.free(z);
    }
    this.mode=IB_TYPE;
    this.bitk=0;
    this.bitb=0;
    this.read=this.write=0;

    if(this.checkfn)
      z.adler=this.check=z._adler.adler32(0, null, 0, 0);
  }

 InfBlocks.prototype.proc = function(z, r){
    var t;              // temporary storage
    var b;              // bit buffer
    var k;              // bits in bit buffer
    var p;              // input data pointer
    var n;              // bytes available there
    var q;              // output window write pointer
    var m;              // bytes to end of window or read pointer

    // copy input/output information to locals (UPDATE macro restores)
    {p=z.next_in_index;n=z.avail_in;b=this.bitb;k=this.bitk;}
    {q=this.write;m=(q<this.read ? this.read-q-1 : this.end-q);}

    // process input based on current state
    while(true){
      switch (this.mode){
      case IB_TYPE:

	while(k<(3)){
	  if(n!=0){
	    r=Z_OK;
	  }
	  else{
	    this.bitb=b; this.bitk=k; 
	    z.avail_in=n;
	    z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    this.write=q;
	    return this.inflate_flush(z,r);
	  };
	  n--;
	  b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}
	t = (b & 7);
	this.last = t & 1;

	switch (t >>> 1){
        case 0:                         // stored 
          {b>>>=(3);k-=(3);}
          t = k & 7;                    // go to byte boundary

          {b>>>=(t);k-=(t);}
          this.mode = IB_LENS;                  // get length of stored block
          break;
        case 1:                         // fixed
          {
              var bl=new Int32Array(1);
	      var bd=new Int32Array(1);
              var tl=[];
	      var td=[];

	      inflate_trees_fixed(bl, bd, tl, td, z);
              this.codes.init(bl[0], bd[0], tl[0], 0, td[0], 0, z);
          }

          {b>>>=(3);k-=(3);}

          this.mode = IB_CODES;
          break;
        case 2:                         // dynamic

          {b>>>=(3);k-=(3);}

          this.mode = IB_TABLE;
          break;
        case 3:                         // illegal

          {b>>>=(3);k-=(3);}
          this.mode = BAD;
          z.msg = "invalid block type";
          r = Z_DATA_ERROR;

	  this.bitb=b; this.bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  this.write=q;
	  return this.inflate_flush(z,r);
	}
	break;
      case IB_LENS:
	while(k<(32)){
	  if(n!=0){
	    r=Z_OK;
	  }
	  else{
	    this.bitb=b; this.bitk=k; 
	    z.avail_in=n;
	    z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    this.write=q;
	    return this.inflate_flush(z,r);
	  };
	  n--;
	  b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	if ((((~b) >>> 16) & 0xffff) != (b & 0xffff)){
	  this.mode = BAD;
	  z.msg = "invalid stored block lengths";
	  r = Z_DATA_ERROR;

	  this.bitb=b; this.bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  this.write=q;
	  return this.inflate_flush(z,r);
	}
	this.left = (b & 0xffff);
	b = k = 0;                       // dump bits
	this.mode = this.left!=0 ? IB_STORED : (this.last!=0 ? IB_DRY : IB_TYPE);
	break;
      case IB_STORED:
	if (n == 0){
	  this.bitb=b; this.bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  write=q;
	  return this.inflate_flush(z,r);
	}

	if(m==0){
	  if(q==end&&read!=0){
	    q=0; m=(q<this.read ? this.read-q-1 : this.end-q);
	  }
	  if(m==0){
	    this.write=q; 
	    r=this.inflate_flush(z,r);
	    q=this.write; m = (q < this.read ? this.read-q-1 : this.end-q);
	    if(q==this.end && this.read != 0){
	      q=0; m = (q < this.read ? this.read-q-1 : this.end-q);
	    }
	    if(m==0){
	      this.bitb=b; this.bitk=k; 
	      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      this.write=q;
	      return this.inflate_flush(z,r);
	    }
	  }
	}
	r=Z_OK;

	t = this.left;
	if(t>n) t = n;
	if(t>m) t = m;
	arrayCopy(z.next_in, p, this.window, q, t);
	p += t;  n -= t;
	q += t;  m -= t;
	if ((this.left -= t) != 0)
	  break;
	this.mode = (this.last != 0 ? IB_DRY : IB_TYPE);
	break;
      case IB_TABLE:

	while(k<(14)){
	  if(n!=0){
	    r=Z_OK;
	  }
	  else{
	    this.bitb=b; this.bitk=k; 
	    z.avail_in=n;
	    z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    this.write=q;
	    return this.inflate_flush(z,r);
	  };
	  n--;
	  b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	this.table = t = (b & 0x3fff);
	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
	  {
	    this.mode = IB_BAD;
	    z.msg = "too many length or distance symbols";
	    r = Z_DATA_ERROR;

	    this.bitb=b; this.bitk=k; 
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    this.write=q;
	    return this.inflate_flush(z,r);
	  }
	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
	if(this.blens==null || this.blens.length<t){
	    this.blens=new Int32Array(t);
	}
	else{
	  for(var i=0; i<t; i++){
              this.blens[i]=0;
          }
	}

	{b>>>=(14);k-=(14);}

	this.index = 0;
	mode = IB_BTREE;
      case IB_BTREE:
	while (this.index < 4 + (this.table >>> 10)){
	  while(k<(3)){
	    if(n!=0){
	      r=Z_OK;
	    }
	    else{
	      this.bitb=b; this.bitk=k; 
	      z.avail_in=n;
	      z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      this.write=q;
	      return this.inflate_flush(z,r);
	    };
	    n--;
	    b|=(z.next_in[p++]&0xff)<<k;
	    k+=8;
	  }

	  this.blens[INFBLOCKS_BORDER[this.index++]] = b&7;

	  {b>>>=(3);k-=(3);}
	}

	while(this.index < 19){
	  this.blens[INFBLOCKS_BORDER[this.index++]] = 0;
	}

	this.bb[0] = 7;
	t = this.inftree.inflate_trees_bits(this.blens, this.bb, this.tb, this.hufts, z);
	if (t != Z_OK){
	  r = t;
	  if (r == Z_DATA_ERROR){
	    this.blens=null;
	    this.mode = IB_BAD;
	  }

	  this.bitb=b; this.bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  write=q;
	  return this.inflate_flush(z,r);
	}

	this.index = 0;
	this.mode = IB_DTREE;
      case IB_DTREE:
	while (true){
	  t = this.table;
	  if(!(this.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))){
	    break;
	  }

	  var h; //int[]
	  var i, j, c;

	  t = this.bb[0];

	  while(k<(t)){
	    if(n!=0){
	      r=Z_OK;
	    }
	    else{
	      this.bitb=b; this.bitk=k; 
	      z.avail_in=n;
	      z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      this.write=q;
	      return this.inflate_flush(z,r);
	    };
	    n--;
	    b|=(z.next_in[p++]&0xff)<<k;
	    k+=8;
	  }

//	  if (this.tb[0]==-1){
//            dlog("null...");
//	  }

	  t=this.hufts[(this.tb[0]+(b & inflate_mask[t]))*3+1];
	  c=this.hufts[(this.tb[0]+(b & inflate_mask[t]))*3+2];

	  if (c < 16){
	    b>>>=(t);k-=(t);
	    this.blens[this.index++] = c;
	  }
	  else { // c == 16..18
	    i = c == 18 ? 7 : c - 14;
	    j = c == 18 ? 11 : 3;

	    while(k<(t+i)){
	      if(n!=0){
		r=Z_OK;
	      }
	      else{
		this.bitb=b; this.bitk=k; 
		z.avail_in=n;
		z.total_in+=p-z.next_in_index;z.next_in_index=p;
		this.write=q;
		return this.inflate_flush(z,r);
	      };
	      n--;
	      b|=(z.next_in[p++]&0xff)<<k;
	      k+=8;
	    }

	    b>>>=(t);k-=(t);

	    j += (b & inflate_mask[i]);

	    b>>>=(i);k-=(i);

	    i = this.index;
	    t = this.table;
	    if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
		(c == 16 && i < 1)){
	      this.blens=null;
	      this.mode = IB_BAD;
	      z.msg = "invalid bit length repeat";
	      r = Z_DATA_ERROR;

	      this.bitb=b; this.bitk=k; 
	      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      this.write=q;
	      return this.inflate_flush(z,r);
	    }

	    c = c == 16 ? this.blens[i-1] : 0;
	    do{
	      this.blens[i++] = c;
	    }
	    while (--j!=0);
	    this.index = i;
	  }
	}

	this.tb[0]=-1;
	{
	    var bl=new Int32Array(1);
	    var bd=new Int32Array(1);
	    var tl=new Int32Array(1);
	    var td=new Int32Array(1);
	    bl[0] = 9;         // must be <= 9 for lookahead assumptions
	    bd[0] = 6;         // must be <= 9 for lookahead assumptions

	    t = this.table;
	    t = this.inftree.inflate_trees_dynamic(257 + (t & 0x1f), 
					      1 + ((t >> 5) & 0x1f),
					      this.blens, bl, bd, tl, td, this.hufts, z);

	    if (t != Z_OK){
	        if (t == Z_DATA_ERROR){
	            this.blens=null;
	            this.mode = BAD;
	        }
	        r = t;

	        this.bitb=b; this.bitk=k; 
	        z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	        this.write=q;
	        return this.inflate_flush(z,r);
	    }
	    this.codes.init(bl[0], bd[0], this.hufts, tl[0], this.hufts, td[0], z);
	}
	this.mode = IB_CODES;
      case IB_CODES:
	this.bitb=b; this.bitk=k;
	z.avail_in=n; z.total_in+=p-z.next_in_index;z.next_in_index=p;
	this.write=q;

	if ((r = this.codes.proc(this, z, r)) != Z_STREAM_END){
	  return this.inflate_flush(z, r);
	}
	r = Z_OK;
	this.codes.free(z);

	p=z.next_in_index; n=z.avail_in;b=this.bitb;k=this.bitk;
	q=this.write;m = (q < this.read ? this.read-q-1 : this.end-q);

	if (this.last==0){
	  this.mode = IB_TYPE;
	  break;
	}
	this.mode = IB_DRY;
      case IB_DRY:
	this.write=q; 
	r = this.inflate_flush(z, r); 
	q=this.write; m = (q < this.read ? this.read-q-1 : this.end-q);
	if (this.read != this.write){
	  this.bitb=b; this.bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  this.write=q;
	  return this.inflate_flush(z, r);
	}
	mode = DONE;
      case IB_DONE:
	r = Z_STREAM_END;

	this.bitb=b; this.bitk=k; 
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	this.write=q;
	return this.inflate_flush(z, r);
      case IB_BAD:
	r = Z_DATA_ERROR;

	this.bitb=b; this.bitk=k; 
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	this.write=q;
	return this.inflate_flush(z, r);

      default:
	r = Z_STREAM_ERROR;

	this.bitb=b; this.bitk=k; 
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	this.write=q;
	return this.inflate_flush(z, r);
      }
    }
  }

InfBlocks.prototype.free = function(z){
    this.reset(z, null);
    this.window=null;
    this.hufts=null;
}

InfBlocks.prototype.set_dictionary = function(d, start, n){
    arrayCopy(d, start, window, 0, n);
    this.read = this.write = n;
}

  // Returns true if inflate is currently at the end of a block generated
  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. 
InfBlocks.prototype.sync_point = function(){
    return this.mode == IB_LENS;
}

  // copy as much as possible from the sliding window to the output area
InfBlocks.prototype.inflate_flush = function(z, r){
    var n;
    var p;
    var q;

    // local copies of source and destination pointers
    p = z.next_out_index;
    q = this.read;

    // compute number of bytes to copy as far as end of window
    n = ((q <= this.write ? this.write : this.end) - q);
    if (n > z.avail_out) n = z.avail_out;
    if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;

    // update counters
    z.avail_out -= n;
    z.total_out += n;

    // update check information
    if(this.checkfn != null)
      z.adler=this.check=z._adler.adler32(this.check, this.window, q, n);

    // copy as far as end of window
    arrayCopy(this.window, q, z.next_out, p, n);
    p += n;
    q += n;

    // see if more to copy at beginning of window
    if (q == this.end){
      // wrap pointers
      q = 0;
      if (this.write == this.end)
        this.write = 0;

      // compute bytes to copy
      n = this.write - q;
      if (n > z.avail_out) n = z.avail_out;
      if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;

      // update counters
      z.avail_out -= n;
      z.total_out += n;

      // update check information
      if(this.checkfn != null)
	z.adler=this.check=z._adler.adler32(this.check, this.window, q, n);

      // copy
      arrayCopy(this.window, q, z.next_out, p, n);
      p += n;
      q += n;
    }

    // update pointers
    z.next_out_index = p;
    this.read = q;

    // done
    return r;
  }

//
// InfCodes.java
//

var IC_START=0;  // x: set up for LEN
var IC_LEN=1;    // i: get length/literal/eob next
var IC_LENEXT=2; // i: getting length extra (have base)
var IC_DIST=3;   // i: get distance next
var IC_DISTEXT=4;// i: getting distance extra
var IC_COPY=5;   // o: copying bytes in window, waiting for space
var IC_LIT=6;    // o: got literal, waiting for output space
var IC_WASH=7;   // o: got eob, possibly still output waiting
var IC_END=8;    // x: got eob and all data flushed
var IC_BADCODE=9;// x: got error

function InfCodes() {
}

InfCodes.prototype.init = function(bl, bd, tl, tl_index, td, td_index, z) {
    this.mode=IC_START;
    this.lbits=bl;
    this.dbits=bd;
    this.ltree=tl;
    this.ltree_index=tl_index;
    this.dtree = td;
    this.dtree_index=td_index;
    this.tree=null;
}

InfCodes.prototype.proc = function(s, z, r){ 
    var j;              // temporary storage
    var t;              // temporary pointer (int[])
    var tindex;         // temporary pointer
    var e;              // extra bits or operation
    var b=0;            // bit buffer
    var k=0;            // bits in bit buffer
    var p=0;            // input data pointer
    var n;              // bytes available there
    var q;              // output window write pointer
    var m;              // bytes to end of window or read pointer
    var f;              // pointer to copy strings from

    // copy input/output information to locals (UPDATE macro restores)
    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;
    q=s.write;m=q<s.read?s.read-q-1:s.end-q;

    // process input and output based on current state
    while (true){
      switch (this.mode){
	// waiting for "i:"=input, "o:"=output, "x:"=nothing
      case IC_START:         // x: set up for LEN
	if (m >= 258 && n >= 10){

	  s.bitb=b;s.bitk=k;
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  s.write=q;
	  r = this.inflate_fast(this.lbits, this.dbits, 
			   this.ltree, this.ltree_index, 
			   this.dtree, this.dtree_index,
			   s, z);

	  p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;
	  q=s.write;m=q<s.read?s.read-q-1:s.end-q;

	  if (r != Z_OK){
	    this.mode = r == Z_STREAM_END ? IC_WASH : IC_BADCODE;
	    break;
	  }
	}
	this.need = this.lbits;
	this.tree = this.ltree;
	this.tree_index=this.ltree_index;

	this.mode = IC_LEN;
      case IC_LEN:           // i: get length/literal/eob next
	j = this.need;

	while(k<(j)){
	  if(n!=0)r=Z_OK;
	  else{

	    s.bitb=b;s.bitk=k;
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    s.write=q;
	    return s.inflate_flush(z,r);
	  }
	  n--;
	  b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	tindex=(this.tree_index+(b&inflate_mask[j]))*3;

	b>>>=(this.tree[tindex+1]);
	k-=(this.tree[tindex+1]);

	e=this.tree[tindex];

	if(e == 0){               // literal
	  this.lit = this.tree[tindex+2];
	  this.mode = IC_LIT;
	  break;
	}
	if((e & 16)!=0 ){          // length
	  this.get = e & 15;
	  this.len = this.tree[tindex+2];
	  this.mode = IC_LENEXT;
	  break;
	}
	if ((e & 64) == 0){        // next table
	  this.need = e;
	  this.tree_index = tindex/3 + this.tree[tindex+2];
	  break;
	}
	if ((e & 32)!=0){               // end of block
	  this.mode = IC_WASH;
	  break;
	}
	this.mode = IC_BADCODE;        // invalid code
	z.msg = "invalid literal/length code";
	r = Z_DATA_ERROR;

	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);

      case IC_LENEXT:        // i: getting length extra (have base)
	j = this.get;

	while(k<(j)){
	  if(n!=0)r=Z_OK;
	  else{

	    s.bitb=b;s.bitk=k;
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    s.write=q;
	    return s.inflate_flush(z,r);
	  }
	  n--; b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	this.len += (b & inflate_mask[j]);

	b>>=j;
	k-=j;

	this.need = this.dbits;
	this.tree = this.dtree;
	this.tree_index = this.dtree_index;
	this.mode = IC_DIST;
      case IC_DIST:          // i: get distance next
	j = this.need;

	while(k<(j)){
	  if(n!=0)r=Z_OK;
	  else{

	    s.bitb=b;s.bitk=k;
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    s.write=q;
	    return s.inflate_flush(z,r);
	  }
	  n--; b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	tindex=(this.tree_index+(b & inflate_mask[j]))*3;

	b>>=this.tree[tindex+1];
	k-=this.tree[tindex+1];

	e = (this.tree[tindex]);
	if((e & 16)!=0){               // distance
	  this.get = e & 15;
	  this.dist = this.tree[tindex+2];
	  this.mode = IC_DISTEXT;
	  break;
	}
	if ((e & 64) == 0){        // next table
	  this.need = e;
	  this.tree_index = tindex/3 + this.tree[tindex+2];
	  break;
	}
	this.mode = IC_BADCODE;        // invalid code
	z.msg = "invalid distance code";
	r = Z_DATA_ERROR;

	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);

      case IC_DISTEXT:       // i: getting distance extra
	j = this.get;

	while(k<(j)){
	  if(n!=0)r=Z_OK;
	  else{

	    s.bitb=b;s.bitk=k;
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    s.write=q;
	    return s.inflate_flush(z,r);
	  }
	  n--; b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	this.dist += (b & inflate_mask[j]);

	b>>=j;
	k-=j;

	this.mode = IC_COPY;
      case IC_COPY:          // o: copying bytes in window, waiting for space
        f = q - this.dist;
        while(f < 0){     // modulo window size-"while" instead
          f += s.end;     // of "if" handles invalid distances
	}
	while (this.len!=0){

	  if(m==0){
	    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}
	    if(m==0){
	      s.write=q; r=s.inflate_flush(z,r);
	      q=s.write;m=q<s.read?s.read-q-1:s.end-q;

	      if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}

	      if(m==0){
		s.bitb=b;s.bitk=k;
		z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
		s.write=q;
		return s.inflate_flush(z,r);
	      }  
	    }
	  }

	  s.window[q++]=s.window[f++]; m--;

	  if (f == s.end)
            f = 0;
	  this.len--;
	}
	this.mode = IC_START;
	break;
      case IC_LIT:           // o: got literal, waiting for output space
	if(m==0){
	  if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}
	  if(m==0){
	    s.write=q; r=s.inflate_flush(z,r);
	    q=s.write;m=q<s.read?s.read-q-1:s.end-q;

	    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}
	    if(m==0){
	      s.bitb=b;s.bitk=k;
	      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      s.write=q;
	      return s.inflate_flush(z,r);
	    }
	  }
	}
	r=Z_OK;

	s.window[q++]=this.lit; m--;

	this.mode = IC_START;
	break;
      case IC_WASH:           // o: got eob, possibly more output
	if (k > 7){        // return unused byte, if any
	  k -= 8;
	  n++;
	  p--;             // can always return one
	}

	s.write=q; r=s.inflate_flush(z,r);
	q=s.write;m=q<s.read?s.read-q-1:s.end-q;

	if (s.read != s.write){
	  s.bitb=b;s.bitk=k;
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  s.write=q;
	  return s.inflate_flush(z,r);
	}
	this.mode = IC_END;
      case IC_END:
	r = Z_STREAM_END;
	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);

      case IC_BADCODE:       // x: got error

	r = Z_DATA_ERROR;

	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);

      default:
	r = Z_STREAM_ERROR;

	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);
      }
    }
  }

InfCodes.prototype.free = function(z){
    //  ZFREE(z, c);
}

  // Called with number of bytes left to write in window at least 258
  // (the maximum string length) and number of input bytes available
  // at least ten.  The ten bytes are six bytes for the longest length/
  // distance pair plus four bytes for overloading the bit buffer.

InfCodes.prototype.inflate_fast = function(bl, bd, tl, tl_index, td, td_index, s, z) {
    var t;                // temporary pointer
    var   tp;             // temporary pointer (int[])
    var tp_index;         // temporary pointer
    var e;                // extra bits or operation
    var b;                // bit buffer
    var k;                // bits in bit buffer
    var p;                // input data pointer
    var n;                // bytes available there
    var q;                // output window write pointer
    var m;                // bytes to end of window or read pointer
    var ml;               // mask for literal/length tree
    var md;               // mask for distance tree
    var c;                // bytes to copy
    var d;                // distance back to copy from
    var r;                // copy source pointer

    var tp_index_t_3;     // (tp_index+t)*3

    // load input, output, bit values
    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;
    q=s.write;m=q<s.read?s.read-q-1:s.end-q;

    // initialize masks
    ml = inflate_mask[bl];
    md = inflate_mask[bd];

    // do until not enough input or output space for fast loop
    do {                          // assume called with m >= 258 && n >= 10
      // get literal/length code
      while(k<(20)){              // max bits for literal/length code
	n--;
	b|=(z.next_in[p++]&0xff)<<k;k+=8;
      }

      t= b&ml;
      tp=tl; 
      tp_index=tl_index;
      tp_index_t_3=(tp_index+t)*3;
      if ((e = tp[tp_index_t_3]) == 0){
	b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);

	s.window[q++] = tp[tp_index_t_3+2];
	m--;
	continue;
      }
      do {

	b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);

	if((e&16)!=0){
	  e &= 15;
	  c = tp[tp_index_t_3+2] + (b & inflate_mask[e]);

	  b>>=e; k-=e;

	  // decode distance base of block to copy
	  while(k<(15)){           // max bits for distance code
	    n--;
	    b|=(z.next_in[p++]&0xff)<<k;k+=8;
	  }

	  t= b&md;
	  tp=td;
	  tp_index=td_index;
          tp_index_t_3=(tp_index+t)*3;
	  e = tp[tp_index_t_3];

	  do {

	    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);

	    if((e&16)!=0){
	      // get extra bits to add to distance base
	      e &= 15;
	      while(k<(e)){         // get extra bits (up to 13)
		n--;
		b|=(z.next_in[p++]&0xff)<<k;k+=8;
	      }

	      d = tp[tp_index_t_3+2] + (b&inflate_mask[e]);

	      b>>=(e); k-=(e);

	      // do the copy
	      m -= c;
	      if (q >= d){                // offset before dest
		//  just copy
		r=q-d;
		if(q-r>0 && 2>(q-r)){           
		  s.window[q++]=s.window[r++]; // minimum count is three,
		  s.window[q++]=s.window[r++]; // so unroll loop a little
		  c-=2;
		}
		else{
		  s.window[q++]=s.window[r++]; // minimum count is three,
		  s.window[q++]=s.window[r++]; // so unroll loop a little
		  c-=2;
		}
	      }
	      else{                  // else offset after destination
                r=q-d;
                do{
                  r+=s.end;          // force pointer in window
                }while(r<0);         // covers invalid distances
		e=s.end-r;
		if(c>e){             // if source crosses,
		  c-=e;              // wrapped copy
		  if(q-r>0 && e>(q-r)){           
		    do{s.window[q++] = s.window[r++];}
		    while(--e!=0);
		  }
		  else{
		    arrayCopy(s.window, r, s.window, q, e);
		    q+=e; r+=e; e=0;
		  }
		  r = 0;                  // copy rest from start of window
		}

	      }

	      // copy all or what's left
              do{s.window[q++] = s.window[r++];}
		while(--c!=0);
	      break;
	    }
	    else if((e&64)==0){
	      t+=tp[tp_index_t_3+2];
	      t+=(b&inflate_mask[e]);
	      tp_index_t_3=(tp_index+t)*3;
	      e=tp[tp_index_t_3];
	    }
	    else{
	      z.msg = "invalid distance code";

	      c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;

	      s.bitb=b;s.bitk=k;
	      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      s.write=q;

	      return Z_DATA_ERROR;
	    }
	  }
	  while(true);
	  break;
	}

	if((e&64)==0){
	  t+=tp[tp_index_t_3+2];
	  t+=(b&inflate_mask[e]);
	  tp_index_t_3=(tp_index+t)*3;
	  if((e=tp[tp_index_t_3])==0){

	    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);

	    s.window[q++]=tp[tp_index_t_3+2];
	    m--;
	    break;
	  }
	}
	else if((e&32)!=0){

	  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;
 
	  s.bitb=b;s.bitk=k;
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  s.write=q;

	  return Z_STREAM_END;
	}
	else{
	  z.msg="invalid literal/length code";

	  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;

	  s.bitb=b;s.bitk=k;
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  s.write=q;

	  return Z_DATA_ERROR;
	}
      } 
      while(true);
    } 
    while(m>=258 && n>= 10);

    // not enough input or output--restore pointers and return
    c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;

    s.bitb=b;s.bitk=k;
    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
    s.write=q;

    return Z_OK;
}

//
// InfTree.java
//

function InfTree() {
}

InfTree.prototype.huft_build = function(b, bindex, n, s, d, e, t, m, hp, hn, v) {

    // Given a list of code lengths and a maximum table size, make a set of
    // tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
    // if the given code set is incomplete (the tables are still built in this
    // case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of
    // lengths), or Z_MEM_ERROR if not enough memory.

    var a;                       // counter for codes of length k
    var f;                       // i repeats in table every f entries
    var g;                       // maximum code length
    var h;                       // table level
    var i;                       // counter, current code
    var j;                       // counter
    var k;                       // number of bits in current code
    var l;                       // bits per table (returned in m)
    var mask;                    // (1 << w) - 1, to avoid cc -O bug on HP
    var p;                       // pointer into c[], b[], or v[]
    var q;                       // points to current table
    var w;                       // bits before this table == (l * h)
    var xp;                      // pointer into x
    var y;                       // number of dummy codes added
    var z;                       // number of entries in current table

    // Generate counts for each bit length

    p = 0; i = n;
    do {
      this.c[b[bindex+p]]++; p++; i--;   // assume all entries <= BMAX
    }while(i!=0);

    if(this.c[0] == n){                // null input--all zero length codes
      t[0] = -1;
      m[0] = 0;
      return Z_OK;
    }

    // Find minimum and maximum length, bound *m by those
    l = m[0];
    for (j = 1; j <= BMAX; j++)
      if(this.c[j]!=0) break;
    k = j;                        // minimum code length
    if(l < j){
      l = j;
    }
    for (i = BMAX; i!=0; i--){
      if(this.c[i]!=0) break;
    }
    g = i;                        // maximum code length
    if(l > i){
      l = i;
    }
    m[0] = l;

    // Adjust last length count to fill out codes, if needed
    for (y = 1 << j; j < i; j++, y <<= 1){
      if ((y -= this.c[j]) < 0){
        return Z_DATA_ERROR;
      }
    }
    if ((y -= this.c[i]) < 0){
      return Z_DATA_ERROR;
    }
    this.c[i] += y;

    // Generate starting offsets into the value table for each length
    this.x[1] = j = 0;
    p = 1;  xp = 2;
    while (--i!=0) {                 // note that i == g from above
      this.x[xp] = (j += this.c[p]);
      xp++;
      p++;
    }

    // Make a table of values in order of bit lengths
    i = 0; p = 0;
    do {
      if ((j = b[bindex+p]) != 0){
        this.v[this.x[j]++] = i;
      }
      p++;
    }
    while (++i < n);
    n = this.x[g];                     // set n to length of v

    // Generate the Huffman codes and for each, make the table entries
    this.x[0] = i = 0;                 // first Huffman code is zero
    p = 0;                        // grab values in bit order
    h = -1;                       // no tables yet--level -1
    w = -l;                       // bits decoded == (l * h)
    this.u[0] = 0;                     // just to keep compilers happy
    q = 0;                        // ditto
    z = 0;                        // ditto

    // go through the bit lengths (k already is bits in shortest code)
    for (; k <= g; k++){
      a = this.c[k];
      while (a--!=0){
	// here i is the Huffman code of length k bits for value *p
	// make tables up to required level
        while (k > w + l){
          h++;
          w += l;                 // previous table always l bits
	  // compute minimum size table less than or equal to l bits
          z = g - w;
          z = (z > l) ? l : z;        // table size upper limit
          if((f=1<<(j=k-w))>a+1){     // try a k-w bit table
                                      // too few codes for k-w bit table
            f -= a + 1;               // deduct codes from patterns left
            xp = k;
            if(j < z){
              while (++j < z){        // try smaller tables up to z bits
                if((f <<= 1) <= this.c[++xp])
                  break;              // enough codes to use up j bits
                f -= this.c[xp];           // else deduct codes from patterns
              }
	    }
          }
          z = 1 << j;                 // table entries for j-bit table

	  // allocate new table
          if (this.hn[0] + z > MANY){       // (note: doesn't matter for fixed)
            return Z_DATA_ERROR;       // overflow of MANY
          }
          this.u[h] = q = /*hp+*/ this.hn[0];   // DEBUG
          this.hn[0] += z;
 
	  // connect to last table, if there is one
	  if(h!=0){
            this.x[h]=i;           // save pattern for backing up
            this.r[0]=j;     // bits in this table
            this.r[1]=l;     // bits to dump before this table
            j=i>>>(w - l);
            this.r[2] = (q - this.u[h-1] - j);               // offset to this table
            arrayCopy(this.r, 0, hp, (this.u[h-1]+j)*3, 3); // connect to last table
          }
          else{
            t[0] = q;               // first table is returned result
	  }
        }

	// set up table entry in r
        this.r[1] = (k - w);
        if (p >= n){
          this.r[0] = 128 + 64;      // out of values--invalid code
	}
        else if (v[p] < s){
          this.r[0] = (this.v[p] < 256 ? 0 : 32 + 64);  // 256 is end-of-block
          this.r[2] = this.v[p++];          // simple code is just the value
        }
        else{
          this.r[0]=(e[this.v[p]-s]+16+64); // non-simple--look up in lists
          this.r[2]=d[this.v[p++] - s];
        }

        // fill code-like entries with r
        f=1<<(k-w);
        for (j=i>>>w;j<z;j+=f){
          arrayCopy(this.r, 0, hp, (q+j)*3, 3);
	}

	// backwards increment the k-bit code i
        for (j = 1 << (k - 1); (i & j)!=0; j >>>= 1){
          i ^= j;
	}
        i ^= j;

	// backup over finished tables
        mask = (1 << w) - 1;      // needed on HP, cc -O bug
        while ((i & mask) != this.x[h]){
          h--;                    // don't need to update q
          w -= l;
          mask = (1 << w) - 1;
        }
      }
    }
    // Return Z_BUF_ERROR if we were given an incomplete table
    return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
}

InfTree.prototype.inflate_trees_bits = function(c, bb, tb, hp, z) {
    var result;
    this.initWorkArea(19);
    this.hn[0]=0;
    result = this.huft_build(c, 0, 19, 19, null, null, tb, bb, hp, this.hn, this.v);

    if(result == Z_DATA_ERROR){
      z.msg = "oversubscribed dynamic bit lengths tree";
    }
    else if(result == Z_BUF_ERROR || bb[0] == 0){
      z.msg = "incomplete dynamic bit lengths tree";
      result = Z_DATA_ERROR;
    }
    return result;
}

InfTree.prototype.inflate_trees_dynamic = function(nl, nd, c, bl, bd, tl, td, hp, z) {
    var result;

    // build literal/length tree
    this.initWorkArea(288);
    this.hn[0]=0;
    result = this.huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, this.hn, this.v);
    if (result != Z_OK || bl[0] == 0){
      if(result == Z_DATA_ERROR){
        z.msg = "oversubscribed literal/length tree";
      }
      else if (result != Z_MEM_ERROR){
        z.msg = "incomplete literal/length tree";
        result = Z_DATA_ERROR;
      }
      return result;
    }

    // build distance tree
    this.initWorkArea(288);
    result = this.huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, this.hn, this.v);

    if (result != Z_OK || (bd[0] == 0 && nl > 257)){
      if (result == Z_DATA_ERROR){
        z.msg = "oversubscribed distance tree";
      }
      else if (result == Z_BUF_ERROR) {
        z.msg = "incomplete distance tree";
        result = Z_DATA_ERROR;
      }
      else if (result != Z_MEM_ERROR){
        z.msg = "empty distance tree with lengths";
        result = Z_DATA_ERROR;
      }
      return result;
    }

    return Z_OK;
}
/*
  static int inflate_trees_fixed(int[] bl,  //literal desired/actual bit depth
                                 int[] bd,  //distance desired/actual bit depth
                                 int[][] tl,//literal/length tree result
                                 int[][] td,//distance tree result 
                                 ZStream z  //for memory allocation
				 ){

*/

function inflate_trees_fixed(bl, bd, tl, td, z) {
    bl[0]=fixed_bl;
    bd[0]=fixed_bd;
    tl[0]=fixed_tl;
    td[0]=fixed_td;
    return Z_OK;
}

InfTree.prototype.initWorkArea = function(vsize){
    if(this.hn==null){
        this.hn=new Int32Array(1);
        this.v=new Int32Array(vsize);
        this.c=new Int32Array(BMAX+1);
        this.r=new Int32Array(3);
        this.u=new Int32Array(BMAX);
        this.x=new Int32Array(BMAX+1);
    }
    if(this.v.length<vsize){ 
        this.v=new Int32Array(vsize); 
    }
    for(var i=0; i<vsize; i++){this.v[i]=0;}
    for(var i=0; i<BMAX+1; i++){this.c[i]=0;}
    for(var i=0; i<3; i++){this.r[i]=0;}
//  for(int i=0; i<BMAX; i++){u[i]=0;}
    arrayCopy(this.c, 0, this.u, 0, BMAX);
//  for(int i=0; i<BMAX+1; i++){x[i]=0;}
    arrayCopy(this.c, 0, this.x, 0, BMAX+1);
}

var testArray = new Uint8Array(1);
var hasSubarray = (typeof testArray.subarray === 'function');
var hasSlice = false; /* (typeof testArray.slice === 'function'); */ // Chrome slice performance is so dire that we're currently not using it...

function arrayCopy(src, srcOffset, dest, destOffset, count) {
    if (count == 0) {
        return;
    } 
    if (!src) {
        throw "Undef src";
    } else if (!dest) {
        throw "Undef dest";
    }

    if (srcOffset == 0 && count == src.length) {
        arrayCopy_fast(src, dest, destOffset);
    } else if (hasSubarray) {
        arrayCopy_fast(src.subarray(srcOffset, srcOffset + count), dest, destOffset); 
    } else if (src.BYTES_PER_ELEMENT == 1 && count > 100) {
        arrayCopy_fast(new Uint8Array(src.buffer, src.byteOffset + srcOffset, count), dest, destOffset);
    } else { 
        arrayCopy_slow(src, srcOffset, dest, destOffset, count);
    }

}

function arrayCopy_slow(src, srcOffset, dest, destOffset, count) {

    // dlog('_slow call: srcOffset=' + srcOffset + '; destOffset=' + destOffset + '; count=' + count);

     for (var i = 0; i < count; ++i) {
        dest[destOffset + i] = src[srcOffset + i];
    }
}

function arrayCopy_fast(src, dest, destOffset) {
    dest.set(src, destOffset);
}


  // largest prime smaller than 65536
var ADLER_BASE=65521; 
  // NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1
var ADLER_NMAX=5552;

function adler32(adler, /* byte[] */ buf,  index, len){
    if(buf == null){ return 1; }

    var s1=adler&0xffff;
    var s2=(adler>>16)&0xffff;
    var k;

    while(len > 0) {
      k=len<ADLER_NMAX?len:ADLER_NMAX;
      len-=k;
      while(k>=16){
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        k-=16;
      }
      if(k!=0){
        do{
          s1+=buf[index++]&0xff; s2+=s1;
        }
        while(--k!=0);
      }
      s1%=ADLER_BASE;
      s2%=ADLER_BASE;
    }
    return (s2<<16)|s1;
}



function jszlib_inflate_buffer(buffer, start, length, afterUncOffset) {
    if (!start) {
        buffer = new Uint8Array(buffer);
    } else if (!length) {
        buffer = new Uint8Array(buffer, start, buffer.byteLength - start);
    } else {
        buffer = new Uint8Array(buffer, start, length);
    }

    var z = new ZStream();
    z.inflateInit(DEF_WBITS, true);
    z.next_in = buffer;
    z.next_in_index = 0;
    z.avail_in = buffer.length;

    var oBlockList = [];
    var totalSize = 0;
    while (true) {
        var obuf = new Uint8Array(32000);
        z.next_out = obuf;
        z.next_out_index = 0;
        z.avail_out = obuf.length;
        var status = z.inflate(Z_NO_FLUSH);
        if (status != Z_OK && status != Z_STREAM_END && status != Z_BUF_ERROR) {
            throw z.msg;
        }
        if (z.avail_out != 0) {
            var newob = new Uint8Array(obuf.length - z.avail_out);
            arrayCopy(obuf, 0, newob, 0, (obuf.length - z.avail_out));
            obuf = newob;
        }
        oBlockList.push(obuf);
        totalSize += obuf.length;
        if (status == Z_STREAM_END || status == Z_BUF_ERROR) {
            break;
        }
    }

    if (afterUncOffset) {
        afterUncOffset[0] = (start || 0) + z.next_in_index;
    }

    if (oBlockList.length == 1) {
        return oBlockList[0].buffer;
    } else {
        var out = new Uint8Array(totalSize);
        var cursor = 0;
        for (var i = 0; i < oBlockList.length; ++i) {
            var b = oBlockList[i];
            arrayCopy(b, 0, out, cursor, b.length);
            cursor += b.length;
        }
        return out.buffer;
    }
}

if (typeof(module) !== 'undefined') {
  module.exports = {
    inflateBuffer: jszlib_inflate_buffer,
    arrayCopy: arrayCopy
  };
}

},{}],61:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],62:[function(require,module,exports){
//  Ramda v0.21.0
//  https://github.com/ramda/ramda
//  (c) 2013-2016 Scott Sauyet, Michael Hurley, and David Chambers
//  Ramda may be freely distributed under the MIT license.

;(function() {

  'use strict';

  /**
     * A special placeholder value used to specify "gaps" within curried functions,
     * allowing partial application of any combination of arguments, regardless of
     * their positions.
     *
     * If `g` is a curried ternary function and `_` is `R.__`, the following are
     * equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2, _)(1, 3)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @constant
     * @memberOf R
     * @since v0.6.0
     * @category Function
     * @example
     *
     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
     *      greet('Alice'); //=> 'Hello, Alice!'
     */
    var __ = { '@@functional/placeholder': true };

    /* eslint-disable no-unused-vars */
    var _arity = function _arity(n, fn) {
        /* eslint-disable no-unused-vars */
        switch (n) {
        case 0:
            return function () {
                return fn.apply(this, arguments);
            };
        case 1:
            return function (a0) {
                return fn.apply(this, arguments);
            };
        case 2:
            return function (a0, a1) {
                return fn.apply(this, arguments);
            };
        case 3:
            return function (a0, a1, a2) {
                return fn.apply(this, arguments);
            };
        case 4:
            return function (a0, a1, a2, a3) {
                return fn.apply(this, arguments);
            };
        case 5:
            return function (a0, a1, a2, a3, a4) {
                return fn.apply(this, arguments);
            };
        case 6:
            return function (a0, a1, a2, a3, a4, a5) {
                return fn.apply(this, arguments);
            };
        case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
                return fn.apply(this, arguments);
            };
        case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                return fn.apply(this, arguments);
            };
        case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                return fn.apply(this, arguments);
            };
        case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                return fn.apply(this, arguments);
            };
        default:
            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
        }
    };

    var _arrayFromIterator = function _arrayFromIterator(iter) {
        var list = [];
        var next;
        while (!(next = iter.next()).done) {
            list.push(next.value);
        }
        return list;
    };

    var _arrayOf = function _arrayOf() {
        return Array.prototype.slice.call(arguments);
    };

    var _cloneRegExp = function _cloneRegExp(pattern) {
        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
    };

    var _complement = function _complement(f) {
        return function () {
            return !f.apply(this, arguments);
        };
    };

    /**
     * Private `concat` function to merge two array-like objects.
     *
     * @private
     * @param {Array|Arguments} [set1=[]] An array-like object.
     * @param {Array|Arguments} [set2=[]] An array-like object.
     * @return {Array} A new, merged array.
     * @example
     *
     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     */
    var _concat = function _concat(set1, set2) {
        set1 = set1 || [];
        set2 = set2 || [];
        var idx;
        var len1 = set1.length;
        var len2 = set2.length;
        var result = [];
        idx = 0;
        while (idx < len1) {
            result[result.length] = set1[idx];
            idx += 1;
        }
        idx = 0;
        while (idx < len2) {
            result[result.length] = set2[idx];
            idx += 1;
        }
        return result;
    };

    var _containsWith = function _containsWith(pred, x, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (pred(x, list[idx])) {
                return true;
            }
            idx += 1;
        }
        return false;
    };

    var _filter = function _filter(fn, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        while (idx < len) {
            if (fn(list[idx])) {
                result[result.length] = list[idx];
            }
            idx += 1;
        }
        return result;
    };

    var _forceReduced = function _forceReduced(x) {
        return {
            '@@transducer/value': x,
            '@@transducer/reduced': true
        };
    };

    // String(x => x) evaluates to "x => x", so the pattern may not match.
    var _functionName = function _functionName(f) {
        // String(x => x) evaluates to "x => x", so the pattern may not match.
        var match = String(f).match(/^function (\w*)/);
        return match == null ? '' : match[1];
    };

    var _has = function _has(prop, obj) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    };

    var _identity = function _identity(x) {
        return x;
    };

    var _isArguments = function () {
        var toString = Object.prototype.toString;
        return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
            return toString.call(x) === '[object Arguments]';
        } : function _isArguments(x) {
            return _has('callee', x);
        };
    }();

    /**
     * Tests whether or not an object is an array.
     *
     * @private
     * @param {*} val The object to test.
     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
     * @example
     *
     *      _isArray([]); //=> true
     *      _isArray(null); //=> false
     *      _isArray({}); //=> false
     */
    var _isArray = Array.isArray || function _isArray(val) {
        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
    };

    var _isFunction = function _isNumber(x) {
        return Object.prototype.toString.call(x) === '[object Function]';
    };

    /**
     * Determine if the passed argument is an integer.
     *
     * @private
     * @param {*} n
     * @category Type
     * @return {Boolean}
     */
    var _isInteger = Number.isInteger || function _isInteger(n) {
        return n << 0 === n;
    };

    var _isNumber = function _isNumber(x) {
        return Object.prototype.toString.call(x) === '[object Number]';
    };

    var _isObject = function _isObject(x) {
        return Object.prototype.toString.call(x) === '[object Object]';
    };

    var _isPlaceholder = function _isPlaceholder(a) {
        return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
    };

    var _isRegExp = function _isRegExp(x) {
        return Object.prototype.toString.call(x) === '[object RegExp]';
    };

    var _isString = function _isString(x) {
        return Object.prototype.toString.call(x) === '[object String]';
    };

    var _isTransformer = function _isTransformer(obj) {
        return typeof obj['@@transducer/step'] === 'function';
    };

    var _map = function _map(fn, functor) {
        var idx = 0;
        var len = functor.length;
        var result = Array(len);
        while (idx < len) {
            result[idx] = fn(functor[idx]);
            idx += 1;
        }
        return result;
    };

    // Based on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    var _objectAssign = function _objectAssign(target) {
        if (target == null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }
        var output = Object(target);
        var idx = 1;
        var length = arguments.length;
        while (idx < length) {
            var source = arguments[idx];
            if (source != null) {
                for (var nextKey in source) {
                    if (_has(nextKey, source)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
            idx += 1;
        }
        return output;
    };

    var _of = function _of(x) {
        return [x];
    };

    var _pipe = function _pipe(f, g) {
        return function () {
            return g.call(this, f.apply(this, arguments));
        };
    };

    var _pipeP = function _pipeP(f, g) {
        return function () {
            var ctx = this;
            return f.apply(ctx, arguments).then(function (x) {
                return g.call(ctx, x);
            });
        };
    };

    // \b matches word boundary; [\b] matches backspace
    var _quote = function _quote(s) {
        var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b')    // \b matches word boundary; [\b] matches backspace
    .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
        return '"' + escaped.replace(/"/g, '\\"') + '"';
    };

    var _reduced = function _reduced(x) {
        return x && x['@@transducer/reduced'] ? x : {
            '@@transducer/value': x,
            '@@transducer/reduced': true
        };
    };

    /**
     * An optimized, private array `slice` implementation.
     *
     * @private
     * @param {Arguments|Array} args The array or arguments object to consider.
     * @param {Number} [from=0] The array index to slice from, inclusive.
     * @param {Number} [to=args.length] The array index to slice to, exclusive.
     * @return {Array} A new, sliced array.
     * @example
     *
     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
     *
     *      var firstThreeArgs = function(a, b, c, d) {
     *        return _slice(arguments, 0, 3);
     *      };
     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
     */
    var _slice = function _slice(args, from, to) {
        switch (arguments.length) {
        case 1:
            return _slice(args, 0, args.length);
        case 2:
            return _slice(args, from, args.length);
        default:
            var list = [];
            var idx = 0;
            var len = Math.max(0, Math.min(args.length, to) - from);
            while (idx < len) {
                list[idx] = args[from + idx];
                idx += 1;
            }
            return list;
        }
    };

    /**
     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
     */
    var _toISOString = function () {
        var pad = function pad(n) {
            return (n < 10 ? '0' : '') + n;
        };
        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
            return d.toISOString();
        } : function _toISOString(d) {
            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
        };
    }();

    var _xfBase = {
        init: function () {
            return this.xf['@@transducer/init']();
        },
        result: function (result) {
            return this.xf['@@transducer/result'](result);
        }
    };

    var _xwrap = function () {
        function XWrap(fn) {
            this.f = fn;
        }
        XWrap.prototype['@@transducer/init'] = function () {
            throw new Error('init not implemented on XWrap');
        };
        XWrap.prototype['@@transducer/result'] = function (acc) {
            return acc;
        };
        XWrap.prototype['@@transducer/step'] = function (acc, x) {
            return this.f(acc, x);
        };
        return function _xwrap(fn) {
            return new XWrap(fn);
        };
    }();

    var _aperture = function _aperture(n, list) {
        var idx = 0;
        var limit = list.length - (n - 1);
        var acc = new Array(limit >= 0 ? limit : 0);
        while (idx < limit) {
            acc[idx] = _slice(list, idx, idx + n);
            idx += 1;
        }
        return acc;
    };

    var _assign = typeof Object.assign === 'function' ? Object.assign : _objectAssign;

    /**
     * Similar to hasMethod, this checks whether a function has a [methodname]
     * function. If it isn't an array it will execute that function otherwise it
     * will default to the ramda implementation.
     *
     * @private
     * @param {Function} fn ramda implemtation
     * @param {String} methodname property to check for a custom implementation
     * @return {Object} Whatever the return value of the method is.
     */
    var _checkForMethod = function _checkForMethod(methodname, fn) {
        return function () {
            var length = arguments.length;
            if (length === 0) {
                return fn();
            }
            var obj = arguments[length - 1];
            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
        };
    };

    /**
     * Optimized internal one-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry1 = function _curry1(fn) {
        return function f1(a) {
            if (arguments.length === 0 || _isPlaceholder(a)) {
                return f1;
            } else {
                return fn.apply(this, arguments);
            }
        };
    };

    /**
     * Optimized internal two-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry2 = function _curry2(fn) {
        return function f2(a, b) {
            switch (arguments.length) {
            case 0:
                return f2;
            case 1:
                return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
                    return fn(a, _b);
                });
            default:
                return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
                    return fn(_a, b);
                }) : _isPlaceholder(b) ? _curry1(function (_b) {
                    return fn(a, _b);
                }) : fn(a, b);
            }
        };
    };

    /**
     * Optimized internal three-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry3 = function _curry3(fn) {
        return function f3(a, b, c) {
            switch (arguments.length) {
            case 0:
                return f3;
            case 1:
                return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
                    return fn(a, _b, _c);
                });
            case 2:
                return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
                    return fn(_a, b, _c);
                }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
                    return fn(a, _b, _c);
                }) : _curry1(function (_c) {
                    return fn(a, b, _c);
                });
            default:
                return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
                    return fn(_a, _b, c);
                }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
                    return fn(_a, b, _c);
                }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
                    return fn(a, _b, _c);
                }) : _isPlaceholder(a) ? _curry1(function (_a) {
                    return fn(_a, b, c);
                }) : _isPlaceholder(b) ? _curry1(function (_b) {
                    return fn(a, _b, c);
                }) : _isPlaceholder(c) ? _curry1(function (_c) {
                    return fn(a, b, _c);
                }) : fn(a, b, c);
            }
        };
    };

    /**
     * Internal curryN function.
     *
     * @private
     * @category Function
     * @param {Number} length The arity of the curried function.
     * @param {Array} received An array of arguments received thus far.
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curryN = function _curryN(length, received, fn) {
        return function () {
            var combined = [];
            var argsIdx = 0;
            var left = length;
            var combinedIdx = 0;
            while (combinedIdx < received.length || argsIdx < arguments.length) {
                var result;
                if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
                    result = received[combinedIdx];
                } else {
                    result = arguments[argsIdx];
                    argsIdx += 1;
                }
                combined[combinedIdx] = result;
                if (!_isPlaceholder(result)) {
                    left -= 1;
                }
                combinedIdx += 1;
            }
            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
        };
    };

    /**
     * Returns a function that dispatches with different strategies based on the
     * object in list position (last argument). If it is an array, executes [fn].
     * Otherwise, if it has a function with [methodname], it will execute that
     * function (functor case). Otherwise, if it is a transformer, uses transducer
     * [xf] to return a new transformer (transducer case). Otherwise, it will
     * default to executing [fn].
     *
     * @private
     * @param {String} methodname property to check for a custom implementation
     * @param {Function} xf transducer to initialize if object is transformer
     * @param {Function} fn default ramda implementation
     * @return {Function} A function that dispatches on object in list position
     */
    var _dispatchable = function _dispatchable(methodname, xf, fn) {
        return function () {
            var length = arguments.length;
            if (length === 0) {
                return fn();
            }
            var obj = arguments[length - 1];
            if (!_isArray(obj)) {
                var args = _slice(arguments, 0, length - 1);
                if (typeof obj[methodname] === 'function') {
                    return obj[methodname].apply(obj, args);
                }
                if (_isTransformer(obj)) {
                    var transducer = xf.apply(null, args);
                    return transducer(obj);
                }
            }
            return fn.apply(this, arguments);
        };
    };

    var _dropLastWhile = function dropLastWhile(pred, list) {
        var idx = list.length - 1;
        while (idx >= 0 && pred(list[idx])) {
            idx -= 1;
        }
        return _slice(list, 0, idx + 1);
    };

    var _xall = function () {
        function XAll(f, xf) {
            this.xf = xf;
            this.f = f;
            this.all = true;
        }
        XAll.prototype['@@transducer/init'] = _xfBase.init;
        XAll.prototype['@@transducer/result'] = function (result) {
            if (this.all) {
                result = this.xf['@@transducer/step'](result, true);
            }
            return this.xf['@@transducer/result'](result);
        };
        XAll.prototype['@@transducer/step'] = function (result, input) {
            if (!this.f(input)) {
                this.all = false;
                result = _reduced(this.xf['@@transducer/step'](result, false));
            }
            return result;
        };
        return _curry2(function _xall(f, xf) {
            return new XAll(f, xf);
        });
    }();

    var _xany = function () {
        function XAny(f, xf) {
            this.xf = xf;
            this.f = f;
            this.any = false;
        }
        XAny.prototype['@@transducer/init'] = _xfBase.init;
        XAny.prototype['@@transducer/result'] = function (result) {
            if (!this.any) {
                result = this.xf['@@transducer/step'](result, false);
            }
            return this.xf['@@transducer/result'](result);
        };
        XAny.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.any = true;
                result = _reduced(this.xf['@@transducer/step'](result, true));
            }
            return result;
        };
        return _curry2(function _xany(f, xf) {
            return new XAny(f, xf);
        });
    }();

    var _xaperture = function () {
        function XAperture(n, xf) {
            this.xf = xf;
            this.pos = 0;
            this.full = false;
            this.acc = new Array(n);
        }
        XAperture.prototype['@@transducer/init'] = _xfBase.init;
        XAperture.prototype['@@transducer/result'] = function (result) {
            this.acc = null;
            return this.xf['@@transducer/result'](result);
        };
        XAperture.prototype['@@transducer/step'] = function (result, input) {
            this.store(input);
            return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
        };
        XAperture.prototype.store = function (input) {
            this.acc[this.pos] = input;
            this.pos += 1;
            if (this.pos === this.acc.length) {
                this.pos = 0;
                this.full = true;
            }
        };
        XAperture.prototype.getCopy = function () {
            return _concat(_slice(this.acc, this.pos), _slice(this.acc, 0, this.pos));
        };
        return _curry2(function _xaperture(n, xf) {
            return new XAperture(n, xf);
        });
    }();

    var _xdrop = function () {
        function XDrop(n, xf) {
            this.xf = xf;
            this.n = n;
        }
        XDrop.prototype['@@transducer/init'] = _xfBase.init;
        XDrop.prototype['@@transducer/result'] = _xfBase.result;
        XDrop.prototype['@@transducer/step'] = function (result, input) {
            if (this.n > 0) {
                this.n -= 1;
                return result;
            }
            return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdrop(n, xf) {
            return new XDrop(n, xf);
        });
    }();

    var _xdropLast = function () {
        function XDropLast(n, xf) {
            this.xf = xf;
            this.pos = 0;
            this.full = false;
            this.acc = new Array(n);
        }
        XDropLast.prototype['@@transducer/init'] = _xfBase.init;
        XDropLast.prototype['@@transducer/result'] = function (result) {
            this.acc = null;
            return this.xf['@@transducer/result'](result);
        };
        XDropLast.prototype['@@transducer/step'] = function (result, input) {
            if (this.full) {
                result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
            }
            this.store(input);
            return result;
        };
        XDropLast.prototype.store = function (input) {
            this.acc[this.pos] = input;
            this.pos += 1;
            if (this.pos === this.acc.length) {
                this.pos = 0;
                this.full = true;
            }
        };
        return _curry2(function _xdropLast(n, xf) {
            return new XDropLast(n, xf);
        });
    }();

    var _xdropRepeatsWith = function () {
        function XDropRepeatsWith(pred, xf) {
            this.xf = xf;
            this.pred = pred;
            this.lastValue = undefined;
            this.seenFirstValue = false;
        }
        XDropRepeatsWith.prototype['@@transducer/init'] = function () {
            return this.xf['@@transducer/init']();
        };
        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](result);
        };
        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
            var sameAsLast = false;
            if (!this.seenFirstValue) {
                this.seenFirstValue = true;
            } else if (this.pred(this.lastValue, input)) {
                sameAsLast = true;
            }
            this.lastValue = input;
            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropRepeatsWith(pred, xf) {
            return new XDropRepeatsWith(pred, xf);
        });
    }();

    var _xdropWhile = function () {
        function XDropWhile(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
        XDropWhile.prototype['@@transducer/step'] = function (result, input) {
            if (this.f) {
                if (this.f(input)) {
                    return result;
                }
                this.f = null;
            }
            return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropWhile(f, xf) {
            return new XDropWhile(f, xf);
        });
    }();

    var _xfilter = function () {
        function XFilter(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XFilter.prototype['@@transducer/init'] = _xfBase.init;
        XFilter.prototype['@@transducer/result'] = _xfBase.result;
        XFilter.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
        };
        return _curry2(function _xfilter(f, xf) {
            return new XFilter(f, xf);
        });
    }();

    var _xfind = function () {
        function XFind(f, xf) {
            this.xf = xf;
            this.f = f;
            this.found = false;
        }
        XFind.prototype['@@transducer/init'] = _xfBase.init;
        XFind.prototype['@@transducer/result'] = function (result) {
            if (!this.found) {
                result = this.xf['@@transducer/step'](result, void 0);
            }
            return this.xf['@@transducer/result'](result);
        };
        XFind.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.found = true;
                result = _reduced(this.xf['@@transducer/step'](result, input));
            }
            return result;
        };
        return _curry2(function _xfind(f, xf) {
            return new XFind(f, xf);
        });
    }();

    var _xfindIndex = function () {
        function XFindIndex(f, xf) {
            this.xf = xf;
            this.f = f;
            this.idx = -1;
            this.found = false;
        }
        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindIndex.prototype['@@transducer/result'] = function (result) {
            if (!this.found) {
                result = this.xf['@@transducer/step'](result, -1);
            }
            return this.xf['@@transducer/result'](result);
        };
        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
            this.idx += 1;
            if (this.f(input)) {
                this.found = true;
                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
            }
            return result;
        };
        return _curry2(function _xfindIndex(f, xf) {
            return new XFindIndex(f, xf);
        });
    }();

    var _xfindLast = function () {
        function XFindLast(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
        XFindLast.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
        };
        XFindLast.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.last = input;
            }
            return result;
        };
        return _curry2(function _xfindLast(f, xf) {
            return new XFindLast(f, xf);
        });
    }();

    var _xfindLastIndex = function () {
        function XFindLastIndex(f, xf) {
            this.xf = xf;
            this.f = f;
            this.idx = -1;
            this.lastIdx = -1;
        }
        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindLastIndex.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
        };
        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
            this.idx += 1;
            if (this.f(input)) {
                this.lastIdx = this.idx;
            }
            return result;
        };
        return _curry2(function _xfindLastIndex(f, xf) {
            return new XFindLastIndex(f, xf);
        });
    }();

    var _xmap = function () {
        function XMap(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XMap.prototype['@@transducer/init'] = _xfBase.init;
        XMap.prototype['@@transducer/result'] = _xfBase.result;
        XMap.prototype['@@transducer/step'] = function (result, input) {
            return this.xf['@@transducer/step'](result, this.f(input));
        };
        return _curry2(function _xmap(f, xf) {
            return new XMap(f, xf);
        });
    }();

    var _xtake = function () {
        function XTake(n, xf) {
            this.xf = xf;
            this.n = n;
        }
        XTake.prototype['@@transducer/init'] = _xfBase.init;
        XTake.prototype['@@transducer/result'] = _xfBase.result;
        XTake.prototype['@@transducer/step'] = function (result, input) {
            if (this.n === 0) {
                return _reduced(result);
            } else {
                this.n -= 1;
                return this.xf['@@transducer/step'](result, input);
            }
        };
        return _curry2(function _xtake(n, xf) {
            return new XTake(n, xf);
        });
    }();

    var _xtakeWhile = function () {
        function XTakeWhile(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
        };
        return _curry2(function _xtakeWhile(f, xf) {
            return new XTakeWhile(f, xf);
        });
    }();

    /**
     * Adds two values.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a
     * @param {Number} b
     * @return {Number}
     * @see R.subtract
     * @example
     *
     *      R.add(2, 3);       //=>  5
     *      R.add(7)(10);      //=> 17
     */
    var add = _curry2(function add(a, b) {
        return Number(a) + Number(b);
    });

    /**
     * Applies a function to the value at the given index of an array, returning a
     * new copy of the array with the element at the given index replaced with the
     * result of the function application.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig (a -> a) -> Number -> [a] -> [a]
     * @param {Function} fn The function to apply.
     * @param {Number} idx The index.
     * @param {Array|Arguments} list An array-like object whose value
     *        at the supplied index will be replaced.
     * @return {Array} A copy of the supplied array-like object with
     *         the element at index `idx` replaced with the value
     *         returned by applying `fn` to the existing element.
     * @see R.update
     * @example
     *
     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]
     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]
     */
    var adjust = _curry3(function adjust(fn, idx, list) {
        if (idx >= list.length || idx < -list.length) {
            return list;
        }
        var start = idx < 0 ? list.length : 0;
        var _idx = start + idx;
        var _list = _concat(list);
        _list[_idx] = fn(list[_idx]);
        return _list;
    });

    /**
     * Returns `true` if all elements of the list match the predicate, `false` if
     * there are any that don't.
     *
     * Dispatches to the `all` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
     *         otherwise.
     * @see R.any, R.none, R.transduce
     * @example
     *
     *      var lessThan2 = R.flip(R.lt)(2);
     *      var lessThan3 = R.flip(R.lt)(3);
     *      R.all(lessThan2)([1, 2]); //=> false
     *      R.all(lessThan3)([1, 2]); //=> true
     */
    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
        var idx = 0;
        while (idx < list.length) {
            if (!fn(list[idx])) {
                return false;
            }
            idx += 1;
        }
        return true;
    }));

    /**
     * Returns a function that always returns the given value. Note that for
     * non-primitives the value returned is a reference to the original value.
     *
     * This function is known as `const`, `constant`, or `K` (for K combinator) in
     * other languages and libraries.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig a -> (* -> a)
     * @param {*} val The value to wrap in a function
     * @return {Function} A Function :: * -> val.
     * @example
     *
     *      var t = R.always('Tee');
     *      t(); //=> 'Tee'
     */
    var always = _curry1(function always(val) {
        return function () {
            return val;
        };
    });

    /**
     * Returns `true` if both arguments are `true`; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> * -> *
     * @param {Boolean} a A boolean value
     * @param {Boolean} b A boolean value
     * @return {Boolean} `true` if both arguments are `true`, `false` otherwise
     * @see R.both
     * @example
     *
     *      R.and(true, true); //=> true
     *      R.and(true, false); //=> false
     *      R.and(false, true); //=> false
     *      R.and(false, false); //=> false
     */
    var and = _curry2(function and(a, b) {
        return a && b;
    });

    /**
     * Returns `true` if at least one of elements of the list match the predicate,
     * `false` otherwise.
     *
     * Dispatches to the `any` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
     *         otherwise.
     * @see R.all, R.none, R.transduce
     * @example
     *
     *      var lessThan0 = R.flip(R.lt)(0);
     *      var lessThan2 = R.flip(R.lt)(2);
     *      R.any(lessThan0)([1, 2]); //=> false
     *      R.any(lessThan2)([1, 2]); //=> true
     */
    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
        var idx = 0;
        while (idx < list.length) {
            if (fn(list[idx])) {
                return true;
            }
            idx += 1;
        }
        return false;
    }));

    /**
     * Returns a new list, composed of n-tuples of consecutive elements If `n` is
     * greater than the length of the list, an empty list is returned.
     *
     * Dispatches to the `aperture` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig Number -> [a] -> [[a]]
     * @param {Number} n The size of the tuples to create
     * @param {Array} list The list to split into `n`-tuples
     * @return {Array} The new list.
     * @see R.transduce
     * @example
     *
     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
     */
    var aperture = _curry2(_dispatchable('aperture', _xaperture, _aperture));

    /**
     * Returns a new list containing the contents of the given list, followed by
     * the given element.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} el The element to add to the end of the new list.
     * @param {Array} list The list whose contents will be added to the beginning of the output
     *        list.
     * @return {Array} A new list containing the contents of the old list followed by `el`.
     * @see R.prepend
     * @example
     *
     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
     *      R.append('tests', []); //=> ['tests']
     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
     */
    var append = _curry2(function append(el, list) {
        return _concat(list, [el]);
    });

    /**
     * Applies function `fn` to the argument list `args`. This is useful for
     * creating a fixed-arity function from a variadic function. `fn` should be a
     * bound function if context is significant.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Function
     * @sig (*... -> a) -> [*] -> a
     * @param {Function} fn
     * @param {Array} args
     * @return {*}
     * @see R.call, R.unapply
     * @example
     *
     *      var nums = [1, 2, 3, -99, 42, 6, 7];
     *      R.apply(Math.max, nums); //=> 42
     */
    var apply = _curry2(function apply(fn, args) {
        return fn.apply(this, args);
    });

    /**
     * Makes a shallow clone of an object, setting or overriding the specified
     * property with the given value. Note that this copies and flattens prototype
     * properties onto the new object as well. All non-primitive properties are
     * copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig String -> a -> {k: v} -> {k: v}
     * @param {String} prop the property name to set
     * @param {*} val the new value
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original except for the specified property.
     * @see R.dissoc
     * @example
     *
     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
     */
    var assoc = _curry3(function assoc(prop, val, obj) {
        var result = {};
        for (var p in obj) {
            result[p] = obj[p];
        }
        result[prop] = val;
        return result;
    });

    /**
     * Makes a shallow clone of an object, setting or overriding the nodes required
     * to create the given path, and placing the specific value at the tail end of
     * that path. Note that this copies and flattens prototype properties onto the
     * new object as well. All non-primitive properties are copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig [String] -> a -> {k: v} -> {k: v}
     * @param {Array} path the path to set
     * @param {*} val the new value
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original except along the specified path.
     * @see R.dissocPath
     * @example
     *
     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
     */
    var assocPath = _curry3(function assocPath(path, val, obj) {
        switch (path.length) {
        case 0:
            return val;
        case 1:
            return assoc(path[0], val, obj);
        default:
            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
        }
    });

    /**
     * Creates a function that is bound to a context.
     * Note: `R.bind` does not provide the additional argument-binding capabilities of
     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Function
     * @category Object
     * @sig (* -> *) -> {*} -> (* -> *)
     * @param {Function} fn The function to bind to context
     * @param {Object} thisObj The context to bind `fn` to
     * @return {Function} A function that will execute in the context of `thisObj`.
     * @see R.partial
     */
    var bind = _curry2(function bind(fn, thisObj) {
        return _arity(fn.length, function () {
            return fn.apply(thisObj, arguments);
        });
    });

    /**
     * Restricts a number to be within a range.
     *
     * Also works for other ordered types such as Strings and Dates.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Relation
     * @sig Ord a => a -> a -> a -> a
     * @param {Number} minimum number
     * @param {Number} maximum number
     * @param {Number} value to be clamped
     * @return {Number} Returns the clamped value
     * @example
     *
     *      R.clamp(1, 10, -1) // => 1
     *      R.clamp(1, 10, 11) // => 10
     *      R.clamp(1, 10, 4)  // => 4
     */
    var clamp = _curry3(function clamp(min, max, value) {
        if (min > max) {
            throw new Error('min must not be greater than max in clamp(min, max, value)');
        }
        return value < min ? min : value > max ? max : value;
    });

    /**
     * Makes a comparator function out of a function that reports whether the first
     * element is less than the second.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a, b -> Boolean) -> (a, b -> Number)
     * @param {Function} pred A predicate function of arity two.
     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.
     * @example
     *
     *      var cmp = R.comparator((a, b) => a.age < b.age);
     *      var people = [
     *        // ...
     *      ];
     *      R.sort(cmp, people);
     */
    var comparator = _curry1(function comparator(pred) {
        return function (a, b) {
            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
        };
    });

    /**
     * Returns a curried equivalent of the provided function, with the specified
     * arity. The curried function has two unusual capabilities. First, its
     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
     * following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
     * following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.5.0
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curry
     * @example
     *
     *      var sumArgs = (...args) => R.sum(args);
     *
     *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
    var curryN = _curry2(function curryN(length, fn) {
        if (length === 1) {
            return _curry1(fn);
        }
        return _arity(length, _curryN(length, [], fn));
    });

    /**
     * Decrements its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @see R.inc
     * @example
     *
     *      R.dec(42); //=> 41
     */
    var dec = add(-1);

    /**
     * Returns the second argument if it is not `null`, `undefined` or `NaN`
     * otherwise the first argument is returned.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Logic
     * @sig a -> b -> a | b
     * @param {a} val The default value.
     * @param {b} val The value to return if it is not null or undefined
     * @return {*} The the second value or the default value
     * @example
     *
     *      var defaultTo42 = R.defaultTo(42);
     *
     *      defaultTo42(null);  //=> 42
     *      defaultTo42(undefined);  //=> 42
     *      defaultTo42('Ramda');  //=> 'Ramda'
     *      defaultTo42(parseInt('string')); //=> 42
     */
    var defaultTo = _curry2(function defaultTo(d, v) {
        return v == null || v !== v ? d : v;
    });

    /**
     * Finds the set (i.e. no duplicates) of all elements in the first list not
     * contained in the second list. Duplication is determined according to the
     * value returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` that are not in `list2`.
     * @see R.difference
     * @example
     *
     *      var cmp = (x, y) => x.a === y.a;
     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
     *      var l2 = [{a: 3}, {a: 4}];
     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
     */
    var differenceWith = _curry3(function differenceWith(pred, first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        while (idx < firstLen) {
            if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {
                out.push(first[idx]);
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new object that does not contain a `prop` property.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Object
     * @sig String -> {k: v} -> {k: v}
     * @param {String} prop the name of the property to dissociate
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original but without the specified property
     * @see R.assoc
     * @example
     *
     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
     */
    var dissoc = _curry2(function dissoc(prop, obj) {
        var result = {};
        for (var p in obj) {
            if (p !== prop) {
                result[p] = obj[p];
            }
        }
        return result;
    });

    /**
     * Makes a shallow clone of an object, omitting the property at the given path.
     * Note that this copies and flattens prototype properties onto the new object
     * as well. All non-primitive properties are copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.11.0
     * @category Object
     * @sig [String] -> {k: v} -> {k: v}
     * @param {Array} path the path to set
     * @param {Object} obj the object to clone
     * @return {Object} a new object without the property at path
     * @see R.assocPath
     * @example
     *
     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
     */
    var dissocPath = _curry2(function dissocPath(path, obj) {
        switch (path.length) {
        case 0:
            return obj;
        case 1:
            return dissoc(path[0], obj);
        default:
            var head = path[0];
            var tail = _slice(path, 1);
            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
        }
    });

    /**
     * Divides two numbers. Equivalent to `a / b`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a / b`.
     * @see R.multiply
     * @example
     *
     *      R.divide(71, 100); //=> 0.71
     *
     *      var half = R.divide(R.__, 2);
     *      half(42); //=> 21
     *
     *      var reciprocal = R.divide(1);
     *      reciprocal(4);   //=> 0.25
     */
    var divide = _curry2(function divide(a, b) {
        return a / b;
    });

    /**
     * Returns a new list containing the last `n` elements of a given list, passing
     * each value to the supplied predicate function, skipping elements while the
     * predicate function returns `true`. The predicate function is passed one
     * argument: *(value)*.
     *
     * Dispatches to the `dropWhile` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.takeWhile, R.transduce, R.addIndex
     * @example
     *
     *      var lteTwo = x => x <= 2;
     *
     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
     */
    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len && pred(list[idx])) {
            idx += 1;
        }
        return _slice(list, idx);
    }));

    /**
     * Returns the empty value of its argument's type. Ramda defines the empty
     * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
     * types are supported if they define `<Type>.empty` and/or
     * `<Type>.prototype.empty`.
     *
     * Dispatches to the `empty` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig a -> a
     * @param {*} x
     * @return {*}
     * @example
     *
     *      R.empty(Just(42));      //=> Nothing()
     *      R.empty([1, 2, 3]);     //=> []
     *      R.empty('unicorns');    //=> ''
     *      R.empty({x: 1, y: 2});  //=> {}
     */
    // else
    var empty = _curry1(function empty(x) {
        return x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
            return arguments;
        }() : // else
        void 0;
    });

    /**
     * Creates a new object by recursively evolving a shallow copy of `object`,
     * according to the `transformation` functions. All non-primitive properties
     * are copied by reference.
     *
     * A `transformation` function will not be invoked if its corresponding key
     * does not exist in the evolved object.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {k: (v -> v)} -> {k: v} -> {k: v}
     * @param {Object} transformations The object specifying transformation functions to apply
     *        to the object.
     * @param {Object} object The object to be transformed.
     * @return {Object} The transformed object.
     * @example
     *
     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
     *      var transformations = {
     *        firstName: R.trim,
     *        lastName: R.trim, // Will not get invoked.
     *        data: {elapsed: R.add(1), remaining: R.add(-1)}
     *      };
     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
     */
    var evolve = _curry2(function evolve(transformations, object) {
        var result = {};
        var transformation, key, type;
        for (key in object) {
            transformation = transformations[key];
            type = typeof transformation;
            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
        }
        return result;
    });

    /**
     * Returns the first element of the list which matches the predicate, or
     * `undefined` if no element matches.
     *
     * Dispatches to the `find` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> a | undefined
     * @param {Function} fn The predicate function used to determine if the element is the
     *        desired one.
     * @param {Array} list The array to consider.
     * @return {Object} The element found, or `undefined`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
     *      R.find(R.propEq('a', 4))(xs); //=> undefined
     */
    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (fn(list[idx])) {
                return list[idx];
            }
            idx += 1;
        }
    }));

    /**
     * Returns the index of the first element of the list which matches the
     * predicate, or `-1` if no element matches.
     *
     * Dispatches to the `findIndex` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
     */
    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (fn(list[idx])) {
                return idx;
            }
            idx += 1;
        }
        return -1;
    }));

    /**
     * Returns the last element of the list which matches the predicate, or
     * `undefined` if no element matches.
     *
     * Dispatches to the `findLast` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> a | undefined
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Object} The element found, or `undefined`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
     */
    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            if (fn(list[idx])) {
                return list[idx];
            }
            idx -= 1;
        }
    }));

    /**
     * Returns the index of the last element of the list which matches the
     * predicate, or `-1` if no element matches.
     *
     * Dispatches to the `findLastIndex` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @see R.transduce
     * @example
     *
     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
     */
    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            if (fn(list[idx])) {
                return idx;
            }
            idx -= 1;
        }
        return -1;
    }));

    /**
     * Iterate over an input `list`, calling a provided function `fn` for each
     * element in the list.
     *
     * `fn` receives one argument: *(value)*.
     *
     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.forEach` method. For more
     * details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
     *
     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
     * the original array. In some libraries this function is named `each`.
     *
     * Dispatches to the `forEach` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> *) -> [a] -> [a]
     * @param {Function} fn The function to invoke. Receives one argument, `value`.
     * @param {Array} list The list to iterate over.
     * @return {Array} The original list.
     * @see R.addIndex
     * @example
     *
     *      var printXPlusFive = x => console.log(x + 5);
     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
     *      //-> 6
     *      //-> 7
     *      //-> 8
     */
    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            fn(list[idx]);
            idx += 1;
        }
        return list;
    }));

    /**
     * Creates a new object out of a list key-value pairs.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [[k,v]] -> {k: v}
     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
     * @return {Object} The object made by pairing up `keys` and `values`.
     * @see R.toPairs, R.pair
     * @example
     *
     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}
     */
    var fromPairs = _curry1(function fromPairs(pairs) {
        var idx = 0;
        var len = pairs.length;
        var out = {};
        while (idx < len) {
            if (_isArray(pairs[idx]) && pairs[idx].length) {
                out[pairs[idx][0]] = pairs[idx][1];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Takes a list and returns a list of lists where each sublist's elements are
     * all "equal" according to the provided equality function.
     *
     * @func
     * @memberOf R
     * @since v0.21.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [[a]]
     * @param {Function} fn Function for determining whether two given (adjacent)
     *        elements should be in the same group
     * @param {Array} list The array to group. Also accepts a string, which will be
     *        treated as a list of characters.
     * @return {List} A list that contains sublists of equal elements,
     *         whose concatenations is equal to the original list.
     * @example
     *
     *    groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
     *    // [[0], [1, 1], [2, 3, 5, 8, 13, 21]]
     *
     *    groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
     *    // [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
     *
     *    R.groupWith(R.eqBy(isVowel), 'aestiou')
     *    // ['ae', 'st', 'iou']
     */
    var groupWith = _curry2(function (fn, list) {
        var res = [];
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            var nextidx = idx + 1;
            while (nextidx < len && fn(list[idx], list[nextidx])) {
                nextidx += 1;
            }
            res.push(list.slice(idx, nextidx));
            idx = nextidx;
        }
        return res;
    });

    /**
     * Returns `true` if the first argument is greater than the second; `false`
     * otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @see R.lt
     * @example
     *
     *      R.gt(2, 1); //=> true
     *      R.gt(2, 2); //=> false
     *      R.gt(2, 3); //=> false
     *      R.gt('a', 'z'); //=> false
     *      R.gt('z', 'a'); //=> true
     */
    var gt = _curry2(function gt(a, b) {
        return a > b;
    });

    /**
     * Returns `true` if the first argument is greater than or equal to the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {Number} a
     * @param {Number} b
     * @return {Boolean}
     * @see R.lte
     * @example
     *
     *      R.gte(2, 1); //=> true
     *      R.gte(2, 2); //=> true
     *      R.gte(2, 3); //=> false
     *      R.gte('a', 'z'); //=> false
     *      R.gte('z', 'a'); //=> true
     */
    var gte = _curry2(function gte(a, b) {
        return a >= b;
    });

    /**
     * Returns whether or not an object has an own property with the specified name
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Object
     * @sig s -> {s: x} -> Boolean
     * @param {String} prop The name of the property to check for.
     * @param {Object} obj The object to query.
     * @return {Boolean} Whether the property exists.
     * @example
     *
     *      var hasName = R.has('name');
     *      hasName({name: 'alice'});   //=> true
     *      hasName({name: 'bob'});     //=> true
     *      hasName({});                //=> false
     *
     *      var point = {x: 0, y: 0};
     *      var pointHas = R.has(R.__, point);
     *      pointHas('x');  //=> true
     *      pointHas('y');  //=> true
     *      pointHas('z');  //=> false
     */
    var has = _curry2(_has);

    /**
     * Returns whether or not an object or its prototype chain has a property with
     * the specified name
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Object
     * @sig s -> {s: x} -> Boolean
     * @param {String} prop The name of the property to check for.
     * @param {Object} obj The object to query.
     * @return {Boolean} Whether the property exists.
     * @example
     *
     *      function Rectangle(width, height) {
     *        this.width = width;
     *        this.height = height;
     *      }
     *      Rectangle.prototype.area = function() {
     *        return this.width * this.height;
     *      };
     *
     *      var square = new Rectangle(2, 2);
     *      R.hasIn('width', square);  //=> true
     *      R.hasIn('area', square);  //=> true
     */
    var hasIn = _curry2(function hasIn(prop, obj) {
        return prop in obj;
    });

    /**
     * Returns true if its arguments are identical, false otherwise. Values are
     * identical if they reference the same memory. `NaN` is identical to `NaN`;
     * `0` and `-0` are not identical.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Relation
     * @sig a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      var o = {};
     *      R.identical(o, o); //=> true
     *      R.identical(1, 1); //=> true
     *      R.identical(1, '1'); //=> false
     *      R.identical([], []); //=> false
     *      R.identical(0, -0); //=> false
     *      R.identical(NaN, NaN); //=> true
     */
    // SameValue algorithm
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Step 6.a: NaN == NaN
    var identical = _curry2(function identical(a, b) {
        // SameValue algorithm
        if (a === b) {
            // Steps 1-5, 7-10
            // Steps 6.b-6.e: +0 != -0
            return a !== 0 || 1 / a === 1 / b;
        } else {
            // Step 6.a: NaN == NaN
            return a !== a && b !== b;
        }
    });

    /**
     * A function that does nothing but return the parameter supplied to it. Good
     * as a default or placeholder function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig a -> a
     * @param {*} x The value to return.
     * @return {*} The input value, `x`.
     * @example
     *
     *      R.identity(1); //=> 1
     *
     *      var obj = {};
     *      R.identity(obj) === obj; //=> true
     */
    var identity = _curry1(_identity);

    /**
     * Creates a function that will process either the `onTrue` or the `onFalse`
     * function depending upon the result of the `condition` predicate.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
     * @param {Function} condition A predicate function
     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
     *                    function depending upon the result of the `condition` predicate.
     * @see R.unless, R.when
     * @example
     *
     *      var incCount = R.ifElse(
     *        R.has('count'),
     *        R.over(R.lensProp('count'), R.inc),
     *        R.assoc('count', 1)
     *      );
     *      incCount({});           //=> { count: 1 }
     *      incCount({ count: 1 }); //=> { count: 2 }
     */
    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
        });
    });

    /**
     * Increments its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @see R.dec
     * @example
     *
     *      R.inc(42); //=> 43
     */
    var inc = add(1);

    /**
     * Inserts the supplied element into the list, at index `index`. _Note that
     * this is not destructive_: it returns a copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.2.2
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} index The position to insert the element
     * @param {*} elt The element to insert into the Array
     * @param {Array} list The list to insert into
     * @return {Array} A new Array with `elt` inserted at `index`.
     * @example
     *
     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
     */
    var insert = _curry3(function insert(idx, elt, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        var result = _slice(list);
        result.splice(idx, 0, elt);
        return result;
    });

    /**
     * Inserts the sub-list into the list, at index `index`. _Note that this is not
     * destructive_: it returns a copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig Number -> [a] -> [a] -> [a]
     * @param {Number} index The position to insert the sub-list
     * @param {Array} elts The sub-list to insert into the Array
     * @param {Array} list The list to insert the sub-list into
     * @return {Array} A new Array with `elts` inserted starting at `index`.
     * @example
     *
     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
     */
    var insertAll = _curry3(function insertAll(idx, elts, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
    });

    /**
     * Creates a new list with the separator interposed between elements.
     *
     * Dispatches to the `intersperse` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} separator The element to add to the list.
     * @param {Array} list The list to be interposed.
     * @return {Array} The new list.
     * @example
     *
     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
     */
    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
        var out = [];
        var idx = 0;
        var length = list.length;
        while (idx < length) {
            if (idx === length - 1) {
                out.push(list[idx]);
            } else {
                out.push(list[idx], separator);
            }
            idx += 1;
        }
        return out;
    }));

    /**
     * See if an object (`val`) is an instance of the supplied constructor. This
     * function will check up the inheritance chain, if any.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Type
     * @sig (* -> {*}) -> a -> Boolean
     * @param {Object} ctor A constructor
     * @param {*} val The value to test
     * @return {Boolean}
     * @example
     *
     *      R.is(Object, {}); //=> true
     *      R.is(Number, 1); //=> true
     *      R.is(Object, 1); //=> false
     *      R.is(String, 's'); //=> true
     *      R.is(String, new String('')); //=> true
     *      R.is(Object, new String('')); //=> true
     *      R.is(Object, 's'); //=> false
     *      R.is(Number, {}); //=> false
     */
    var is = _curry2(function is(Ctor, val) {
        return val != null && val.constructor === Ctor || val instanceof Ctor;
    });

    /**
     * Tests whether or not an object is similar to an array.
     *
     * @func
     * @memberOf R
     * @since v0.5.0
     * @category Type
     * @category List
     * @sig * -> Boolean
     * @param {*} x The object to test.
     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
     * @example
     *
     *      R.isArrayLike([]); //=> true
     *      R.isArrayLike(true); //=> false
     *      R.isArrayLike({}); //=> false
     *      R.isArrayLike({length: 10}); //=> false
     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
     */
    var isArrayLike = _curry1(function isArrayLike(x) {
        if (_isArray(x)) {
            return true;
        }
        if (!x) {
            return false;
        }
        if (typeof x !== 'object') {
            return false;
        }
        if (x instanceof String) {
            return false;
        }
        if (x.nodeType === 1) {
            return !!x.length;
        }
        if (x.length === 0) {
            return true;
        }
        if (x.length > 0) {
            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
        }
        return false;
    });

    /**
     * Checks if the input value is `null` or `undefined`.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Type
     * @sig * -> Boolean
     * @param {*} x The value to test.
     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
     * @example
     *
     *      R.isNil(null); //=> true
     *      R.isNil(undefined); //=> true
     *      R.isNil(0); //=> false
     *      R.isNil([]); //=> false
     */
    var isNil = _curry1(function isNil(x) {
        return x == null;
    });

    /**
     * Returns a list containing the names of all the enumerable own properties of
     * the supplied object.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own properties.
     * @example
     *
     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
     */
    // cover IE < 9 keys issues
    // Safari bug
    var keys = function () {
        // cover IE < 9 keys issues
        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
        var nonEnumerableProps = [
            'constructor',
            'valueOf',
            'isPrototypeOf',
            'toString',
            'propertyIsEnumerable',
            'hasOwnProperty',
            'toLocaleString'
        ];
        // Safari bug
        var hasArgsEnumBug = function () {
            'use strict';
            return arguments.propertyIsEnumerable('length');
        }();
        var contains = function contains(list, item) {
            var idx = 0;
            while (idx < list.length) {
                if (list[idx] === item) {
                    return true;
                }
                idx += 1;
            }
            return false;
        };
        return typeof Object.keys === 'function' && !hasArgsEnumBug ? _curry1(function keys(obj) {
            return Object(obj) !== obj ? [] : Object.keys(obj);
        }) : _curry1(function keys(obj) {
            if (Object(obj) !== obj) {
                return [];
            }
            var prop, nIdx;
            var ks = [];
            var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
            for (prop in obj) {
                if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
                    ks[ks.length] = prop;
                }
            }
            if (hasEnumBug) {
                nIdx = nonEnumerableProps.length - 1;
                while (nIdx >= 0) {
                    prop = nonEnumerableProps[nIdx];
                    if (_has(prop, obj) && !contains(ks, prop)) {
                        ks[ks.length] = prop;
                    }
                    nIdx -= 1;
                }
            }
            return ks;
        });
    }();

    /**
     * Returns a list containing the names of all the properties of the supplied
     * object, including prototype properties.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.keysIn(f); //=> ['x', 'y']
     */
    var keysIn = _curry1(function keysIn(obj) {
        var prop;
        var ks = [];
        for (prop in obj) {
            ks[ks.length] = prop;
        }
        return ks;
    });

    /**
     * Returns the number of elements in the array by returning `list.length`.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [a] -> Number
     * @param {Array} list The array to inspect.
     * @return {Number} The length of the array.
     * @example
     *
     *      R.length([]); //=> 0
     *      R.length([1, 2, 3]); //=> 3
     */
    var length = _curry1(function length(list) {
        return list != null && is(Number, list.length) ? list.length : NaN;
    });

    /**
     * Returns `true` if the first argument is less than the second; `false`
     * otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @see R.gt
     * @example
     *
     *      R.lt(2, 1); //=> false
     *      R.lt(2, 2); //=> false
     *      R.lt(2, 3); //=> true
     *      R.lt('a', 'z'); //=> true
     *      R.lt('z', 'a'); //=> false
     */
    var lt = _curry2(function lt(a, b) {
        return a < b;
    });

    /**
     * Returns `true` if the first argument is less than or equal to the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {Number} a
     * @param {Number} b
     * @return {Boolean}
     * @see R.gte
     * @example
     *
     *      R.lte(2, 1); //=> false
     *      R.lte(2, 2); //=> true
     *      R.lte(2, 3); //=> true
     *      R.lte('a', 'z'); //=> true
     *      R.lte('z', 'a'); //=> false
     */
    var lte = _curry2(function lte(a, b) {
        return a <= b;
    });

    /**
     * The mapAccum function behaves like a combination of map and reduce; it
     * applies a function to each element of a list, passing an accumulating
     * parameter from left to right, and returning a final value of this
     * accumulator together with the new list.
     *
     * The iterator function receives two arguments, *acc* and *value*, and should
     * return a tuple *[acc, value]*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.addIndex
     * @example
     *
     *      var digits = ['1', '2', '3', '4'];
     *      var appender = (a, b) => [a + b, a + b];
     *
     *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
     */
    var mapAccum = _curry3(function mapAccum(fn, acc, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        var tuple = [acc];
        while (idx < len) {
            tuple = fn(tuple[0], list[idx]);
            result[idx] = tuple[1];
            idx += 1;
        }
        return [
            tuple[0],
            result
        ];
    });

    /**
     * The mapAccumRight function behaves like a combination of map and reduce; it
     * applies a function to each element of a list, passing an accumulating
     * parameter from right to left, and returning a final value of this
     * accumulator together with the new list.
     *
     * Similar to `mapAccum`, except moves through the input list from the right to
     * the left.
     *
     * The iterator function receives two arguments, *acc* and *value*, and should
     * return a tuple *[acc, value]*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.addIndex
     * @example
     *
     *      var digits = ['1', '2', '3', '4'];
     *      var append = (a, b) => [a + b, a + b];
     *
     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]
     */
    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
        var idx = list.length - 1;
        var result = [];
        var tuple = [acc];
        while (idx >= 0) {
            tuple = fn(tuple[0], list[idx]);
            result[idx] = tuple[1];
            idx -= 1;
        }
        return [
            tuple[0],
            result
        ];
    });

    /**
     * Tests a regular expression against a String. Note that this function will
     * return an empty array when there are no matches. This differs from
     * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
     * which returns `null` when there are no matches.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category String
     * @sig RegExp -> String -> [String | Undefined]
     * @param {RegExp} rx A regular expression.
     * @param {String} str The string to match against
     * @return {Array} The list of matches or empty array.
     * @see R.test
     * @example
     *
     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
     *      R.match(/a/, 'b'); //=> []
     *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
     */
    var match = _curry2(function match(rx, str) {
        return str.match(rx) || [];
    });

    /**
     * mathMod behaves like the modulo operator should mathematically, unlike the
     * `%` operator (and by extension, R.modulo). So while "-17 % 5" is -2,
     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
     * when the modulus is zero or negative.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} m The dividend.
     * @param {Number} p the modulus.
     * @return {Number} The result of `b mod a`.
     * @example
     *
     *      R.mathMod(-17, 5);  //=> 3
     *      R.mathMod(17, 5);   //=> 2
     *      R.mathMod(17, -5);  //=> NaN
     *      R.mathMod(17, 0);   //=> NaN
     *      R.mathMod(17.2, 5); //=> NaN
     *      R.mathMod(17, 5.3); //=> NaN
     *
     *      var clock = R.mathMod(R.__, 12);
     *      clock(15); //=> 3
     *      clock(24); //=> 0
     *
     *      var seventeenMod = R.mathMod(17);
     *      seventeenMod(3);  //=> 2
     *      seventeenMod(4);  //=> 1
     *      seventeenMod(10); //=> 7
     */
    var mathMod = _curry2(function mathMod(m, p) {
        if (!_isInteger(m)) {
            return NaN;
        }
        if (!_isInteger(p) || p < 1) {
            return NaN;
        }
        return (m % p + p) % p;
    });

    /**
     * Returns the larger of its two arguments.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> a
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.maxBy, R.min
     * @example
     *
     *      R.max(789, 123); //=> 789
     *      R.max('a', 'b'); //=> 'b'
     */
    var max = _curry2(function max(a, b) {
        return b > a ? b : a;
    });

    /**
     * Takes a function and two values, and returns whichever value produces the
     * larger result when passed to the provided function.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Relation
     * @sig Ord b => (a -> b) -> a -> a -> a
     * @param {Function} f
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.max, R.minBy
     * @example
     *
     *      //  square :: Number -> Number
     *      var square = n => n * n;
     *
     *      R.maxBy(square, -3, 2); //=> -3
     *
     *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
     *      R.reduce(R.maxBy(square), 0, []); //=> 0
     */
    var maxBy = _curry3(function maxBy(f, a, b) {
        return f(b) > f(a) ? b : a;
    });

    /**
     * Create a new object with the own properties of the first object merged with
     * the own properties of the second object. If a key exists in both objects,
     * the value from the second object will be used.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> {k: v} -> {k: v}
     * @param {Object} l
     * @param {Object} r
     * @return {Object}
     * @see R.mergeWith, R.mergeWithKey
     * @example
     *
     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
     *      //=> { 'name': 'fred', 'age': 40 }
     *
     *      var resetToDefault = R.merge(R.__, {x: 0});
     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
     */
    var merge = _curry2(function merge(l, r) {
        return _assign({}, l, r);
    });

    /**
     * Merges a list of objects together into one object.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig [{k: v}] -> {k: v}
     * @param {Array} list An array of objects
     * @return {Object} A merged object.
     * @see R.reduce
     * @example
     *
     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
     */
    var mergeAll = _curry1(function mergeAll(list) {
        return _assign.apply(null, [{}].concat(list));
    });

    /**
     * Creates a new object with the own properties of the two provided objects. If
     * a key exists in both objects, the provided function is applied to the key
     * and the values associated with the key in each object, with the result being
     * used as the value associated with the key in the returned object. The key
     * will be excluded from the returned object if the resulting value is
     * `undefined`.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Object
     * @sig (String -> a -> a -> a) -> {a} -> {a} -> {a}
     * @param {Function} fn
     * @param {Object} l
     * @param {Object} r
     * @return {Object}
     * @see R.merge, R.mergeWith
     * @example
     *
     *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
     *      R.mergeWithKey(concatValues,
     *                     { a: true, thing: 'foo', values: [10, 20] },
     *                     { b: true, thing: 'bar', values: [15, 35] });
     *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
     */
    var mergeWithKey = _curry3(function mergeWithKey(fn, l, r) {
        var result = {};
        var k;
        for (k in l) {
            if (_has(k, l)) {
                result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
            }
        }
        for (k in r) {
            if (_has(k, r) && !_has(k, result)) {
                result[k] = r[k];
            }
        }
        return result;
    });

    /**
     * Returns the smaller of its two arguments.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> a
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.minBy, R.max
     * @example
     *
     *      R.min(789, 123); //=> 123
     *      R.min('a', 'b'); //=> 'a'
     */
    var min = _curry2(function min(a, b) {
        return b < a ? b : a;
    });

    /**
     * Takes a function and two values, and returns whichever value produces the
     * smaller result when passed to the provided function.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Relation
     * @sig Ord b => (a -> b) -> a -> a -> a
     * @param {Function} f
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.min, R.maxBy
     * @example
     *
     *      //  square :: Number -> Number
     *      var square = n => n * n;
     *
     *      R.minBy(square, -3, 2); //=> 2
     *
     *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
     *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
     */
    var minBy = _curry3(function minBy(f, a, b) {
        return f(b) < f(a) ? b : a;
    });

    /**
     * Divides the second parameter by the first and returns the remainder. Note
     * that this function preserves the JavaScript-style behavior for modulo. For
     * mathematical modulo see `mathMod`.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The value to the divide.
     * @param {Number} b The pseudo-modulus
     * @return {Number} The result of `b % a`.
     * @see R.mathMod
     * @example
     *
     *      R.modulo(17, 3); //=> 2
     *      // JS behavior:
     *      R.modulo(-17, 3); //=> -2
     *      R.modulo(17, -3); //=> 2
     *
     *      var isOdd = R.modulo(R.__, 2);
     *      isOdd(42); //=> 0
     *      isOdd(21); //=> 1
     */
    var modulo = _curry2(function modulo(a, b) {
        return a % b;
    });

    /**
     * Multiplies two numbers. Equivalent to `a * b` but curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a * b`.
     * @see R.divide
     * @example
     *
     *      var double = R.multiply(2);
     *      var triple = R.multiply(3);
     *      double(3);       //=>  6
     *      triple(4);       //=> 12
     *      R.multiply(2, 5);  //=> 10
     */
    var multiply = _curry2(function multiply(a, b) {
        return a * b;
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts
     * exactly `n` parameters. Any extraneous parameters will not be passed to the
     * supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} n The desired arity of the new function.
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity `n`.
     * @example
     *
     *      var takesTwoArgs = (a, b) => [a, b];
     *
     *      takesTwoArgs.length; //=> 2
     *      takesTwoArgs(1, 2); //=> [1, 2]
     *
     *      var takesOneArg = R.nAry(1, takesTwoArgs);
     *      takesOneArg.length; //=> 1
     *      // Only `n` arguments are passed to the wrapped function
     *      takesOneArg(1, 2); //=> [1, undefined]
     */
    var nAry = _curry2(function nAry(n, fn) {
        switch (n) {
        case 0:
            return function () {
                return fn.call(this);
            };
        case 1:
            return function (a0) {
                return fn.call(this, a0);
            };
        case 2:
            return function (a0, a1) {
                return fn.call(this, a0, a1);
            };
        case 3:
            return function (a0, a1, a2) {
                return fn.call(this, a0, a1, a2);
            };
        case 4:
            return function (a0, a1, a2, a3) {
                return fn.call(this, a0, a1, a2, a3);
            };
        case 5:
            return function (a0, a1, a2, a3, a4) {
                return fn.call(this, a0, a1, a2, a3, a4);
            };
        case 6:
            return function (a0, a1, a2, a3, a4, a5) {
                return fn.call(this, a0, a1, a2, a3, a4, a5);
            };
        case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
            };
        case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
            };
        case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
            };
        case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            };
        default:
            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
        }
    });

    /**
     * Negates its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @example
     *
     *      R.negate(42); //=> -42
     */
    var negate = _curry1(function negate(n) {
        return -n;
    });

    /**
     * Returns `true` if no elements of the list match the predicate, `false`
     * otherwise.
     *
     * Dispatches to the `any` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
     * @see R.all, R.any
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *
     *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
     *      R.none(isEven, [1, 3, 5, 7, 8, 11]); //=> false
     */
    var none = _curry2(_complement(_dispatchable('any', _xany, any)));

    /**
     * A function that returns the `!` of its argument. It will return `true` when
     * passed false-y value, and `false` when passed a truth-y one.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> Boolean
     * @param {*} a any value
     * @return {Boolean} the logical inverse of passed argument.
     * @see R.complement
     * @example
     *
     *      R.not(true); //=> false
     *      R.not(false); //=> true
     *      R.not(0); => true
     *      R.not(1); => false
     */
    var not = _curry1(function not(a) {
        return !a;
    });

    /**
     * Returns the nth element of the given list or string. If n is negative the
     * element at index length + n is returned.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> a | Undefined
     * @sig Number -> String -> String
     * @param {Number} offset
     * @param {*} list
     * @return {*}
     * @example
     *
     *      var list = ['foo', 'bar', 'baz', 'quux'];
     *      R.nth(1, list); //=> 'bar'
     *      R.nth(-1, list); //=> 'quux'
     *      R.nth(-99, list); //=> undefined
     *
     *      R.nth(2, 'abc'); //=> 'c'
     *      R.nth(3, 'abc'); //=> ''
     */
    var nth = _curry2(function nth(offset, list) {
        var idx = offset < 0 ? list.length + offset : offset;
        return _isString(list) ? list.charAt(idx) : list[idx];
    });

    /**
     * Returns a function which returns its nth argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig Number -> *... -> *
     * @param {Number} n
     * @return {Function}
     * @example
     *
     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
     */
    var nthArg = _curry1(function nthArg(n) {
        return function () {
            return nth(n, arguments);
        };
    });

    /**
     * Creates an object containing a single key:value pair.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Object
     * @sig String -> a -> {String:a}
     * @param {String} key
     * @param {*} val
     * @return {Object}
     * @see R.pair
     * @example
     *
     *      var matchPhrases = R.compose(
     *        R.objOf('must'),
     *        R.map(R.objOf('match_phrase'))
     *      );
     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
     */
    var objOf = _curry2(function objOf(key, val) {
        var obj = {};
        obj[key] = val;
        return obj;
    });

    /**
     * Returns a singleton array containing the value provided.
     *
     * Note this `of` is different from the ES6 `of`; See
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig a -> [a]
     * @param {*} x any value
     * @return {Array} An array wrapping `x`.
     * @example
     *
     *      R.of(null); //=> [null]
     *      R.of([42]); //=> [[42]]
     */
    var of = _curry1(_of);

    /**
     * Accepts a function `fn` and returns a function that guards invocation of
     * `fn` such that `fn` can only ever be called once, no matter how many times
     * the returned function is invoked. The first value calculated is returned in
     * subsequent invocations.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a... -> b) -> (a... -> b)
     * @param {Function} fn The function to wrap in a call-only-once wrapper.
     * @return {Function} The wrapped function.
     * @example
     *
     *      var addOneOnce = R.once(x => x + 1);
     *      addOneOnce(10); //=> 11
     *      addOneOnce(addOneOnce(50)); //=> 11
     */
    var once = _curry1(function once(fn) {
        var called = false;
        var result;
        return _arity(fn.length, function () {
            if (called) {
                return result;
            }
            called = true;
            result = fn.apply(this, arguments);
            return result;
        });
    });

    /**
     * Returns `true` if one or both of its arguments are `true`. Returns `false`
     * if both arguments are `false`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> * -> *
     * @param {Boolean} a A boolean value
     * @param {Boolean} b A boolean value
     * @return {Boolean} `true` if one or both arguments are `true`, `false` otherwise
     * @see R.either
     * @example
     *
     *      R.or(true, true); //=> true
     *      R.or(true, false); //=> true
     *      R.or(false, true); //=> true
     *      R.or(false, false); //=> false
     */
    var or = _curry2(function or(a, b) {
        return a || b;
    });

    /**
     * Returns the result of "setting" the portion of the given data structure
     * focused by the given lens to the result of applying the given function to
     * the focused value.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> (a -> a) -> s -> s
     * @param {Lens} lens
     * @param {*} v
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var headLens = R.lensIndex(0);
     *
     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
     */
    // `Identity` is a functor that holds a single value, where `map` simply
    // transforms the held value with the provided function.
    // The value returned by the getter function is first transformed with `f`,
    // then set as the value of an `Identity`. This is then mapped over with the
    // setter function of the lens.
    var over = function () {
        // `Identity` is a functor that holds a single value, where `map` simply
        // transforms the held value with the provided function.
        var Identity = function (x) {
            return {
                value: x,
                map: function (f) {
                    return Identity(f(x));
                }
            };
        };
        return _curry3(function over(lens, f, x) {
            // The value returned by the getter function is first transformed with `f`,
            // then set as the value of an `Identity`. This is then mapped over with the
            // setter function of the lens.
            return lens(function (y) {
                return Identity(f(y));
            })(x).value;
        });
    }();

    /**
     * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category List
     * @sig a -> b -> (a,b)
     * @param {*} fst
     * @param {*} snd
     * @return {Array}
     * @see R.objOf, R.of
     * @example
     *
     *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
     */
    var pair = _curry2(function pair(fst, snd) {
        return [
            fst,
            snd
        ];
    });

    /**
     * Retrieve the value at a given path.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig [String] -> {k: v} -> v | Undefined
     * @param {Array} path The path to use.
     * @param {Object} obj The object to retrieve the nested property from.
     * @return {*} The data at `path`.
     * @example
     *
     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
     */
    var path = _curry2(function path(paths, obj) {
        var val = obj;
        var idx = 0;
        while (idx < paths.length) {
            if (val == null) {
                return;
            }
            val = val[paths[idx]];
            idx += 1;
        }
        return val;
    });

    /**
     * If the given, non-null object has a value at the given path, returns the
     * value at that path. Otherwise returns the provided default value.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Object
     * @sig a -> [String] -> Object -> a
     * @param {*} d The default value.
     * @param {Array} p The path to use.
     * @param {Object} obj The object to retrieve the nested property from.
     * @return {*} The data at `path` of the supplied object or the default value.
     * @example
     *
     *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
     *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
     */
    var pathOr = _curry3(function pathOr(d, p, obj) {
        return defaultTo(d, path(p, obj));
    });

    /**
     * Returns `true` if the specified object property at given path satisfies the
     * given predicate; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Logic
     * @sig (a -> Boolean) -> [String] -> Object -> Boolean
     * @param {Function} pred
     * @param {Array} propPath
     * @param {*} obj
     * @return {Boolean}
     * @see R.propSatisfies, R.path
     * @example
     *
     *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
     */
    var pathSatisfies = _curry3(function pathSatisfies(pred, propPath, obj) {
        return propPath.length > 0 && pred(path(propPath, obj));
    });

    /**
     * Returns a partial copy of an object containing only the keys specified. If
     * the key does not exist, the property is ignored.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> {k: v}
     * @param {Array} names an array of String property names to copy onto a new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties from `names` on it.
     * @see R.omit, R.props
     * @example
     *
     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
     */
    var pick = _curry2(function pick(names, obj) {
        var result = {};
        var idx = 0;
        while (idx < names.length) {
            if (names[idx] in obj) {
                result[names[idx]] = obj[names[idx]];
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Similar to `pick` except that this one includes a `key: undefined` pair for
     * properties that don't exist.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> {k: v}
     * @param {Array} names an array of String property names to copy onto a new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties from `names` on it.
     * @see R.pick
     * @example
     *
     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
     */
    var pickAll = _curry2(function pickAll(names, obj) {
        var result = {};
        var idx = 0;
        var len = names.length;
        while (idx < len) {
            var name = names[idx];
            result[name] = obj[name];
            idx += 1;
        }
        return result;
    });

    /**
     * Returns a partial copy of an object containing only the keys that satisfy
     * the supplied predicate.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
     * @param {Function} pred A predicate to determine whether or not a key
     *        should be included on the output object.
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties that satisfy `pred`
     *         on it.
     * @see R.pick, R.filter
     * @example
     *
     *      var isUpperCase = (val, key) => key.toUpperCase() === key;
     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
     */
    var pickBy = _curry2(function pickBy(test, obj) {
        var result = {};
        for (var prop in obj) {
            if (test(obj[prop], prop, obj)) {
                result[prop] = obj[prop];
            }
        }
        return result;
    });

    /**
     * Returns a new list with the given element at the front, followed by the
     * contents of the list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} el The item to add to the head of the output list.
     * @param {Array} list The array to add to the tail of the output list.
     * @return {Array} A new array.
     * @see R.append
     * @example
     *
     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
     */
    var prepend = _curry2(function prepend(el, list) {
        return _concat([el], list);
    });

    /**
     * Returns a function that when supplied an object returns the indicated
     * property of that object, if it exists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig s -> {s: a} -> a | Undefined
     * @param {String} p The property name
     * @param {Object} obj The object to query
     * @return {*} The value at `obj.p`.
     * @example
     *
     *      R.prop('x', {x: 100}); //=> 100
     *      R.prop('x', {}); //=> undefined
     */
    var prop = _curry2(function prop(p, obj) {
        return obj[p];
    });

    /**
     * If the given, non-null object has an own property with the specified name,
     * returns the value of that property. Otherwise returns the provided default
     * value.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Object
     * @sig a -> String -> Object -> a
     * @param {*} val The default value.
     * @param {String} p The name of the property to return.
     * @param {Object} obj The object to query.
     * @return {*} The value of given property of the supplied object or the default value.
     * @example
     *
     *      var alice = {
     *        name: 'ALICE',
     *        age: 101
     *      };
     *      var favorite = R.prop('favoriteLibrary');
     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
     *
     *      favorite(alice);  //=> undefined
     *      favoriteWithDefault(alice);  //=> 'Ramda'
     */
    var propOr = _curry3(function propOr(val, p, obj) {
        return obj != null && _has(p, obj) ? obj[p] : val;
    });

    /**
     * Returns `true` if the specified object property satisfies the given
     * predicate; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Logic
     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
     * @param {Function} pred
     * @param {String} name
     * @param {*} obj
     * @return {Boolean}
     * @see R.propEq, R.propIs
     * @example
     *
     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
     */
    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
        return pred(obj[name]);
    });

    /**
     * Acts as multiple `prop`: array of keys in, array of values out. Preserves
     * order.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> [v]
     * @param {Array} ps The property names to fetch
     * @param {Object} obj The object to query
     * @return {Array} The corresponding values or partially applied function.
     * @example
     *
     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
     *
     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
     */
    var props = _curry2(function props(ps, obj) {
        var len = ps.length;
        var out = [];
        var idx = 0;
        while (idx < len) {
            out[idx] = obj[ps[idx]];
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> Number -> [Number]
     * @param {Number} from The first number in the list.
     * @param {Number} to One more than the last number in the list.
     * @return {Array} The list of numbers in tthe set `[a, b)`.
     * @example
     *
     *      R.range(1, 5);    //=> [1, 2, 3, 4]
     *      R.range(50, 53);  //=> [50, 51, 52]
     */
    var range = _curry2(function range(from, to) {
        if (!(_isNumber(from) && _isNumber(to))) {
            throw new TypeError('Both arguments to range must be numbers');
        }
        var result = [];
        var n = from;
        while (n < to) {
            result.push(n);
            n += 1;
        }
        return result;
    });

    /**
     * Returns a single item by iterating through the list, successively calling
     * the iterator function and passing it an accumulator value and the current
     * value from the array, and then passing the result to the next call.
     *
     * Similar to `reduce`, except moves through the input list from the right to
     * the left.
     *
     * The iterator function receives two values: *(acc, value)*
     *
     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.reduce` method. For more details
     * on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.addIndex
     * @example
     *
     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
     *      var flattenPairs = (acc, pair) => acc.concat(pair);
     *
     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]
     */
    var reduceRight = _curry3(function reduceRight(fn, acc, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            acc = fn(acc, list[idx]);
            idx -= 1;
        }
        return acc;
    });

    /**
     * Returns a value wrapped to indicate that it is the final value of the reduce
     * and transduce functions. The returned value should be considered a black
     * box: the internal structure is not guaranteed to be stable.
     *
     * Note: this optimization is unavailable to functions not explicitly listed
     * above. For instance, it is not currently supported by reduceRight.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category List
     * @sig a -> *
     * @param {*} x The final value of the reduce.
     * @return {*} The wrapped value.
     * @see R.reduce, R.transduce
     * @example
     *
     *      R.reduce(
     *        R.pipe(R.add, R.when(R.gte(R.__, 10), R.reduced)),
     *        0,
     *        [1, 2, 3, 4, 5]) // 10
     */
    var reduced = _curry1(_reduced);

    /**
     * Removes the sub-list of `list` starting at index `start` and containing
     * `count` elements. _Note that this is not destructive_: it returns a copy of
     * the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.2.2
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @param {Number} start The position to start removing elements
     * @param {Number} count The number of elements to remove
     * @param {Array} list The list to remove from
     * @return {Array} A new Array with `count` elements from `start` removed.
     * @example
     *
     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
     */
    var remove = _curry3(function remove(start, count, list) {
        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
    });

    /**
     * Replace a substring or regex match in a string with a replacement.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category String
     * @sig RegExp|String -> String -> String -> String
     * @param {RegExp|String} pattern A regular expression or a substring to match.
     * @param {String} replacement The string to replace the matches with.
     * @param {String} str The String to do the search and replacement in.
     * @return {String} The result.
     * @example
     *
     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
     *
     *      // Use the "g" (global) flag to replace all occurrences:
     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
     */
    var replace = _curry3(function replace(regex, replacement, str) {
        return str.replace(regex, replacement);
    });

    /**
     * Returns a new list or string with the elements or characters in reverse
     * order.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {Array|String} list
     * @return {Array|String}
     * @example
     *
     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
     *      R.reverse([1, 2]);     //=> [2, 1]
     *      R.reverse([1]);        //=> [1]
     *      R.reverse([]);         //=> []
     *
     *      R.reverse('abc');      //=> 'cba'
     *      R.reverse('ab');       //=> 'ba'
     *      R.reverse('a');        //=> 'a'
     *      R.reverse('');         //=> ''
     */
    var reverse = _curry1(function reverse(list) {
        return _isString(list) ? list.split('').reverse().join('') : _slice(list).reverse();
    });

    /**
     * Scan is similar to reduce, but returns a list of successively reduced values
     * from the left
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> [a]
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {Array} A list of all intermediately reduced values.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
     */
    var scan = _curry3(function scan(fn, acc, list) {
        var idx = 0;
        var len = list.length;
        var result = [acc];
        while (idx < len) {
            acc = fn(acc, list[idx]);
            result[idx + 1] = acc;
            idx += 1;
        }
        return result;
    });

    /**
     * Returns the result of "setting" the portion of the given data structure
     * focused by the given lens to the given value.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> a -> s -> s
     * @param {Lens} lens
     * @param {*} v
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
     */
    var set = _curry3(function set(lens, v, x) {
        return over(lens, always(v), x);
    });

    /**
     * Returns the elements of the given list or string (or object with a `slice`
     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
     *
     * Dispatches to the `slice` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @sig Number -> Number -> String -> String
     * @param {Number} fromIndex The start index (inclusive).
     * @param {Number} toIndex The end index (exclusive).
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
     */
    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
        return Array.prototype.slice.call(list, fromIndex, toIndex);
    }));

    /**
     * Returns a copy of the list, sorted according to the comparator function,
     * which should accept two values at a time and return a negative number if the
     * first value is smaller, a positive number if it's larger, and zero if they
     * are equal. Please note that this is a **copy** of the list. It does not
     * modify the original.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,a -> Number) -> [a] -> [a]
     * @param {Function} comparator A sorting function :: a -> b -> Int
     * @param {Array} list The list to sort
     * @return {Array} a new array with its elements sorted by the comparator function.
     * @example
     *
     *      var diff = function(a, b) { return a - b; };
     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
     */
    var sort = _curry2(function sort(comparator, list) {
        return _slice(list).sort(comparator);
    });

    /**
     * Sorts the list according to the supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord b => (a -> b) -> [a] -> [a]
     * @param {Function} fn
     * @param {Array} list The list to sort.
     * @return {Array} A new list sorted by the keys generated by `fn`.
     * @example
     *
     *      var sortByFirstItem = R.sortBy(R.prop(0));
     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
     *      var alice = {
     *        name: 'ALICE',
     *        age: 101
     *      };
     *      var bob = {
     *        name: 'Bob',
     *        age: -10
     *      };
     *      var clara = {
     *        name: 'clara',
     *        age: 314.159
     *      };
     *      var people = [clara, bob, alice];
     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
     */
    var sortBy = _curry2(function sortBy(fn, list) {
        return _slice(list).sort(function (a, b) {
            var aa = fn(a);
            var bb = fn(b);
            return aa < bb ? -1 : aa > bb ? 1 : 0;
        });
    });

    /**
     * Splits a given list or string at a given index.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig Number -> [a] -> [[a], [a]]
     * @sig Number -> String -> [String, String]
     * @param {Number} index The index where the array/string is split.
     * @param {Array|String} array The array/string to be split.
     * @return {Array}
     * @example
     *
     *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
     *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
     *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
     */
    var splitAt = _curry2(function splitAt(index, array) {
        return [
            slice(0, index, array),
            slice(index, length(array), array)
        ];
    });

    /**
     * Splits a collection into slices of the specified length.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [[a]]
     * @sig Number -> String -> [String]
     * @param {Number} n
     * @param {Array} list
     * @return {Array}
     * @example
     *
     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
     */
    var splitEvery = _curry2(function splitEvery(n, list) {
        if (n <= 0) {
            throw new Error('First argument to splitEvery must be a positive integer');
        }
        var result = [];
        var idx = 0;
        while (idx < list.length) {
            result.push(slice(idx, idx += n, list));
        }
        return result;
    });

    /**
     * Takes a list and a predicate and returns a pair of lists with the following properties:
     *
     *  - the result of concatenating the two output lists is equivalent to the input list;
     *  - none of the elements of the first output list satisfies the predicate; and
     *  - if the second output list is non-empty, its first element satisfies the predicate.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [[a], [a]]
     * @param {Function} pred The predicate that determines where the array is split.
     * @param {Array} list The array to be split.
     * @return {Array}
     * @example
     *
     *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
     */
    var splitWhen = _curry2(function splitWhen(pred, list) {
        var idx = 0;
        var len = list.length;
        var prefix = [];
        while (idx < len && !pred(list[idx])) {
            prefix.push(list[idx]);
            idx += 1;
        }
        return [
            prefix,
            _slice(list, idx)
        ];
    });

    /**
     * Subtracts its second argument from its first argument.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a - b`.
     * @see R.add
     * @example
     *
     *      R.subtract(10, 8); //=> 2
     *
     *      var minus5 = R.subtract(R.__, 5);
     *      minus5(17); //=> 12
     *
     *      var complementaryAngle = R.subtract(90);
     *      complementaryAngle(30); //=> 60
     *      complementaryAngle(72); //=> 18
     */
    var subtract = _curry2(function subtract(a, b) {
        return Number(a) - Number(b);
    });

    /**
     * Returns all but the first element of the given list or string (or object
     * with a `tail` method).
     *
     * Dispatches to the `slice` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.head, R.init, R.last
     * @example
     *
     *      R.tail([1, 2, 3]);  //=> [2, 3]
     *      R.tail([1, 2]);     //=> [2]
     *      R.tail([1]);        //=> []
     *      R.tail([]);         //=> []
     *
     *      R.tail('abc');  //=> 'bc'
     *      R.tail('ab');   //=> 'b'
     *      R.tail('a');    //=> ''
     *      R.tail('');     //=> ''
     */
    var tail = _checkForMethod('tail', slice(1, Infinity));

    /**
     * Returns the first `n` elements of the given list, string, or
     * transducer/transformer (or object with a `take` method).
     *
     * Dispatches to the `take` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {*} list
     * @return {*}
     * @see R.drop
     * @example
     *
     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.take(3, 'ramda');               //=> 'ram'
     *
     *      var personnel = [
     *        'Dave Brubeck',
     *        'Paul Desmond',
     *        'Eugene Wright',
     *        'Joe Morello',
     *        'Gerry Mulligan',
     *        'Bob Bates',
     *        'Joe Dodge',
     *        'Ron Crotty'
     *      ];
     *
     *      var takeFive = R.take(5);
     *      takeFive(personnel);
     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
     */
    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
        return slice(0, n < 0 ? Infinity : n, xs);
    }));

    /**
     * Returns a new list containing the last `n` elements of a given list, passing
     * each value to the supplied predicate function, and terminating when the
     * predicate function returns `false`. Excludes the element that caused the
     * predicate function to fail. The predicate function is passed one argument:
     * *(value)*.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.dropLastWhile, R.addIndex
     * @example
     *
     *      var isNotOne = x => x !== 1;
     *
     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
     */
    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0 && fn(list[idx])) {
            idx -= 1;
        }
        return _slice(list, idx + 1, Infinity);
    });

    /**
     * Returns a new list containing the first `n` elements of a given list,
     * passing each value to the supplied predicate function, and terminating when
     * the predicate function returns `false`. Excludes the element that caused the
     * predicate function to fail. The predicate function is passed one argument:
     * *(value)*.
     *
     * Dispatches to the `takeWhile` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.dropWhile, R.transduce, R.addIndex
     * @example
     *
     *      var isNotFour = x => x !== 4;
     *
     *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
     */
    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len && fn(list[idx])) {
            idx += 1;
        }
        return _slice(list, 0, idx);
    }));

    /**
     * Runs the given function with the supplied object, then returns the object.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a -> *) -> a -> a
     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
     * @param {*} x
     * @return {*} `x`.
     * @example
     *
     *      var sayX = x => console.log('x is ' + x);
     *      R.tap(sayX, 100); //=> 100
     *      //-> 'x is 100'
     */
    var tap = _curry2(function tap(fn, x) {
        fn(x);
        return x;
    });

    /**
     * Calls an input function `n` times, returning an array containing the results
     * of those function calls.
     *
     * `fn` is passed one argument: The current value of `n`, which begins at `0`
     * and is gradually incremented to `n - 1`.
     *
     * @func
     * @memberOf R
     * @since v0.2.3
     * @category List
     * @sig (Number -> a) -> Number -> [a]
     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
     * @return {Array} An array containing the return values of all calls to `fn`.
     * @example
     *
     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
     */
    var times = _curry2(function times(fn, n) {
        var len = Number(n);
        var idx = 0;
        var list;
        if (len < 0 || isNaN(len)) {
            throw new RangeError('n must be a non-negative number');
        }
        list = new Array(len);
        while (idx < len) {
            list[idx] = fn(idx);
            idx += 1;
        }
        return list;
    });

    /**
     * Converts an object into an array of key, value arrays. Only the object's
     * own properties are used.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Object
     * @sig {String: *} -> [[String,*]]
     * @param {Object} obj The object to extract from
     * @return {Array} An array of key, value arrays from the object's own properties.
     * @see R.fromPairs
     * @example
     *
     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
     */
    var toPairs = _curry1(function toPairs(obj) {
        var pairs = [];
        for (var prop in obj) {
            if (_has(prop, obj)) {
                pairs[pairs.length] = [
                    prop,
                    obj[prop]
                ];
            }
        }
        return pairs;
    });

    /**
     * Converts an object into an array of key, value arrays. The object's own
     * properties and prototype properties are used. Note that the order of the
     * output array is not guaranteed to be consistent across different JS
     * platforms.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Object
     * @sig {String: *} -> [[String,*]]
     * @param {Object} obj The object to extract from
     * @return {Array} An array of key, value arrays from the object's own
     *         and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
     */
    var toPairsIn = _curry1(function toPairsIn(obj) {
        var pairs = [];
        for (var prop in obj) {
            pairs[pairs.length] = [
                prop,
                obj[prop]
            ];
        }
        return pairs;
    });

    /**
     * Transposes the rows and columns of a 2D list.
     * When passed a list of `n` lists of length `x`,
     * returns a list of `x` lists of length `n`.
     *
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig [[a]] -> [[a]]
     * @param {Array} list A 2D list
     * @return {Array} A 2D list
     * @example
     *
     *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
     *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
     *
     * If some of the rows are shorter than the following rows, their elements are skipped:
     *
     *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
     */
    var transpose = _curry1(function transpose(outerlist) {
        var i = 0;
        var result = [];
        while (i < outerlist.length) {
            var innerlist = outerlist[i];
            var j = 0;
            while (j < innerlist.length) {
                if (typeof result[j] === 'undefined') {
                    result[j] = [];
                }
                result[j].push(innerlist[j]);
                j += 1;
            }
            i += 1;
        }
        return result;
    });

    /**
     * Removes (strips) whitespace from both ends of the string.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to trim.
     * @return {String} Trimmed version of `str`.
     * @example
     *
     *      R.trim('   xyz  '); //=> 'xyz'
     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
     */
    var trim = function () {
        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
        var zeroWidth = '\u200B';
        var hasProtoTrim = typeof String.prototype.trim === 'function';
        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
            return _curry1(function trim(str) {
                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
                return str.replace(beginRx, '').replace(endRx, '');
            });
        } else {
            return _curry1(function trim(str) {
                return str.trim();
            });
        }
    }();

    /**
     * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
     * function evaluates the `tryer`; if it does not throw, it simply returns the
     * result. If the `tryer` *does* throw, the returned function evaluates the
     * `catcher` function and returns its result. Note that for effective
     * composition with this function, both the `tryer` and `catcher` functions
     * must return the same type of results.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Function
     * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
     * @param {Function} tryer The function that may throw.
     * @param {Function} catcher The function that will be evaluated if `tryer` throws.
     * @return {Function} A new function that will catch exceptions and send then to the catcher.
     * @example
     *
     *      R.tryCatch(R.prop('x'), R.F, {x: true}); //=> true
     *      R.tryCatch(R.prop('x'), R.F, null);      //=> false
     */
    var tryCatch = _curry2(function _tryCatch(tryer, catcher) {
        return _arity(tryer.length, function () {
            try {
                return tryer.apply(this, arguments);
            } catch (e) {
                return catcher.apply(this, _concat([e], arguments));
            }
        });
    });

    /**
     * Gives a single-word string description of the (native) type of a value,
     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
     * attempt to distinguish user Object types any further, reporting them all as
     * 'Object'.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Type
     * @sig (* -> {*}) -> String
     * @param {*} val The value to test
     * @return {String}
     * @example
     *
     *      R.type({}); //=> "Object"
     *      R.type(1); //=> "Number"
     *      R.type(false); //=> "Boolean"
     *      R.type('s'); //=> "String"
     *      R.type(null); //=> "Null"
     *      R.type([]); //=> "Array"
     *      R.type(/[A-z]/); //=> "RegExp"
     */
    var type = _curry1(function type(val) {
        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
    });

    /**
     * Takes a function `fn`, which takes a single array argument, and returns a
     * function which:
     *
     *   - takes any number of positional arguments;
     *   - passes these arguments to `fn` as an array; and
     *   - returns the result.
     *
     * In other words, R.unapply derives a variadic function from a function which
     * takes an array. R.unapply is the inverse of R.apply.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Function
     * @sig ([*...] -> a) -> (*... -> a)
     * @param {Function} fn
     * @return {Function}
     * @see R.apply
     * @example
     *
     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
     */
    var unapply = _curry1(function unapply(fn) {
        return function () {
            return fn(_slice(arguments));
        };
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts
     * exactly 1 parameter. Any extraneous parameters will not be passed to the
     * supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Function
     * @sig (* -> b) -> (a -> b)
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity 1.
     * @example
     *
     *      var takesTwoArgs = function(a, b) {
     *        return [a, b];
     *      };
     *      takesTwoArgs.length; //=> 2
     *      takesTwoArgs(1, 2); //=> [1, 2]
     *
     *      var takesOneArg = R.unary(takesTwoArgs);
     *      takesOneArg.length; //=> 1
     *      // Only 1 argument is passed to the wrapped function
     *      takesOneArg(1, 2); //=> [1, undefined]
     */
    var unary = _curry1(function unary(fn) {
        return nAry(1, fn);
    });

    /**
     * Returns a function of arity `n` from a (manually) curried function.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Function
     * @sig Number -> (a -> b) -> (a -> c)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to uncurry.
     * @return {Function} A new function.
     * @see R.curry
     * @example
     *
     *      var addFour = a => b => c => d => a + b + c + d;
     *
     *      var uncurriedAddFour = R.uncurryN(4, addFour);
     *      uncurriedAddFour(1, 2, 3, 4); //=> 10
     */
    var uncurryN = _curry2(function uncurryN(depth, fn) {
        return curryN(depth, function () {
            var currentDepth = 1;
            var value = fn;
            var idx = 0;
            var endIdx;
            while (currentDepth <= depth && typeof value === 'function') {
                endIdx = currentDepth === depth ? arguments.length : idx + value.length;
                value = value.apply(this, _slice(arguments, idx, endIdx));
                currentDepth += 1;
                idx = endIdx;
            }
            return value;
        });
    });

    /**
     * Builds a list from a seed value. Accepts an iterator function, which returns
     * either false to stop iteration or an array of length 2 containing the value
     * to add to the resulting list and the seed to be used in the next call to the
     * iterator function.
     *
     * The iterator function receives one argument: *(seed)*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (a -> [b]) -> * -> [b]
     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
     *        either false to quit iteration or an array of length two to proceed. The element
     *        at index 0 of this array will be added to the resulting array, and the element
     *        at index 1 will be passed to the next call to `fn`.
     * @param {*} seed The seed value.
     * @return {Array} The final list.
     * @example
     *
     *      var f = n => n > 50 ? false : [-n, n + 10];
     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
     */
    var unfold = _curry2(function unfold(fn, seed) {
        var pair = fn(seed);
        var result = [];
        while (pair && pair.length) {
            result[result.length] = pair[0];
            pair = fn(pair[1]);
        }
        return result;
    });

    /**
     * Returns a new list containing only one copy of each element in the original
     * list, based upon the value returned by applying the supplied predicate to
     * two list elements. Prefers the first item if two items compare equal based
     * on the predicate.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      var strEq = R.eqBy(String);
     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
     */
    var uniqWith = _curry2(function uniqWith(pred, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        var item;
        while (idx < len) {
            item = list[idx];
            if (!_containsWith(pred, item, result)) {
                result[result.length] = item;
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Tests the final argument by passing it to the given predicate function. If
     * the predicate is not satisfied, the function will return the result of
     * calling the `whenFalseFn` function with the same argument. If the predicate
     * is satisfied, the argument is returned as is.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Logic
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred        A predicate function
     * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
     *                               to a falsy value.
     * @param {*}        x           An object to test with the `pred` function and
     *                               pass to `whenFalseFn` if necessary.
     * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
     * @see R.ifElse, R.when
     * @example
     *
     *      // coerceArray :: (a|[a]) -> [a]
     *      var coerceArray = R.unless(R.isArrayLike, R.of);
     *      coerceArray([1, 2, 3]); //=> [1, 2, 3]
     *      coerceArray(1);         //=> [1]
     */
    var unless = _curry3(function unless(pred, whenFalseFn, x) {
        return pred(x) ? x : whenFalseFn(x);
    });

    /**
     * Takes a predicate, a transformation function, and an initial value,
     * and returns a value of the same type as the initial value.
     * It does so by applying the transformation until the predicate is satisfied,
     * at which point it returns the satisfactory value.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Logic
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred A predicate function
     * @param {Function} fn The iterator function
     * @param {*} init Initial value
     * @return {*} Final value that satisfies predicate
     * @example
     *
     *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
     */
    var until = _curry3(function until(pred, fn, init) {
        var val = init;
        while (!pred(val)) {
            val = fn(val);
        }
        return val;
    });

    /**
     * Returns a new copy of the array with the element at the provided index
     * replaced with the given value.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} idx The index to update.
     * @param {*} x The value to exist at the given index of the returned array.
     * @param {Array|Arguments} list The source array-like object to be updated.
     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
     * @see R.adjust
     * @example
     *
     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
     */
    var update = _curry3(function update(idx, x, list) {
        return adjust(always(x), idx, list);
    });

    /**
     * Accepts a function `fn` and a list of transformer functions and returns a
     * new curried function. When the new function is invoked, it calls the
     * function `fn` with parameters consisting of the result of calling each
     * supplied handler on successive arguments to the new function.
     *
     * If more arguments are passed to the returned function than transformer
     * functions, those arguments are passed directly to `fn` as additional
     * parameters. If you expect additional arguments that don't need to be
     * transformed, although you can ignore them, it's best to pass an identity
     * function so that the new function reports the correct arity.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
     * @param {Function} fn The function to wrap.
     * @param {Array} transformers A list of transformer functions
     * @return {Function} The wrapped function.
     * @example
     *
     *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
     *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
     *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
     *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
     */
    var useWith = _curry2(function useWith(fn, transformers) {
        return curryN(transformers.length, function () {
            var args = [];
            var idx = 0;
            while (idx < transformers.length) {
                args.push(transformers[idx].call(this, arguments[idx]));
                idx += 1;
            }
            return fn.apply(this, args.concat(_slice(arguments, transformers.length)));
        });
    });

    /**
     * Returns a list of all the enumerable own properties of the supplied object.
     * Note that the order of the output array is not guaranteed across different
     * JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> [v]
     * @param {Object} obj The object to extract values from
     * @return {Array} An array of the values of the object's own properties.
     * @example
     *
     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
     */
    var values = _curry1(function values(obj) {
        var props = keys(obj);
        var len = props.length;
        var vals = [];
        var idx = 0;
        while (idx < len) {
            vals[idx] = obj[props[idx]];
            idx += 1;
        }
        return vals;
    });

    /**
     * Returns a list of all the properties, including prototype properties, of the
     * supplied object.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig {k: v} -> [v]
     * @param {Object} obj The object to extract values from
     * @return {Array} An array of the values of the object's own and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.valuesIn(f); //=> ['X', 'Y']
     */
    var valuesIn = _curry1(function valuesIn(obj) {
        var prop;
        var vs = [];
        for (prop in obj) {
            vs[vs.length] = obj[prop];
        }
        return vs;
    });

    /**
     * Returns a "view" of the given data structure, determined by the given lens.
     * The lens's focus determines which portion of the data structure is visible.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> s -> a
     * @param {Lens} lens
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.view(xLens, {x: 1, y: 2});  //=> 1
     *      R.view(xLens, {x: 4, y: 2});  //=> 4
     */
    // `Const` is a functor that effectively ignores the function given to `map`.
    // Using `Const` effectively ignores the setter function of the `lens`,
    // leaving the value returned by the getter function unmodified.
    var view = function () {
        // `Const` is a functor that effectively ignores the function given to `map`.
        var Const = function (x) {
            return {
                value: x,
                map: function () {
                    return this;
                }
            };
        };
        return _curry2(function view(lens, x) {
            // Using `Const` effectively ignores the setter function of the `lens`,
            // leaving the value returned by the getter function unmodified.
            return lens(Const)(x).value;
        });
    }();

    /**
     * Tests the final argument by passing it to the given predicate function. If
     * the predicate is satisfied, the function will return the result of calling
     * the `whenTrueFn` function with the same argument. If the predicate is not
     * satisfied, the argument is returned as is.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Logic
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred       A predicate function
     * @param {Function} whenTrueFn A function to invoke when the `condition`
     *                              evaluates to a truthy value.
     * @param {*}        x          An object to test with the `pred` function and
     *                              pass to `whenTrueFn` if necessary.
     * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
     * @see R.ifElse, R.unless
     * @example
     *
     *      // truncate :: String -> String
     *      var truncate = R.when(
     *        R.propSatisfies(R.gt(R.__, 10), 'length'),
     *        R.pipe(R.take(10), R.append('…'), R.join(''))
     *      );
     *      truncate('12345');         //=> '12345'
     *      truncate('0123456789ABC'); //=> '0123456789…'
     */
    var when = _curry3(function when(pred, whenTrueFn, x) {
        return pred(x) ? whenTrueFn(x) : x;
    });

    /**
     * Takes a spec object and a test object; returns true if the test satisfies
     * the spec. Each of the spec's own properties must be a predicate function.
     * Each predicate is applied to the value of the corresponding property of the
     * test object. `where` returns true if all the predicates return true, false
     * otherwise.
     *
     * `where` is well suited to declaratively expressing constraints for other
     * functions such as `filter` and `find`.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category Object
     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
     * @param {Object} spec
     * @param {Object} testObj
     * @return {Boolean}
     * @example
     *
     *      // pred :: Object -> Boolean
     *      var pred = R.where({
     *        a: R.equals('foo'),
     *        b: R.complement(R.equals('bar')),
     *        x: R.gt(_, 10),
     *        y: R.lt(_, 20)
     *      });
     *
     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
     */
    var where = _curry2(function where(spec, testObj) {
        for (var prop in spec) {
            if (_has(prop, spec) && !spec[prop](testObj[prop])) {
                return false;
            }
        }
        return true;
    });

    /**
     * Wrap a function inside another to allow you to make adjustments to the
     * parameters, or do other processing either before the internal function is
     * called or with its results.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)
     * @param {Function} fn The function to wrap.
     * @param {Function} wrapper The wrapper function.
     * @return {Function} The wrapped function.
     * @example
     *
     *      var greet = name => 'Hello ' + name;
     *
     *      var shoutedGreet = R.wrap(greet, (gr, name) => gr(name).toUpperCase());
     *
     *      shoutedGreet("Kathy"); //=> "HELLO KATHY"
     *
     *      var shortenedGreet = R.wrap(greet, function(gr, name) {
     *        return gr(name.substring(0, 3));
     *      });
     *      shortenedGreet("Robert"); //=> "Hello Rob"
     */
    var wrap = _curry2(function wrap(fn, wrapper) {
        return curryN(fn.length, function () {
            return wrapper.apply(this, _concat([fn], arguments));
        });
    });

    /**
     * Creates a new list out of the two supplied by creating each possible pair
     * from the lists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b] -> [[a,b]]
     * @param {Array} as The first list.
     * @param {Array} bs The second list.
     * @return {Array} The list made by combining each possible pair from
     *         `as` and `bs` into pairs (`[a, b]`).
     * @example
     *
     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
     */
    // = xprodWith(prepend); (takes about 3 times as long...)
    var xprod = _curry2(function xprod(a, b) {
        // = xprodWith(prepend); (takes about 3 times as long...)
        var idx = 0;
        var ilen = a.length;
        var j;
        var jlen = b.length;
        var result = [];
        while (idx < ilen) {
            j = 0;
            while (j < jlen) {
                result[result.length] = [
                    a[idx],
                    b[j]
                ];
                j += 1;
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Creates a new list out of the two supplied by pairing up equally-positioned
     * items from both lists. The returned list is truncated to the length of the
     * shorter of the two input lists.
     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b] -> [[a,b]]
     * @param {Array} list1 The first array to consider.
     * @param {Array} list2 The second array to consider.
     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
     * @example
     *
     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
     */
    var zip = _curry2(function zip(a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
            rv[idx] = [
                a[idx],
                b[idx]
            ];
            idx += 1;
        }
        return rv;
    });

    /**
     * Creates a new object out of a list of keys and a list of values.
     * Key/value pairing is truncated to the length of the shorter of the two lists.
     * Note: `zipObj` is equivalent to `pipe(zipWith(pair), fromPairs)`.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [String] -> [*] -> {String: *}
     * @param {Array} keys The array that will be properties on the output object.
     * @param {Array} values The list of values on the output object.
     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
     * @example
     *
     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
     */
    var zipObj = _curry2(function zipObj(keys, values) {
        var idx = 0;
        var len = Math.min(keys.length, values.length);
        var out = {};
        while (idx < len) {
            out[keys[idx]] = values[idx];
            idx += 1;
        }
        return out;
    });

    /**
     * Creates a new list out of the two supplied by applying the function to each
     * equally-positioned pair in the lists. The returned list is truncated to the
     * length of the shorter of the two input lists.
     *
     * @function
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,b -> c) -> [a] -> [b] -> [c]
     * @param {Function} fn The function used to combine the two elements into one value.
     * @param {Array} list1 The first array to consider.
     * @param {Array} list2 The second array to consider.
     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
     *         using `fn`.
     * @example
     *
     *      var f = (x, y) => {
     *        // ...
     *      };
     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
     */
    var zipWith = _curry3(function zipWith(fn, a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
            rv[idx] = fn(a[idx], b[idx]);
            idx += 1;
        }
        return rv;
    });

    /**
     * A function that always returns `false`. Any passed in parameters are ignored.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig * -> Boolean
     * @param {*}
     * @return {Boolean}
     * @see R.always, R.T
     * @example
     *
     *      R.F(); //=> false
     */
    var F = always(false);

    /**
     * A function that always returns `true`. Any passed in parameters are ignored.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig * -> Boolean
     * @param {*}
     * @return {Boolean}
     * @see R.always, R.F
     * @example
     *
     *      R.T(); //=> true
     */
    var T = always(true);

    /**
     * Copies an object.
     *
     * @private
     * @param {*} value The value to be copied
     * @param {Array} refFrom Array containing the source references
     * @param {Array} refTo Array containing the copied source references
     * @param {Boolean} deep Whether or not to perform deep cloning.
     * @return {*} The copied value.
     */
    var _clone = function _clone(value, refFrom, refTo, deep) {
        var copy = function copy(copiedValue) {
            var len = refFrom.length;
            var idx = 0;
            while (idx < len) {
                if (value === refFrom[idx]) {
                    return refTo[idx];
                }
                idx += 1;
            }
            refFrom[idx + 1] = value;
            refTo[idx + 1] = copiedValue;
            for (var key in value) {
                copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
            }
            return copiedValue;
        };
        switch (type(value)) {
        case 'Object':
            return copy({});
        case 'Array':
            return copy([]);
        case 'Date':
            return new Date(value.valueOf());
        case 'RegExp':
            return _cloneRegExp(value);
        default:
            return value;
        }
    };

    var _createPartialApplicator = function _createPartialApplicator(concat) {
        return _curry2(function (fn, args) {
            return _arity(Math.max(0, fn.length - args.length), function () {
                return fn.apply(this, concat(args, arguments));
            });
        });
    };

    var _dropLast = function dropLast(n, xs) {
        return take(n < xs.length ? xs.length - n : 0, xs);
    };

    // Values of other types are only equal if identical.
    var _equals = function _equals(a, b, stackA, stackB) {
        if (identical(a, b)) {
            return true;
        }
        if (type(a) !== type(b)) {
            return false;
        }
        if (a == null || b == null) {
            return false;
        }
        if (typeof a.equals === 'function' || typeof b.equals === 'function') {
            return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
        }
        switch (type(a)) {
        case 'Arguments':
        case 'Array':
        case 'Object':
            if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
                return a === b;
            }
            break;
        case 'Boolean':
        case 'Number':
        case 'String':
            if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
                return false;
            }
            break;
        case 'Date':
            if (!identical(a.valueOf(), b.valueOf())) {
                return false;
            }
            break;
        case 'Error':
            return a.name === b.name && a.message === b.message;
        case 'RegExp':
            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
                return false;
            }
            break;
        case 'Map':
        case 'Set':
            if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
                return false;
            }
            break;
        case 'Int8Array':
        case 'Uint8Array':
        case 'Uint8ClampedArray':
        case 'Int16Array':
        case 'Uint16Array':
        case 'Int32Array':
        case 'Uint32Array':
        case 'Float32Array':
        case 'Float64Array':
            break;
        case 'ArrayBuffer':
            break;
        default:
            // Values of other types are only equal if identical.
            return false;
        }
        var keysA = keys(a);
        if (keysA.length !== keys(b).length) {
            return false;
        }
        var idx = stackA.length - 1;
        while (idx >= 0) {
            if (stackA[idx] === a) {
                return stackB[idx] === b;
            }
            idx -= 1;
        }
        stackA.push(a);
        stackB.push(b);
        idx = keysA.length - 1;
        while (idx >= 0) {
            var key = keysA[idx];
            if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
                return false;
            }
            idx -= 1;
        }
        stackA.pop();
        stackB.pop();
        return true;
    };

    /**
     * `_makeFlat` is a helper function that returns a one-level or fully recursive
     * function based on the flag passed in.
     *
     * @private
     */
    var _makeFlat = function _makeFlat(recursive) {
        return function flatt(list) {
            var value, jlen, j;
            var result = [];
            var idx = 0;
            var ilen = list.length;
            while (idx < ilen) {
                if (isArrayLike(list[idx])) {
                    value = recursive ? flatt(list[idx]) : list[idx];
                    j = 0;
                    jlen = value.length;
                    while (j < jlen) {
                        result[result.length] = value[j];
                        j += 1;
                    }
                } else {
                    result[result.length] = list[idx];
                }
                idx += 1;
            }
            return result;
        };
    };

    var _reduce = function () {
        function _arrayReduce(xf, acc, list) {
            var idx = 0;
            var len = list.length;
            while (idx < len) {
                acc = xf['@@transducer/step'](acc, list[idx]);
                if (acc && acc['@@transducer/reduced']) {
                    acc = acc['@@transducer/value'];
                    break;
                }
                idx += 1;
            }
            return xf['@@transducer/result'](acc);
        }
        function _iterableReduce(xf, acc, iter) {
            var step = iter.next();
            while (!step.done) {
                acc = xf['@@transducer/step'](acc, step.value);
                if (acc && acc['@@transducer/reduced']) {
                    acc = acc['@@transducer/value'];
                    break;
                }
                step = iter.next();
            }
            return xf['@@transducer/result'](acc);
        }
        function _methodReduce(xf, acc, obj) {
            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
        }
        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
        return function _reduce(fn, acc, list) {
            if (typeof fn === 'function') {
                fn = _xwrap(fn);
            }
            if (isArrayLike(list)) {
                return _arrayReduce(fn, acc, list);
            }
            if (typeof list.reduce === 'function') {
                return _methodReduce(fn, acc, list);
            }
            if (list[symIterator] != null) {
                return _iterableReduce(fn, acc, list[symIterator]());
            }
            if (typeof list.next === 'function') {
                return _iterableReduce(fn, acc, list);
            }
            throw new TypeError('reduce: list must be array or iterable');
        };
    }();

    var _stepCat = function () {
        var _stepCatArray = {
            '@@transducer/init': Array,
            '@@transducer/step': function (xs, x) {
                xs.push(x);
                return xs;
            },
            '@@transducer/result': _identity
        };
        var _stepCatString = {
            '@@transducer/init': String,
            '@@transducer/step': function (a, b) {
                return a + b;
            },
            '@@transducer/result': _identity
        };
        var _stepCatObject = {
            '@@transducer/init': Object,
            '@@transducer/step': function (result, input) {
                return _assign(result, isArrayLike(input) ? objOf(input[0], input[1]) : input);
            },
            '@@transducer/result': _identity
        };
        return function _stepCat(obj) {
            if (_isTransformer(obj)) {
                return obj;
            }
            if (isArrayLike(obj)) {
                return _stepCatArray;
            }
            if (typeof obj === 'string') {
                return _stepCatString;
            }
            if (typeof obj === 'object') {
                return _stepCatObject;
            }
            throw new Error('Cannot create transformer for ' + obj);
        };
    }();

    var _xdropLastWhile = function () {
        function XDropLastWhile(fn, xf) {
            this.f = fn;
            this.retained = [];
            this.xf = xf;
        }
        XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropLastWhile.prototype['@@transducer/result'] = function (result) {
            this.retained = null;
            return this.xf['@@transducer/result'](result);
        };
        XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.retain(result, input) : this.flush(result, input);
        };
        XDropLastWhile.prototype.flush = function (result, input) {
            result = _reduce(this.xf['@@transducer/step'], result, this.retained);
            this.retained = [];
            return this.xf['@@transducer/step'](result, input);
        };
        XDropLastWhile.prototype.retain = function (result, input) {
            this.retained.push(input);
            return result;
        };
        return _curry2(function _xdropLastWhile(fn, xf) {
            return new XDropLastWhile(fn, xf);
        });
    }();

    var _xgroupBy = function () {
        function XGroupBy(f, xf) {
            this.xf = xf;
            this.f = f;
            this.inputs = {};
        }
        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;
        XGroupBy.prototype['@@transducer/result'] = function (result) {
            var key;
            for (key in this.inputs) {
                if (_has(key, this.inputs)) {
                    result = this.xf['@@transducer/step'](result, this.inputs[key]);
                    if (result['@@transducer/reduced']) {
                        result = result['@@transducer/value'];
                        break;
                    }
                }
            }
            this.inputs = null;
            return this.xf['@@transducer/result'](result);
        };
        XGroupBy.prototype['@@transducer/step'] = function (result, input) {
            var key = this.f(input);
            this.inputs[key] = this.inputs[key] || [
                key,
                []
            ];
            this.inputs[key][1] = append(input, this.inputs[key][1]);
            return result;
        };
        return _curry2(function _xgroupBy(f, xf) {
            return new XGroupBy(f, xf);
        });
    }();

    /**
     * Creates a new list iteration function from an existing one by adding two new
     * parameters to its callback function: the current index, and the entire list.
     *
     * This would turn, for instance, Ramda's simple `map` function into one that
     * more closely resembles `Array.prototype.map`. Note that this will only work
     * for functions in which the iteration callback function is the first
     * parameter, and where the list is the last parameter. (This latter might be
     * unimportant if the list parameter is not used.)
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Function
     * @category List
     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
     * @param {Function} fn A list iteration function that does not pass index or list to its callback
     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
     * @example
     *
     *      var mapIndexed = R.addIndex(R.map);
     *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
     */
    var addIndex = _curry1(function addIndex(fn) {
        return curryN(fn.length, function () {
            var idx = 0;
            var origFn = arguments[0];
            var list = arguments[arguments.length - 1];
            var args = _slice(arguments);
            args[0] = function () {
                var result = origFn.apply(this, _concat(arguments, [
                    idx,
                    list
                ]));
                idx += 1;
                return result;
            };
            return fn.apply(this, args);
        });
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts
     * exactly 2 parameters. Any extraneous parameters will not be passed to the
     * supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Function
     * @sig (* -> c) -> (a, b -> c)
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity 2.
     * @example
     *
     *      var takesThreeArgs = function(a, b, c) {
     *        return [a, b, c];
     *      };
     *      takesThreeArgs.length; //=> 3
     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
     *
     *      var takesTwoArgs = R.binary(takesThreeArgs);
     *      takesTwoArgs.length; //=> 2
     *      // Only 2 arguments are passed to the wrapped function
     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
     */
    var binary = _curry1(function binary(fn) {
        return nAry(2, fn);
    });

    /**
     * Creates a deep copy of the value which may contain (nested) `Array`s and
     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are not
     * copied, but assigned by their reference.
     *
     * Dispatches to a `clone` method if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {*} -> {*}
     * @param {*} value The object or array to clone
     * @return {*} A new object or array.
     * @example
     *
     *      var objects = [{}, {}, {}];
     *      var objectsClone = R.clone(objects);
     *      objects[0] === objectsClone[0]; //=> false
     */
    var clone = _curry1(function clone(value) {
        return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], [], true);
    });

    /**
     * Returns a curried equivalent of the provided function. The curried function
     * has two unusual capabilities. First, its arguments needn't be provided one
     * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
     * following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
     * following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (* -> a) -> (* -> a)
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curryN
     * @example
     *
     *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
     *
     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
    var curry = _curry1(function curry(fn) {
        return curryN(fn.length, fn);
    });

    /**
     * Returns all but the first `n` elements of the given list, string, or
     * transducer/transformer (or object with a `drop` method).
     *
     * Dispatches to the `drop` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {*} list
     * @return {*}
     * @see R.take, R.transduce
     * @example
     *
     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
     *      R.drop(3, 'ramda');               //=> 'da'
     */
    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
        return slice(Math.max(0, n), Infinity, xs);
    }));

    /**
     * Returns a list containing all but the last `n` elements of the given `list`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n The number of elements of `xs` to skip.
     * @param {Array} xs The collection to consider.
     * @return {Array}
     * @see R.takeLast
     * @example
     *
     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
     *      R.dropLast(3, 'ramda');               //=> 'ra'
     */
    var dropLast = _curry2(_dispatchable('dropLast', _xdropLast, _dropLast));

    /**
     * Returns a new list containing all but last the`n` elements of a given list,
     * passing each value from the right to the supplied predicate function,
     * skipping elements while the predicate function returns `true`. The predicate
     * function is passed one argument: (value)*.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.takeLastWhile, R.addIndex
     * @example
     *
     *      var lteThree = x => x <= 3;
     *
     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
     */
    var dropLastWhile = _curry2(_dispatchable('dropLastWhile', _xdropLastWhile, _dropLastWhile));

    /**
     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
     * cyclical data structures.
     *
     * Dispatches symmetrically to the `equals` methods of both arguments, if
     * present.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Relation
     * @sig a -> b -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      R.equals(1, 1); //=> true
     *      R.equals(1, '1'); //=> false
     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
     *
     *      var a = {}; a.v = a;
     *      var b = {}; b.v = b;
     *      R.equals(a, b); //=> true
     */
    var equals = _curry2(function equals(a, b) {
        return _equals(a, b, [], []);
    });

    /**
     * Takes a predicate and a "filterable", and returns a new filterable of the
     * same type containing the members of the given filterable which satisfy the
     * given predicate.
     *
     * Dispatches to the `filter` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Filterable f => (a -> Boolean) -> f a -> f a
     * @param {Function} pred
     * @param {Array} filterable
     * @return {Array}
     * @see R.reject, R.transduce, R.addIndex
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *
     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
     *
     *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
     */
    // else
    var filter = _curry2(_dispatchable('filter', _xfilter, function (pred, filterable) {
        return _isObject(filterable) ? _reduce(function (acc, key) {
            if (pred(filterable[key])) {
                acc[key] = filterable[key];
            }
            return acc;
        }, {}, keys(filterable)) : // else
        _filter(pred, filterable);
    }));

    /**
     * Returns a new list by pulling every item out of it (and all its sub-arrays)
     * and putting them in a new array, depth-first.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b]
     * @param {Array} list The array to consider.
     * @return {Array} The flattened list.
     * @see R.unnest
     * @example
     *
     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
     */
    var flatten = _curry1(_makeFlat(true));

    /**
     * Returns a new function much like the supplied one, except that the first two
     * arguments' order is reversed.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
     * @param {Function} fn The function to invoke with its first two parameters reversed.
     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
     * @example
     *
     *      var mergeThree = (a, b, c) => [].concat(a, b, c);
     *
     *      mergeThree(1, 2, 3); //=> [1, 2, 3]
     *
     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
     */
    var flip = _curry1(function flip(fn) {
        return curry(function (a, b) {
            var args = _slice(arguments);
            args[0] = b;
            args[1] = a;
            return fn.apply(this, args);
        });
    });

    /**
     * Returns the first element of the given list or string. In some libraries
     * this function is named `first`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> a | Undefined
     * @sig String -> String
     * @param {Array|String} list
     * @return {*}
     * @see R.tail, R.init, R.last
     * @example
     *
     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
     *      R.head([]); //=> undefined
     *
     *      R.head('abc'); //=> 'a'
     *      R.head(''); //=> ''
     */
    var head = nth(0);

    /**
     * Returns all but the last element of the given list or string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.last, R.head, R.tail
     * @example
     *
     *      R.init([1, 2, 3]);  //=> [1, 2]
     *      R.init([1, 2]);     //=> [1]
     *      R.init([1]);        //=> []
     *      R.init([]);         //=> []
     *
     *      R.init('abc');  //=> 'ab'
     *      R.init('ab');   //=> 'a'
     *      R.init('a');    //=> ''
     *      R.init('');     //=> ''
     */
    var init = slice(0, -1);

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of those
     * elements common to both lists. Duplication is determined according to the
     * value returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
     * @param {Function} pred A predicate function that determines whether
     *        the two supplied elements are equal.
     * @param {Array} list1 One list of items to compare
     * @param {Array} list2 A second list of items to compare
     * @return {Array} A new list containing those elements common to both lists.
     * @see R.intersection
     * @example
     *
     *      var buffaloSpringfield = [
     *        {id: 824, name: 'Richie Furay'},
     *        {id: 956, name: 'Dewey Martin'},
     *        {id: 313, name: 'Bruce Palmer'},
     *        {id: 456, name: 'Stephen Stills'},
     *        {id: 177, name: 'Neil Young'}
     *      ];
     *      var csny = [
     *        {id: 204, name: 'David Crosby'},
     *        {id: 456, name: 'Stephen Stills'},
     *        {id: 539, name: 'Graham Nash'},
     *        {id: 177, name: 'Neil Young'}
     *      ];
     *
     *      R.intersectionWith(R.eqBy(R.prop('id')), buffaloSpringfield, csny);
     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
     */
    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
        var lookupList, filteredList;
        if (list1.length > list2.length) {
            lookupList = list1;
            filteredList = list2;
        } else {
            lookupList = list2;
            filteredList = list1;
        }
        var results = [];
        var idx = 0;
        while (idx < filteredList.length) {
            if (_containsWith(pred, filteredList[idx], lookupList)) {
                results[results.length] = filteredList[idx];
            }
            idx += 1;
        }
        return uniqWith(pred, results);
    });

    /**
     * Transforms the items of the list with the transducer and appends the
     * transformed items to the accumulator using an appropriate iterator function
     * based on the accumulator type.
     *
     * The accumulator can be an array, string, object or a transformer. Iterated
     * items will be appended to arrays and concatenated to strings. Objects will
     * be merged directly or 2-item arrays will be merged as key, value pairs.
     *
     * The accumulator can also be a transformer object that provides a 2-arity
     * reducing iterator function, step, 0-arity initial value function, init, and
     * 1-arity result extraction function result. The step function is used as the
     * iterator function in reduce. The result function is used to convert the
     * final accumulator into the return type and in most cases is R.identity. The
     * init function is used to provide the initial accumulator.
     *
     * The iteration is performed with R.reduce after initializing the transducer.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig a -> (b -> b) -> [c] -> a
     * @param {*} acc The initial accumulator value.
     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
     *
     *      R.into([], transducer, numbers); //=> [2, 3]
     *
     *      var intoArray = R.into([]);
     *      intoArray(transducer, numbers); //=> [2, 3]
     */
    var into = _curry3(function into(acc, xf, list) {
        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
    });

    /**
     * Same as R.invertObj, however this accounts for objects with duplicate values
     * by putting the values into an array.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {s: x} -> {x: [ s, ... ]}
     * @param {Object} obj The object or array to invert
     * @return {Object} out A new object with keys
     * in an array.
     * @example
     *
     *      var raceResultsByFirstName = {
     *        first: 'alice',
     *        second: 'jake',
     *        third: 'alice',
     *      };
     *      R.invert(raceResultsByFirstName);
     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
     */
    var invert = _curry1(function invert(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
            var key = props[idx];
            var val = obj[key];
            var list = _has(val, out) ? out[val] : out[val] = [];
            list[list.length] = key;
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new object with the keys of the given object as values, and the
     * values of the given object, which are coerced to strings, as keys. Note
     * that the last key found is preferred when handling the same value.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {s: x} -> {x: s}
     * @param {Object} obj The object or array to invert
     * @return {Object} out A new object
     * @example
     *
     *      var raceResults = {
     *        first: 'alice',
     *        second: 'jake'
     *      };
     *      R.invertObj(raceResults);
     *      //=> { 'alice': 'first', 'jake':'second' }
     *
     *      // Alternatively:
     *      var raceResults = ['alice', 'jake'];
     *      R.invertObj(raceResults);
     *      //=> { 'alice': '0', 'jake':'1' }
     */
    var invertObj = _curry1(function invertObj(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
            var key = props[idx];
            out[obj[key]] = key;
            idx += 1;
        }
        return out;
    });

    /**
     * Returns `true` if the given value is its type's empty value; `false`
     * otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig a -> Boolean
     * @param {*} x
     * @return {Boolean}
     * @see R.empty
     * @example
     *
     *      R.isEmpty([1, 2, 3]);   //=> false
     *      R.isEmpty([]);          //=> true
     *      R.isEmpty('');          //=> true
     *      R.isEmpty(null);        //=> false
     *      R.isEmpty({});          //=> true
     *      R.isEmpty({length: 0}); //=> false
     */
    var isEmpty = _curry1(function isEmpty(x) {
        return x != null && equals(x, empty(x));
    });

    /**
     * Returns the last element of the given list or string.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig [a] -> a | Undefined
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.init, R.head, R.tail
     * @example
     *
     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
     *      R.last([]); //=> undefined
     *
     *      R.last('abc'); //=> 'c'
     *      R.last(''); //=> ''
     */
    var last = nth(-1);

    /**
     * Returns the position of the last occurrence of an item in an array, or -1 if
     * the item is not included in the array. `R.equals` is used to determine
     * equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Number
     * @param {*} target The item to find.
     * @param {Array} xs The array to search in.
     * @return {Number} the index of the target, or -1 if the target is not found.
     * @see R.indexOf
     * @example
     *
     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
     */
    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
        if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
            return xs.lastIndexOf(target);
        } else {
            var idx = xs.length - 1;
            while (idx >= 0) {
                if (equals(xs[idx], target)) {
                    return idx;
                }
                idx -= 1;
            }
            return -1;
        }
    });

    /**
     * Takes a function and
     * a [functor](https://github.com/fantasyland/fantasy-land#functor),
     * applies the function to each of the functor's values, and returns
     * a functor of the same shape.
     *
     * Ramda provides suitable `map` implementations for `Array` and `Object`,
     * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
     *
     * Dispatches to the `map` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * Also treats functions as functors and will compose them together.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Functor f => (a -> b) -> f a -> f b
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {Array} list The list to be iterated over.
     * @return {Array} The new list.
     * @see R.transduce, R.addIndex
     * @example
     *
     *      var double = x => x * 2;
     *
     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
     *
     *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
     */
    var map = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {
        switch (Object.prototype.toString.call(functor)) {
        case '[object Function]':
            return curryN(functor.length, function () {
                return fn.call(this, functor.apply(this, arguments));
            });
        case '[object Object]':
            return _reduce(function (acc, key) {
                acc[key] = fn(functor[key]);
                return acc;
            }, {}, keys(functor));
        default:
            return _map(fn, functor);
        }
    }));

    /**
     * An Object-specific version of `map`. The function is applied to three
     * arguments: *(value, key, obj)*. If only the value is significant, use
     * `map` instead.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig ((*, String, Object) -> *) -> Object -> Object
     * @param {Function} fn
     * @param {Object} obj
     * @return {Object}
     * @see R.map
     * @example
     *
     *      var values = { x: 1, y: 2, z: 3 };
     *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
     *
     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
     */
    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
        return _reduce(function (acc, key) {
            acc[key] = fn(obj[key], key, obj);
            return acc;
        }, {}, keys(obj));
    });

    /**
     * Creates a new object with the own properties of the two provided objects. If
     * a key exists in both objects, the provided function is applied to the values
     * associated with the key in each object, with the result being used as the
     * value associated with the key in the returned object. The key will be
     * excluded from the returned object if the resulting value is `undefined`.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Object
     * @sig (a -> a -> a) -> {a} -> {a} -> {a}
     * @param {Function} fn
     * @param {Object} l
     * @param {Object} r
     * @return {Object}
     * @see R.merge, R.mergeWithKey
     * @example
     *
     *      R.mergeWith(R.concat,
     *                  { a: true, values: [10, 20] },
     *                  { b: true, values: [15, 35] });
     *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
     */
    var mergeWith = _curry3(function mergeWith(fn, l, r) {
        return mergeWithKey(function (_, _l, _r) {
            return fn(_l, _r);
        }, l, r);
    });

    /**
     * Takes a function `f` and a list of arguments, and returns a function `g`.
     * When applied, `g` returns the result of applying `f` to the arguments
     * provided initially followed by the arguments provided to `g`.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
     * @param {Function} f
     * @param {Array} args
     * @return {Function}
     * @see R.partialRight
     * @example
     *
     *      var multiply = (a, b) => a * b;
     *      var double = R.partial(multiply, [2]);
     *      double(2); //=> 4
     *
     *      var greet = (salutation, title, firstName, lastName) =>
     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
     *
     *      var sayHello = R.partial(greet, ['Hello']);
     *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
     */
    var partial = _createPartialApplicator(_concat);

    /**
     * Takes a function `f` and a list of arguments, and returns a function `g`.
     * When applied, `g` returns the result of applying `f` to the arguments
     * provided to `g` followed by the arguments provided initially.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
     * @param {Function} f
     * @param {Array} args
     * @return {Function}
     * @see R.partial
     * @example
     *
     *      var greet = (salutation, title, firstName, lastName) =>
     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
     *
     *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
     *
     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
     */
    var partialRight = _createPartialApplicator(flip(_concat));

    /**
     * Determines whether a nested path on an object has a specific value, in
     * `R.equals` terms. Most likely used to filter a list.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Relation
     * @sig [String] -> * -> {String: *} -> Boolean
     * @param {Array} path The path of the nested property to use
     * @param {*} val The value to compare the nested property with
     * @param {Object} obj The object to check the nested property in
     * @return {Boolean} `true` if the value equals the nested object property,
     *         `false` otherwise.
     * @example
     *
     *      var user1 = { address: { zipCode: 90210 } };
     *      var user2 = { address: { zipCode: 55555 } };
     *      var user3 = { name: 'Bob' };
     *      var users = [ user1, user2, user3 ];
     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
     *      R.filter(isFamous, users); //=> [ user1 ]
     */
    var pathEq = _curry3(function pathEq(_path, val, obj) {
        return equals(path(_path, obj), val);
    });

    /**
     * Returns a new list by plucking the same named property off all objects in
     * the list supplied.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig k -> [{k: v}] -> [v]
     * @param {Number|String} key The key name to pluck off of each object.
     * @param {Array} list The array to consider.
     * @return {Array} The list of values for the given key.
     * @see R.props
     * @example
     *
     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
     */
    var pluck = _curry2(function pluck(p, list) {
        return map(prop(p), list);
    });

    /**
     * Reasonable analog to SQL `select` statement.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @category Relation
     * @sig [k] -> [{k: v}] -> [{k: v}]
     * @param {Array} props The property names to project
     * @param {Array} objs The objects to query
     * @return {Array} An array of objects with just the `props` properties.
     * @example
     *
     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
     *      var kids = [abby, fred];
     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
     */
    // passing `identity` gives correct arity
    var project = useWith(_map, [
        pickAll,
        identity
    ]);

    /**
     * Returns `true` if the specified object property is equal, in `R.equals`
     * terms, to the given value; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig String -> a -> Object -> Boolean
     * @param {String} name
     * @param {*} val
     * @param {*} obj
     * @return {Boolean}
     * @see R.equals, R.propSatisfies
     * @example
     *
     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
     *      var kids = [abby, fred, rusty, alois];
     *      var hasBrownHair = R.propEq('hair', 'brown');
     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
     */
    var propEq = _curry3(function propEq(name, val, obj) {
        return propSatisfies(equals(val), name, obj);
    });

    /**
     * Returns `true` if the specified object property is of the given type;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Type
     * @sig Type -> String -> Object -> Boolean
     * @param {Function} type
     * @param {String} name
     * @param {*} obj
     * @return {Boolean}
     * @see R.is, R.propSatisfies
     * @example
     *
     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
     *      R.propIs(Number, 'x', {});            //=> false
     */
    var propIs = _curry3(function propIs(type, name, obj) {
        return propSatisfies(is(type), name, obj);
    });

    /**
     * Returns a single item by iterating through the list, successively calling
     * the iterator function and passing it an accumulator value and the current
     * value from the array, and then passing the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*. It may use
     * `R.reduced` to shortcut the iteration.
     *
     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.reduce` method. For more details
     * on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
     *
     * Dispatches to the `reduce` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig ((a, b) -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.reduced, R.addIndex
     * @example
     *
     *      var numbers = [1, 2, 3];
     *      var add = (a, b) => a + b;
     *
     *      R.reduce(add, 10, numbers); //=> 16
     */
    var reduce = _curry3(_reduce);

    /**
     * Groups the elements of the list according to the result of calling
     * the String-returning function `keyFn` on each element and reduces the elements
     * of each group to a single value via the reducer function `valueFn`.
     *
     * This function is basically a more general `groupBy` function.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category List
     * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
     * @param {Function} valueFn The function that reduces the elements of each group to a single
     *        value. Receives two values, accumulator for a particular group and the current element.
     * @param {*} acc The (initial) accumulator value for each group.
     * @param {Function} keyFn The function that maps the list's element into a key.
     * @param {Array} list The array to group.
     * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
     *         `valueFn` for elements which produced that key when passed to `keyFn`.
     * @see R.groupBy, R.reduce
     * @example
     *
     *      var reduceToNamesBy = R.reduceBy((acc, student) => acc.concat(student.name), []);
     *      var namesByGrade = reduceToNamesBy(function(student) {
     *        var score = student.score;
     *        return score < 65 ? 'F' :
     *               score < 70 ? 'D' :
     *               score < 80 ? 'C' :
     *               score < 90 ? 'B' : 'A';
     *      });
     *      var students = [{name: 'Lucy', score: 92},
     *                      {name: 'Drew', score: 85},
     *                      // ...
     *                      {name: 'Bart', score: 62}];
     *      namesByGrade(students);
     *      // {
     *      //   'A': ['Lucy'],
     *      //   'B': ['Drew']
     *      //   // ...,
     *      //   'F': ['Bart']
     *      // }
     */
    var reduceBy = _curryN(4, [], function reduceBy(valueFn, valueAcc, keyFn, list) {
        return _reduce(function (acc, elt) {
            var key = keyFn(elt);
            acc[key] = valueFn(_has(key, acc) ? acc[key] : valueAcc, elt);
            return acc;
        }, {}, list);
    });

    /**
     * The complement of `filter`.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Filterable f => (a -> Boolean) -> f a -> f a
     * @param {Function} pred
     * @param {Array} filterable
     * @return {Array}
     * @see R.filter, R.transduce, R.addIndex
     * @example
     *
     *      var isOdd = (n) => n % 2 === 1;
     *
     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
     *
     *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
     */
    var reject = _curry2(function reject(pred, filterable) {
        return filter(_complement(pred), filterable);
    });

    /**
     * Returns a fixed list of size `n` containing a specified identical value.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig a -> n -> [a]
     * @param {*} value The value to repeat.
     * @param {Number} n The desired size of the output list.
     * @return {Array} A new array containing `n` `value`s.
     * @example
     *
     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
     *
     *      var obj = {};
     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
     *      repeatedObjs[0] === repeatedObjs[1]; //=> true
     */
    var repeat = _curry2(function repeat(value, n) {
        return times(always(value), n);
    });

    /**
     * Adds together all the elements of a list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list An array of numbers
     * @return {Number} The sum of all the numbers in the list.
     * @see R.reduce
     * @example
     *
     *      R.sum([2,4,6,8,100,1]); //=> 121
     */
    var sum = reduce(add, 0);

    /**
     * Returns a new list containing the last `n` elements of the given list.
     * If `n > list.length`, returns a list of `list.length` elements.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n The number of elements to return.
     * @param {Array} xs The collection to consider.
     * @return {Array}
     * @see R.dropLast
     * @example
     *
     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.takeLast(3, 'ramda');               //=> 'mda'
     */
    var takeLast = _curry2(function takeLast(n, xs) {
        return drop(n >= 0 ? xs.length - n : 0, xs);
    });

    /**
     * Initializes a transducer using supplied iterator function. Returns a single
     * item by iterating through the list, successively calling the transformed
     * iterator function and passing it an accumulator value and the current value
     * from the array, and then passing the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*. It will be
     * wrapped as a transformer to initialize the transducer. A transformer can be
     * passed directly in place of an iterator function. In both cases, iteration
     * may be stopped early with the `R.reduced` function.
     *
     * A transducer is a function that accepts a transformer and returns a
     * transformer and can be composed directly.
     *
     * A transformer is an an object that provides a 2-arity reducing iterator
     * function, step, 0-arity initial value function, init, and 1-arity result
     * extraction function, result. The step function is used as the iterator
     * function in reduce. The result function is used to convert the final
     * accumulator into the return type and in most cases is R.identity. The init
     * function can be used to provide an initial accumulator, but is ignored by
     * transduce.
     *
     * The iteration is performed with R.reduce after initializing the transducer.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array. Wrapped as transformer, if necessary, and used to
     *        initialize the transducer
     * @param {*} acc The initial accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.reduce, R.reduced, R.into
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
     *
     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
     */
    var transduce = curryN(4, function transduce(xf, fn, acc, list) {
        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
    });

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of the elements
     * of each list. Duplication is determined according to the value returned by
     * applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The first and second lists concatenated, with
     *         duplicates removed.
     * @see R.union
     * @example
     *
     *      var l1 = [{a: 1}, {a: 2}];
     *      var l2 = [{a: 1}, {a: 4}];
     *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
     */
    var unionWith = _curry3(function unionWith(pred, list1, list2) {
        return uniqWith(pred, _concat(list1, list2));
    });

    /**
     * Takes a spec object and a test object; returns true if the test satisfies
     * the spec, false otherwise. An object satisfies the spec if, for each of the
     * spec's own properties, accessing that property of the object gives the same
     * value (in `R.equals` terms) as accessing that property of the spec.
     *
     * `whereEq` is a specialization of [`where`](#where).
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @sig {String: *} -> {String: *} -> Boolean
     * @param {Object} spec
     * @param {Object} testObj
     * @return {Boolean}
     * @see R.where
     * @example
     *
     *      // pred :: Object -> Boolean
     *      var pred = R.whereEq({a: 1, b: 2});
     *
     *      pred({a: 1});              //=> false
     *      pred({a: 1, b: 2});        //=> true
     *      pred({a: 1, b: 2, c: 3});  //=> true
     *      pred({a: 1, b: 1});        //=> false
     */
    var whereEq = _curry2(function whereEq(spec, testObj) {
        return where(map(equals, spec), testObj);
    });

    var _flatCat = function () {
        var preservingReduced = function (xf) {
            return {
                '@@transducer/init': _xfBase.init,
                '@@transducer/result': function (result) {
                    return xf['@@transducer/result'](result);
                },
                '@@transducer/step': function (result, input) {
                    var ret = xf['@@transducer/step'](result, input);
                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
                }
            };
        };
        return function _xcat(xf) {
            var rxf = preservingReduced(xf);
            return {
                '@@transducer/init': _xfBase.init,
                '@@transducer/result': function (result) {
                    return rxf['@@transducer/result'](result);
                },
                '@@transducer/step': function (result, input) {
                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
                }
            };
        };
    }();

    // Array.prototype.indexOf doesn't exist below IE9
    // manually crawl the list to distinguish between +0 and -0
    // NaN
    // non-zero numbers can utilise Set
    // all these types can utilise Set
    // null can utilise Set
    // anything else not covered above, defer to R.equals
    var _indexOf = function _indexOf(list, a, idx) {
        var inf, item;
        // Array.prototype.indexOf doesn't exist below IE9
        if (typeof list.indexOf === 'function') {
            switch (typeof a) {
            case 'number':
                if (a === 0) {
                    // manually crawl the list to distinguish between +0 and -0
                    inf = 1 / a;
                    while (idx < list.length) {
                        item = list[idx];
                        if (item === 0 && 1 / item === inf) {
                            return idx;
                        }
                        idx += 1;
                    }
                    return -1;
                } else if (a !== a) {
                    // NaN
                    while (idx < list.length) {
                        item = list[idx];
                        if (typeof item === 'number' && item !== item) {
                            return idx;
                        }
                        idx += 1;
                    }
                    return -1;
                }
                // non-zero numbers can utilise Set
                return list.indexOf(a, idx);
            // all these types can utilise Set
            case 'string':
            case 'boolean':
            case 'function':
            case 'undefined':
                return list.indexOf(a, idx);
            case 'object':
                if (a === null) {
                    // null can utilise Set
                    return list.indexOf(a, idx);
                }
            }
        }
        // anything else not covered above, defer to R.equals
        while (idx < list.length) {
            if (equals(list[idx], a)) {
                return idx;
            }
            idx += 1;
        }
        return -1;
    };

    var _xchain = _curry2(function _xchain(f, xf) {
        return map(f, _flatCat(xf));
    });

    /**
     * Takes a list of predicates and returns a predicate that returns true for a
     * given list of arguments if every one of the provided predicates is satisfied
     * by those arguments.
     *
     * The function returned is a curried function whose arity matches that of the
     * highest-arity predicate.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Logic
     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
     * @param {Array} preds
     * @return {Function}
     * @see R.anyPass
     * @example
     *
     *      var isQueen = R.propEq('rank', 'Q');
     *      var isSpade = R.propEq('suit', '♠︎');
     *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
     *
     *      isQueenOfSpades({rank: 'Q', suit: '♣︎'}); //=> false
     *      isQueenOfSpades({rank: 'Q', suit: '♠︎'}); //=> true
     */
    var allPass = _curry1(function allPass(preds) {
        return curryN(reduce(max, 0, pluck('length', preds)), function () {
            var idx = 0;
            var len = preds.length;
            while (idx < len) {
                if (!preds[idx].apply(this, arguments)) {
                    return false;
                }
                idx += 1;
            }
            return true;
        });
    });

    /**
     * Returns `true` if all elements are unique, in `R.equals` terms, otherwise
     * `false`.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category List
     * @sig [a] -> Boolean
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if all elements are unique, else `false`.
     * @deprecated since v0.20.0
     * @example
     *
     *      R.allUniq(['1', 1]); //=> true
     *      R.allUniq([1, 1]);   //=> false
     *      R.allUniq([[42], [42]]); //=> false
     */
    var allUniq = _curry1(function allUniq(list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            if (_indexOf(list, list[idx], idx + 1) >= 0) {
                return false;
            }
            idx += 1;
        }
        return true;
    });

    /**
     * Takes a list of predicates and returns a predicate that returns true for a
     * given list of arguments if at least one of the provided predicates is
     * satisfied by those arguments.
     *
     * The function returned is a curried function whose arity matches that of the
     * highest-arity predicate.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Logic
     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
     * @param {Array} preds
     * @return {Function}
     * @see R.allPass
     * @example
     *
     *      var gte = R.anyPass([R.gt, R.equals]);
     *
     *      gte(3, 2); //=> true
     *      gte(2, 2); //=> true
     *      gte(2, 3); //=> false
     */
    var anyPass = _curry1(function anyPass(preds) {
        return curryN(reduce(max, 0, pluck('length', preds)), function () {
            var idx = 0;
            var len = preds.length;
            while (idx < len) {
                if (preds[idx].apply(this, arguments)) {
                    return true;
                }
                idx += 1;
            }
            return false;
        });
    });

    /**
     * ap applies a list of functions to a list of values.
     *
     * Dispatches to the `ap` method of the second argument, if present. Also
     * treats functions as applicatives.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig [f] -> [a] -> [f a]
     * @param {Array} fns An array of functions
     * @param {Array} vs An array of values
     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
     * @example
     *
     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
     */
    // else
    var ap = _curry2(function ap(applicative, fn) {
        return typeof applicative.ap === 'function' ? applicative.ap(fn) : typeof applicative === 'function' ? curryN(Math.max(applicative.length, fn.length), function () {
            return applicative.apply(this, arguments)(fn.apply(this, arguments));
        }) : // else
        _reduce(function (acc, f) {
            return _concat(acc, map(f, fn));
        }, [], applicative);
    });

    /**
     * Given a spec object recursively mapping properties to functions, creates a
     * function producing an object of the same structure, by mapping each property
     * to the result of calling its associated function with the supplied arguments.
     *
     * @func
     * @memberOf R
     * @since v0.20.0
     * @category Function
     * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
     * @param {Object} spec an object recursively mapping properties to functions for
     *        producing the values for these properties.
     * @return {Function} A function that returns an object of the same structure
     * as `spec', with each property set to the value returned by calling its
     * associated function with the supplied arguments.
     * @see R.juxt
     * @example
     *
     *      var getMetrics = R.applySpec({
     *                                      sum: R.add,
     *                                      nested: { mul: R.multiply }
     *                                   });
     *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
     */
    var applySpec = _curry1(function applySpec(spec) {
        spec = map(function (v) {
            return typeof v == 'function' ? v : applySpec(v);
        }, spec);
        return curryN(reduce(max, 0, pluck('length', values(spec))), function () {
            var args = arguments;
            return map(function (f) {
                return apply(f, args);
            }, spec);
        });
    });

    /**
     * Returns the result of calling its first argument with the remaining
     * arguments. This is occasionally useful as a converging function for
     * `R.converge`: the left branch can produce a function while the right branch
     * produces a value to be passed to that function as an argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig (*... -> a),*... -> a
     * @param {Function} fn The function to apply to the remaining arguments.
     * @param {...*} args Any number of positional arguments.
     * @return {*}
     * @see R.apply
     * @example
     *
     *      var indentN = R.pipe(R.times(R.always(' ')),
     *                           R.join(''),
     *                           R.replace(/^(?!$)/gm));
     *
     *      var format = R.converge(R.call, [
     *                                  R.pipe(R.prop('indent'), indentN),
     *                                  R.prop('value')
     *                              ]);
     *
     *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
     */
    var call = curry(function call(fn) {
        return fn.apply(this, _slice(arguments, 1));
    });

    /**
     * `chain` maps a function over a list and concatenates the results. `chain`
     * is also known as `flatMap` in some libraries
     *
     * Dispatches to the `chain` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig (a -> [b]) -> [a] -> [b]
     * @param {Function} fn
     * @param {Array} list
     * @return {Array}
     * @example
     *
     *      var duplicate = n => [n, n];
     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
     */
    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, monad) {
        if (typeof monad === 'function') {
            return function () {
                return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);
            };
        }
        return _makeFlat(false)(map(fn, monad));
    }));

    /**
     * Returns a function, `fn`, which encapsulates if/else-if/else logic.
     * `R.cond` takes a list of [predicate, transform] pairs. All of the arguments
     * to `fn` are applied to each of the predicates in turn until one returns a
     * "truthy" value, at which point `fn` returns the result of applying its
     * arguments to the corresponding transformer. If none of the predicates
     * matches, `fn` returns undefined.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Logic
     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
     * @param {Array} pairs
     * @return {Function}
     * @example
     *
     *      var fn = R.cond([
     *        [R.equals(0),   R.always('water freezes at 0°C')],
     *        [R.equals(100), R.always('water boils at 100°C')],
     *        [R.T,           temp => 'nothing special happens at ' + temp + '°C']
     *      ]);
     *      fn(0); //=> 'water freezes at 0°C'
     *      fn(50); //=> 'nothing special happens at 50°C'
     *      fn(100); //=> 'water boils at 100°C'
     */
    var cond = _curry1(function cond(pairs) {
        var arity = reduce(max, 0, map(function (pair) {
            return pair[0].length;
        }, pairs));
        return _arity(arity, function () {
            var idx = 0;
            while (idx < pairs.length) {
                if (pairs[idx][0].apply(this, arguments)) {
                    return pairs[idx][1].apply(this, arguments);
                }
                idx += 1;
            }
        });
    });

    /**
     * Wraps a constructor function inside a curried function that can be called
     * with the same arguments and returns the same type. The arity of the function
     * returned is specified to allow using variadic constructor functions.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Function
     * @sig Number -> (* -> {*}) -> (* -> {*})
     * @param {Number} n The arity of the constructor function.
     * @param {Function} Fn The constructor function to wrap.
     * @return {Function} A wrapped, curried constructor function.
     * @example
     *
     *      // Variadic constructor function
     *      var Widget = () => {
     *        this.children = Array.prototype.slice.call(arguments);
     *        // ...
     *      };
     *      Widget.prototype = {
     *        // ...
     *      };
     *      var allConfigs = [
     *        // ...
     *      ];
     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets
     */
    var constructN = _curry2(function constructN(n, Fn) {
        if (n > 10) {
            throw new Error('Constructor with greater than ten arguments');
        }
        if (n === 0) {
            return function () {
                return new Fn();
            };
        }
        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
            switch (arguments.length) {
            case 1:
                return new Fn($0);
            case 2:
                return new Fn($0, $1);
            case 3:
                return new Fn($0, $1, $2);
            case 4:
                return new Fn($0, $1, $2, $3);
            case 5:
                return new Fn($0, $1, $2, $3, $4);
            case 6:
                return new Fn($0, $1, $2, $3, $4, $5);
            case 7:
                return new Fn($0, $1, $2, $3, $4, $5, $6);
            case 8:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
            case 9:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
            case 10:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
            }
        }));
    });

    /**
     * Accepts a converging function and a list of branching functions and returns
     * a new function. When invoked, this new function is applied to some
     * arguments, each branching function is applied to those same arguments. The
     * results of each branching function are passed as arguments to the converging
     * function to produce the return value.
     *
     * @func
     * @memberOf R
     * @since v0.4.2
     * @category Function
     * @sig (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)
     * @param {Function} after A function. `after` will be invoked with the return values of
     *        `fn1` and `fn2` as its arguments.
     * @param {Array} functions A list of functions.
     * @return {Function} A new function.
     * @example
     *
     *      var add = (a, b) => a + b;
     *      var multiply = (a, b) => a * b;
     *      var subtract = (a, b) => a - b;
     *
     *      //≅ multiply( add(1, 2), subtract(1, 2) );
     *      R.converge(multiply, [add, subtract])(1, 2); //=> -3
     *
     *      var add3 = (a, b, c) => a + b + c;
     *      R.converge(add3, [multiply, add, subtract])(1, 2); //=> 4
     */
    var converge = _curry2(function converge(after, fns) {
        return curryN(reduce(max, 0, pluck('length', fns)), function () {
            var args = arguments;
            var context = this;
            return after.apply(context, _map(function (fn) {
                return fn.apply(context, args);
            }, fns));
        });
    });

    /**
     * Counts the elements of a list according to how many match each value of a
     * key generated by the supplied function. Returns an object mapping the keys
     * produced by `fn` to the number of occurrences in the list. Note that all
     * keys are coerced to strings because of how JavaScript objects work.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> String) -> [a] -> {*}
     * @param {Function} fn The function used to map values to keys.
     * @param {Array} list The list to count elements from.
     * @return {Object} An object mapping keys to number of occurrences in the list.
     * @example
     *
     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
     *      var letters = R.split('', 'abcABCaaaBBc');
     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}
     */
    var countBy = reduceBy(function (acc, elem) {
        return acc + 1;
    }, 0);

    /**
     * Returns a new list without any consecutively repeating elements. Equality is
     * determined by applying the supplied predicate two consecutive elements. The
     * first element in a series of equal element is the one being preserved.
     *
     * Dispatches to the `dropRepeatsWith` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list The array to consider.
     * @return {Array} `list` without repeating elements.
     * @see R.transduce
     * @example
     *
     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
     *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
     */
    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
        var result = [];
        var idx = 1;
        var len = list.length;
        if (len !== 0) {
            result[0] = list[0];
            while (idx < len) {
                if (!pred(last(result), list[idx])) {
                    result[result.length] = list[idx];
                }
                idx += 1;
            }
        }
        return result;
    }));

    /**
     * Takes a function and two values in its domain and returns `true` if the
     * values map to the same value in the codomain; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Relation
     * @sig (a -> b) -> a -> a -> Boolean
     * @param {Function} f
     * @param {*} x
     * @param {*} y
     * @return {Boolean}
     * @example
     *
     *      R.eqBy(Math.abs, 5, -5); //=> true
     */
    var eqBy = _curry3(function eqBy(f, x, y) {
        return equals(f(x), f(y));
    });

    /**
     * Reports whether two objects have the same value, in `R.equals` terms, for
     * the specified property. Useful as a curried predicate.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig k -> {k: v} -> {k: v} -> Boolean
     * @param {String} prop The name of the property to compare
     * @param {Object} obj1
     * @param {Object} obj2
     * @return {Boolean}
     *
     * @example
     *
     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
     *      R.eqProps('a', o1, o2); //=> false
     *      R.eqProps('c', o1, o2); //=> true
     */
    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
        return equals(obj1[prop], obj2[prop]);
    });

    /**
     * Splits a list into sub-lists stored in an object, based on the result of
     * calling a String-returning function on each element, and grouping the
     * results according to values returned.
     *
     * Dispatches to the `groupBy` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> String) -> [a] -> {String: [a]}
     * @param {Function} fn Function :: a -> String
     * @param {Array} list The array to group
     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
     *         that produced that key when passed to `fn`.
     * @see R.transduce
     * @example
     *
     *      var byGrade = R.groupBy(function(student) {
     *        var score = student.score;
     *        return score < 65 ? 'F' :
     *               score < 70 ? 'D' :
     *               score < 80 ? 'C' :
     *               score < 90 ? 'B' : 'A';
     *      });
     *      var students = [{name: 'Abby', score: 84},
     *                      {name: 'Eddy', score: 58},
     *                      // ...
     *                      {name: 'Jack', score: 69}];
     *      byGrade(students);
     *      // {
     *      //   'A': [{name: 'Dianne', score: 99}],
     *      //   'B': [{name: 'Abby', score: 84}]
     *      //   // ...,
     *      //   'F': [{name: 'Eddy', score: 58}]
     *      // }
     */
    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, reduceBy(function (acc, item) {
        if (acc == null) {
            acc = [];
        }
        acc.push(item);
        return acc;
    }, null)));

    /**
     * Given a function that generates a key, turns a list of objects into an
     * object indexing the objects by the given key. Note that if multiple
     * objects generate the same value for the indexing key only the last value
     * will be included in the generated object.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
     * @param {Function} fn Function :: a -> String
     * @param {Array} array The array of objects to index
     * @return {Object} An object indexing each array element by the given property.
     * @example
     *
     *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
     *      R.indexBy(R.prop('id'), list);
     *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
     */
    var indexBy = reduceBy(function (acc, elem) {
        return elem;
    }, null);

    /**
     * Returns the position of the first occurrence of an item in an array, or -1
     * if the item is not included in the array. `R.equals` is used to determine
     * equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Number
     * @param {*} target The item to find.
     * @param {Array} xs The array to search in.
     * @return {Number} the index of the target, or -1 if the target is not found.
     * @see R.lastIndexOf
     * @example
     *
     *      R.indexOf(3, [1,2,3,4]); //=> 2
     *      R.indexOf(10, [1,2,3,4]); //=> -1
     */
    var indexOf = _curry2(function indexOf(target, xs) {
        return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
    });

    /**
     * juxt applies a list of functions to a list of values.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Function
     * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
     * @param {Array} fns An array of functions
     * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
     * @see R.applySpec
     * @example
     *
     *      var range = R.juxt([Math.min, Math.max]);
     *      range(3, 4, 9, -3); //=> [-3, 9]
     */
    var juxt = _curry1(function juxt(fns) {
        return converge(_arrayOf, fns);
    });

    /**
     * Returns a lens for the given getter and setter functions. The getter "gets"
     * the value of the focus; the setter "sets" the value of the focus. The setter
     * should not mutate the data structure.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
     * @param {Function} getter
     * @param {Function} setter
     * @return {Lens}
     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
     *
     *      R.view(xLens, {x: 1, y: 2});            //=> 1
     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
     */
    var lens = _curry2(function lens(getter, setter) {
        return function (toFunctorFn) {
            return function (target) {
                return map(function (focus) {
                    return setter(focus, target);
                }, toFunctorFn(getter(target)));
            };
        };
    });

    /**
     * Returns a lens whose focus is the specified index.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Number -> Lens s a
     * @param {Number} n
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var headLens = R.lensIndex(0);
     *
     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
     */
    var lensIndex = _curry1(function lensIndex(n) {
        return lens(nth(n), update(n));
    });

    /**
     * Returns a lens whose focus is the specified path.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig [String] -> Lens s a
     * @param {Array} path The path to use.
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var xyLens = R.lensPath(['x', 'y']);
     *
     *      R.view(xyLens, {x: {y: 2, z: 3}});            //=> 2
     *      R.set(xyLens, 4, {x: {y: 2, z: 3}});          //=> {x: {y: 4, z: 3}}
     *      R.over(xyLens, R.negate, {x: {y: 2, z: 3}});  //=> {x: {y: -2, z: 3}}
     */
    var lensPath = _curry1(function lensPath(p) {
        return lens(path(p), assocPath(p));
    });

    /**
     * Returns a lens whose focus is the specified property.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig String -> Lens s a
     * @param {String} k
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.view(xLens, {x: 1, y: 2});            //=> 1
     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
     */
    var lensProp = _curry1(function lensProp(k) {
        return lens(prop(k), assoc(k));
    });

    /**
     * "lifts" a function to be the specified arity, so that it may "map over" that
     * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Function
     * @sig Number -> (*... -> *) -> ([*]... -> [*])
     * @param {Function} fn The function to lift into higher context
     * @return {Function} The lifted function.
     * @see R.lift, R.ap
     * @example
     *
     *      var madd3 = R.liftN(3, R.curryN(3, (...args) => R.sum(args)));
     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
     */
    var liftN = _curry2(function liftN(arity, fn) {
        var lifted = curryN(arity, fn);
        return curryN(arity, function () {
            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
        });
    });

    /**
     * Returns the mean of the given list of numbers.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list
     * @return {Number}
     * @example
     *
     *      R.mean([2, 7, 9]); //=> 6
     *      R.mean([]); //=> NaN
     */
    var mean = _curry1(function mean(list) {
        return sum(list) / list.length;
    });

    /**
     * Returns the median of the given list of numbers.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list
     * @return {Number}
     * @example
     *
     *      R.median([2, 9, 7]); //=> 7
     *      R.median([7, 2, 10, 9]); //=> 8
     *      R.median([]); //=> NaN
     */
    var median = _curry1(function median(list) {
        var len = list.length;
        if (len === 0) {
            return NaN;
        }
        var width = 2 - len % 2;
        var idx = (len - width) / 2;
        return mean(_slice(list).sort(function (a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        }).slice(idx, idx + width));
    });

    /**
     * Takes a predicate and a list or other "filterable" object and returns the
     * pair of filterable objects of the same type of elements which do and do not
     * satisfy, the predicate, respectively.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
     * @param {Function} pred A predicate to determine which side the element belongs to.
     * @param {Array} filterable the list (or other filterable) to partition.
     * @return {Array} An array, containing first the subset of elements that satisfy the
     *         predicate, and second the subset of elements that do not satisfy.
     * @see R.filter, R.reject
     * @example
     *
     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
     *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
     *
     *      R.partition(R.contains('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
     *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
     */
    var partition = juxt([
        filter,
        reject
    ]);

    /**
     * Performs left-to-right function composition. The leftmost function may have
     * any arity; the remaining functions must be unary.
     *
     * In some libraries this function is named `sequence`.
     *
     * **Note:** The result of pipe is not automatically curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.compose
     * @example
     *
     *      var f = R.pipe(Math.pow, R.negate, R.inc);
     *
     *      f(3, 4); // -(3^4) + 1
     */
    var pipe = function pipe() {
        if (arguments.length === 0) {
            throw new Error('pipe requires at least one argument');
        }
        return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
    };

    /**
     * Performs left-to-right composition of one or more Promise-returning
     * functions. The leftmost function may have any arity; the remaining functions
     * must be unary.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.composeP
     * @example
     *
     *      //  followersForUser :: String -> Promise [User]
     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
     */
    var pipeP = function pipeP() {
        if (arguments.length === 0) {
            throw new Error('pipeP requires at least one argument');
        }
        return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
    };

    /**
     * Multiplies together all the elements of a list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list An array of numbers
     * @return {Number} The product of all the numbers in the list.
     * @see R.reduce
     * @example
     *
     *      R.product([2,4,6,8,100,1]); //=> 38400
     */
    var product = reduce(multiply, 1);

    /**
     * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
     * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
     * Applicative of Traversable.
     *
     * Dispatches to the `sequence` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
     * @param {Function} of
     * @param {*} traversable
     * @return {*}
     * @see R.traverse
     * @example
     *
     *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
     *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
     *
     *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
     *      R.sequence(R.of, Nothing());       //=> [Nothing()]
     */
    var sequence = _curry2(function sequence(of, traversable) {
        return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (acc, x) {
            return ap(map(prepend, x), acc);
        }, of([]), traversable);
    });

    /**
     * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
     * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
     * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
     * into an Applicative of Traversable.
     *
     * Dispatches to the `sequence` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
     * @param {Function} of
     * @param {Function} f
     * @param {*} traversable
     * @return {*}
     * @see R.sequence
     * @example
     *
     *      // Returns `Nothing` if the given divisor is `0`
     *      safeDiv = n => d => d === 0 ? Nothing() : Just(n / d)
     *
     *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Just([5, 2.5, 2])
     *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Nothing
     */
    var traverse = _curry3(function traverse(of, f, traversable) {
        return sequence(of, map(f, traversable));
    });

    /**
     * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
     * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig Chain c => c (c a) -> c a
     * @param {*} list
     * @return {*}
     * @see R.flatten, R.chain
     * @example
     *
     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
     */
    var unnest = chain(_identity);

    var _contains = function _contains(a, list) {
        return _indexOf(list, a, 0) >= 0;
    };

    //  mapPairs :: (Object, [String]) -> [String]
    var _toString = function _toString(x, seen) {
        var recur = function recur(y) {
            var xs = seen.concat([x]);
            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
        };
        //  mapPairs :: (Object, [String]) -> [String]
        var mapPairs = function (obj, keys) {
            return _map(function (k) {
                return _quote(k) + ': ' + recur(obj[k]);
            }, keys.slice().sort());
        };
        switch (Object.prototype.toString.call(x)) {
        case '[object Arguments]':
            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
        case '[object Array]':
            return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
                return /^\d+$/.test(k);
            }, keys(x)))).join(', ') + ']';
        case '[object Boolean]':
            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
        case '[object Date]':
            return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
        case '[object Null]':
            return 'null';
        case '[object Number]':
            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
        case '[object String]':
            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
        case '[object Undefined]':
            return 'undefined';
        default:
            if (typeof x.toString === 'function') {
                var repr = x.toString();
                if (repr !== '[object Object]') {
                    return repr;
                }
            }
            return '{' + mapPairs(x, keys(x)).join(', ') + '}';
        }
    };

    /**
     * Performs right-to-left function composition. The rightmost function may have
     * any arity; the remaining functions must be unary.
     *
     * **Note:** The result of compose is not automatically curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.pipe
     * @example
     *
     *      var f = R.compose(R.inc, R.negate, Math.pow);
     *
     *      f(3, 4); // -(3^4) + 1
     */
    var compose = function compose() {
        if (arguments.length === 0) {
            throw new Error('compose requires at least one argument');
        }
        return pipe.apply(this, reverse(arguments));
    };

    /**
     * Returns the right-to-left Kleisli composition of the provided functions,
     * each of which must return a value of a type supported by [`chain`](#chain).
     *
     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Function
     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)
     * @param {...Function}
     * @return {Function}
     * @see R.pipeK
     * @example
     *
     *      //  parseJson :: String -> Maybe *
     *      //  get :: String -> Object -> Maybe *
     *
     *      //  getStateCode :: Maybe String -> Maybe String
     *      var getStateCode = R.composeK(
     *        R.compose(Maybe.of, R.toUpper),
     *        get('state'),
     *        get('address'),
     *        get('user'),
     *        parseJson
     *      );
     *
     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
     *      //=> Just('NY')
     *      getStateCode(Maybe.of('[Invalid JSON]'));
     *      //=> Nothing()
     */
    var composeK = function composeK() {
        return compose.apply(this, prepend(identity, map(chain, arguments)));
    };

    /**
     * Performs right-to-left composition of one or more Promise-returning
     * functions. The rightmost function may have any arity; the remaining
     * functions must be unary.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.pipeP
     * @example
     *
     *      //  followersForUser :: String -> Promise [User]
     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);
     */
    var composeP = function composeP() {
        if (arguments.length === 0) {
            throw new Error('composeP requires at least one argument');
        }
        return pipeP.apply(this, reverse(arguments));
    };

    /**
     * Wraps a constructor function inside a curried function that can be called
     * with the same arguments and returns the same type.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (* -> {*}) -> (* -> {*})
     * @param {Function} Fn The constructor function to wrap.
     * @return {Function} A wrapped, curried constructor function.
     * @example
     *
     *      // Constructor function
     *      var Widget = config => {
     *        // ...
     *      };
     *      Widget.prototype = {
     *        // ...
     *      };
     *      var allConfigs = [
     *        // ...
     *      ];
     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets
     */
    var construct = _curry1(function construct(Fn) {
        return constructN(Fn.length, Fn);
    });

    /**
     * Returns `true` if the specified value is equal, in `R.equals` terms, to at
     * least one element of the given list; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Boolean
     * @param {Object} a The item to compare against.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
     * @see R.any
     * @example
     *
     *      R.contains(3, [1, 2, 3]); //=> true
     *      R.contains(4, [1, 2, 3]); //=> false
     *      R.contains([42], [[42]]); //=> true
     */
    var contains = _curry2(_contains);

    /**
     * Finds the set (i.e. no duplicates) of all elements in the first list not
     * contained in the second list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` that are not in `list2`.
     * @see R.differenceWith
     * @example
     *
     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
     */
    var difference = _curry2(function difference(first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        while (idx < firstLen) {
            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
                out[out.length] = first[idx];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new list without any consecutively repeating elements. `R.equals`
     * is used to determine equality.
     *
     * Dispatches to the `dropRepeats` method of the first argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} `list` without repeating elements.
     * @see R.transduce
     * @example
     *
     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
     */
    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

    /**
     * "lifts" a function of arity > 1 so that it may "map over" a list, Function or other
     * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Function
     * @sig (*... -> *) -> ([*]... -> [*])
     * @param {Function} fn The function to lift into higher context
     * @return {Function} The lifted function.
     * @see R.liftN
     * @example
     *
     *      var madd3 = R.lift(R.curry((a, b, c) => a + b + c));
     *
     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
     *
     *      var madd5 = R.lift(R.curry((a, b, c, d, e) => a + b + c + d + e));
     *
     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
     */
    var lift = _curry1(function lift(fn) {
        return liftN(fn.length, fn);
    });

    /**
     * Returns a partial copy of an object omitting the keys specified.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [String] -> {String: *} -> {String: *}
     * @param {Array} names an array of String property names to omit from the new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with properties from `names` not on it.
     * @see R.pick
     * @example
     *
     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
     */
    var omit = _curry2(function omit(names, obj) {
        var result = {};
        for (var prop in obj) {
            if (!_contains(prop, names)) {
                result[prop] = obj[prop];
            }
        }
        return result;
    });

    /**
     * Returns the left-to-right Kleisli composition of the provided functions,
     * each of which must return a value of a type supported by [`chain`](#chain).
     *
     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Function
     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)
     * @param {...Function}
     * @return {Function}
     * @see R.composeK
     * @example
     *
     *      //  parseJson :: String -> Maybe *
     *      //  get :: String -> Object -> Maybe *
     *
     *      //  getStateCode :: Maybe String -> Maybe String
     *      var getStateCode = R.pipeK(
     *        parseJson,
     *        get('user'),
     *        get('address'),
     *        get('state'),
     *        R.compose(Maybe.of, R.toUpper)
     *      );
     *
     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
     *      //=> Just('NY')
     *      getStateCode(Maybe.of('[Invalid JSON]'));
     *      //=> Nothing()
     */
    var pipeK = function pipeK() {
        return composeK.apply(this, reverse(arguments));
    };

    /**
     * Returns the string representation of the given value. `eval`'ing the output
     * should result in a value equivalent to the input value. Many of the built-in
     * `toString` methods do not satisfy this requirement.
     *
     * If the given value is an `[object Object]` with a `toString` method other
     * than `Object.prototype.toString`, this method is invoked with no arguments
     * to produce the return value. This means user-defined constructor functions
     * can provide a suitable `toString` method. For example:
     *
     *     function Point(x, y) {
     *       this.x = x;
     *       this.y = y;
     *     }
     *
     *     Point.prototype.toString = function() {
     *       return 'new Point(' + this.x + ', ' + this.y + ')';
     *     };
     *
     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category String
     * @sig * -> String
     * @param {*} val
     * @return {String}
     * @example
     *
     *      R.toString(42); //=> '42'
     *      R.toString('abc'); //=> '"abc"'
     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
     */
    var toString = _curry1(function toString(val) {
        return _toString(val, []);
    });

    /**
     * Returns a new list without values in the first argument.
     * `R.equals` is used to determine equality.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category List
     * @sig [a] -> [a] -> [a]
     * @param {Array} list1 The values to be removed from `list2`.
     * @param {Array} list2 The array to remove values from.
     * @return {Array} The new array without values in `list1`.
     * @see R.transduce
     * @example
     *
     *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
     */
    var without = _curry2(function (xs, list) {
        return reject(flip(_contains)(xs), list);
    });

    // A simple Set type that honours R.equals semantics
    /* globals Set */
    /**
       * Combines the logic for checking whether an item is a member of the set and
       * for adding a new item to the set.
       *
       * @param item       The item to check or add to the Set instance.
       * @param shouldAdd  If true, the item will be added to the set if it doesn't
       *                   already exist.
       * @param set        The set instance to check or add to.
       * @return {boolean} When shouldAdd is true, this will return true when a new
       *                   item was added otherwise false. When shouldAdd is false,
       *                   this will return true if the item already exists, otherwise
       *                   false.
       */
    // distinguish between +0 and -0
    // these types can all utilise Set
    // set._items['boolean'] holds a two element array
    // representing [ falseExists, trueExists ]
    // compare functions for reference equality
    /* falls through */
    // reduce the search size of heterogeneous sets by creating buckets
    // for each type.
    // scan through all previously applied items
    var _Set = function () {
        function _Set() {
            /* globals Set */
            this._nativeSet = typeof Set === 'function' ? new Set() : null;
            this._items = {};
        }
        _Set.prototype.add = function (item) {
            return hasOrAdd(item, true, this);
        };
        _Set.prototype.has = function (item) {
            return hasOrAdd(item, false, this);
        };
        /**
       * Combines the logic for checking whether an item is a member of the set and
       * for adding a new item to the set.
       *
       * @param item       The item to check or add to the Set instance.
       * @param shouldAdd  If true, the item will be added to the set if it doesn't
       *                   already exist.
       * @param set        The set instance to check or add to.
       * @return {boolean} When shouldAdd is true, this will return true when a new
       *                   item was added otherwise false. When shouldAdd is false,
       *                   this will return true if the item already exists, otherwise
       *                   false.
       */
        function hasOrAdd(item, shouldAdd, set) {
            var type = typeof item;
            var prevSize, newSize;
            switch (type) {
            case 'string':
            case 'number':
                // distinguish between +0 and -0
                if (item === 0 && !set._items['-0'] && 1 / item === -Infinity) {
                    if (shouldAdd) {
                        set._items['-0'] = true;
                    }
                    return shouldAdd;
                }
                // these types can all utilise Set
                if (set._nativeSet !== null) {
                    if (shouldAdd) {
                        prevSize = set._nativeSet.size;
                        set._nativeSet.add(item);
                        newSize = set._nativeSet.size;
                        return newSize > prevSize;
                    } else {
                        return set._nativeSet.has(item);
                    }
                } else {
                    if (!(type in set._items)) {
                        if (shouldAdd) {
                            set._items[type] = {};
                            set._items[type][item] = true;
                        }
                        return shouldAdd;
                    } else if (item in set._items[type]) {
                        return !shouldAdd;
                    } else {
                        if (shouldAdd) {
                            set._items[type][item] = true;
                        }
                        return shouldAdd;
                    }
                }
            case 'boolean':
                // set._items['boolean'] holds a two element array
                // representing [ falseExists, trueExists ]
                if (type in set._items) {
                    var bIdx = item ? 1 : 0;
                    if (set._items[type][bIdx]) {
                        return !shouldAdd;
                    } else {
                        if (shouldAdd) {
                            set._items[type][bIdx] = true;
                        }
                        return shouldAdd;
                    }
                } else {
                    if (shouldAdd) {
                        set._items[type] = item ? [
                            false,
                            true
                        ] : [
                            true,
                            false
                        ];
                    }
                    return shouldAdd;
                }
            case 'function':
                // compare functions for reference equality
                if (set._nativeSet !== null) {
                    if (shouldAdd) {
                        prevSize = set._nativeSet.size;
                        set._nativeSet.add(item);
                        newSize = set._nativeSet.size;
                        return newSize > prevSize;
                    } else {
                        return set._nativeSet.has(item);
                    }
                } else {
                    if (!(type in set._items)) {
                        if (shouldAdd) {
                            set._items[type] = [item];
                        }
                        return shouldAdd;
                    }
                    if (!_contains(item, set._items[type])) {
                        if (shouldAdd) {
                            set._items[type].push(item);
                        }
                        return shouldAdd;
                    }
                }
                return !shouldAdd;
            case 'undefined':
                if (set._items[type]) {
                    return !shouldAdd;
                } else {
                    if (shouldAdd) {
                        set._items[type] = true;
                    }
                    return shouldAdd;
                }
            case 'object':
                if (item === null) {
                    if (!set._items['null']) {
                        if (shouldAdd) {
                            set._items['null'] = true;
                        }
                        return shouldAdd;
                    }
                    return !shouldAdd;
                }
            /* falls through */
            default:
                // reduce the search size of heterogeneous sets by creating buckets
                // for each type.
                type = Object.prototype.toString.call(item);
                if (!(type in set._items)) {
                    if (shouldAdd) {
                        set._items[type] = [item];
                    }
                    return shouldAdd;
                }
                // scan through all previously applied items
                if (!_contains(item, set._items[type])) {
                    if (shouldAdd) {
                        set._items[type].push(item);
                    }
                    return shouldAdd;
                }
                return !shouldAdd;
            }
        }
        return _Set;
    }();

    /**
     * A function wrapping calls to the two functions in an `&&` operation,
     * returning the result of the first function if it is false-y and the result
     * of the second function otherwise. Note that this is short-circuited,
     * meaning that the second function will not be invoked if the first returns a
     * false-y value.
     *
     * In addition to functions, `R.both` also accepts any fantasy-land compatible
     * applicative functor.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
     * @param {Function} f a predicate
     * @param {Function} g another predicate
     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
     * @see R.and
     * @example
     *
     *      var gt10 = x => x > 10;
     *      var even = x => x % 2 === 0;
     *      var f = R.both(gt10, even);
     *      f(100); //=> true
     *      f(101); //=> false
     */
    var both = _curry2(function both(f, g) {
        return _isFunction(f) ? function _both() {
            return f.apply(this, arguments) && g.apply(this, arguments);
        } : lift(and)(f, g);
    });

    /**
     * Takes a function `f` and returns a function `g` such that:
     *
     *   - applying `g` to zero or more arguments will give __true__ if applying
     *     the same arguments to `f` gives a logical __false__ value; and
     *
     *   - applying `g` to zero or more arguments will give __false__ if applying
     *     the same arguments to `f` gives a logical __true__ value.
     *
     * `R.complement` will work on all other functors as well.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> *) -> (*... -> Boolean)
     * @param {Function} f
     * @return {Function}
     * @see R.not
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *      var isOdd = R.complement(isEven);
     *      isOdd(21); //=> true
     *      isOdd(42); //=> false
     */
    var complement = lift(not);

    /**
     * A function wrapping calls to the two functions in an `||` operation,
     * returning the result of the first function if it is truth-y and the result
     * of the second function otherwise. Note that this is short-circuited,
     * meaning that the second function will not be invoked if the first returns a
     * truth-y value.
     *
     * In addition to functions, `R.either` also accepts any fantasy-land compatible
     * applicative functor.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
     * @param {Function} f a predicate
     * @param {Function} g another predicate
     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
     * @see R.or
     * @example
     *
     *      var gt10 = x => x > 10;
     *      var even = x => x % 2 === 0;
     *      var f = R.either(gt10, even);
     *      f(101); //=> true
     *      f(8); //=> true
     */
    var either = _curry2(function either(f, g) {
        return _isFunction(f) ? function _either() {
            return f.apply(this, arguments) || g.apply(this, arguments);
        } : lift(or)(f, g);
    });

    /**
     * Turns a named method with a specified arity into a function that can be
     * called directly supplied with arguments and a target object.
     *
     * The returned function is curried and accepts `arity + 1` parameters where
     * the final parameter is the target object.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
     * @param {Number} arity Number of arguments the returned function should take
     *        before the target object.
     * @param {String} method Name of the method to call.
     * @return {Function} A new curried function.
     * @example
     *
     *      var sliceFrom = R.invoker(1, 'slice');
     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
     *      var sliceFrom6 = R.invoker(2, 'slice')(6);
     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
     */
    var invoker = _curry2(function invoker(arity, method) {
        return curryN(arity + 1, function () {
            var target = arguments[arity];
            if (target != null && is(Function, target[method])) {
                return target[method].apply(target, _slice(arguments, 0, arity));
            }
            throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
        });
    });

    /**
     * Returns a string made by inserting the `separator` between each element and
     * concatenating all the elements into a single string.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig String -> [a] -> String
     * @param {Number|String} separator The string used to separate the elements.
     * @param {Array} xs The elements to join into a string.
     * @return {String} str The string made by concatenating `xs` with `separator`.
     * @see R.split
     * @example
     *
     *      var spacer = R.join(' ');
     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
     */
    var join = invoker(1, 'join');

    /**
     * Creates a new function that, when invoked, caches the result of calling `fn`
     * for a given argument set and returns the result. Subsequent calls to the
     * memoized `fn` with the same argument set will not result in an additional
     * call to `fn`; instead, the cached result for that set of arguments will be
     * returned.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (*... -> a) -> (*... -> a)
     * @param {Function} fn The function to memoize.
     * @return {Function} Memoized version of `fn`.
     * @example
     *
     *      var count = 0;
     *      var factorial = R.memoize(n => {
     *        count += 1;
     *        return R.product(R.range(1, n + 1));
     *      });
     *      factorial(5); //=> 120
     *      factorial(5); //=> 120
     *      factorial(5); //=> 120
     *      count; //=> 1
     */
    var memoize = _curry1(function memoize(fn) {
        var cache = {};
        return _arity(fn.length, function () {
            var key = toString(arguments);
            if (!_has(key, cache)) {
                cache[key] = fn.apply(this, arguments);
            }
            return cache[key];
        });
    });

    /**
     * Splits a string into an array of strings based on the given
     * separator.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category String
     * @sig (String | RegExp) -> String -> [String]
     * @param {String|RegExp} sep The pattern.
     * @param {String} str The string to separate into an array.
     * @return {Array} The array of strings from `str` separated by `str`.
     * @see R.join
     * @example
     *
     *      var pathComponents = R.split('/');
     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
     *
     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
     */
    var split = invoker(1, 'split');

    /**
     * Determines whether a given string matches a given regular expression.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category String
     * @sig RegExp -> String -> Boolean
     * @param {RegExp} pattern
     * @param {String} str
     * @return {Boolean}
     * @see R.match
     * @example
     *
     *      R.test(/^x/, 'xyz'); //=> true
     *      R.test(/^y/, 'xyz'); //=> false
     */
    var test = _curry2(function test(pattern, str) {
        if (!_isRegExp(pattern)) {
            throw new TypeError('\u2018test\u2019 requires a value of type RegExp as its first argument; received ' + toString(pattern));
        }
        return _cloneRegExp(pattern).test(str);
    });

    /**
     * The lower case version of a string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to lower case.
     * @return {String} The lower case version of `str`.
     * @see R.toUpper
     * @example
     *
     *      R.toLower('XYZ'); //=> 'xyz'
     */
    var toLower = invoker(0, 'toLowerCase');

    /**
     * The upper case version of a string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to upper case.
     * @return {String} The upper case version of `str`.
     * @see R.toLower
     * @example
     *
     *      R.toUpper('abc'); //=> 'ABC'
     */
    var toUpper = invoker(0, 'toUpperCase');

    /**
     * Returns a new list containing only one copy of each element in the original
     * list, based upon the value returned by applying the supplied function to
     * each list element. Prefers the first item if the supplied function produces
     * the same value on two items. `R.equals` is used for comparison.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> b) -> [a] -> [a]
     * @param {Function} fn A function used to produce a value to use during comparisons.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
     */
    var uniqBy = _curry2(function uniqBy(fn, list) {
        var set = new _Set();
        var result = [];
        var idx = 0;
        var appliedItem, item;
        while (idx < list.length) {
            item = list[idx];
            appliedItem = fn(item);
            if (set.add(appliedItem)) {
                result.push(item);
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Returns the result of concatenating the given lists or strings.
     *
     * Dispatches to the `concat` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a] -> [a]
     * @sig String -> String -> String
     * @param {Array|String} a
     * @param {Array|String} b
     * @return {Array|String}
     *
     * @example
     *
     *      R.concat([], []); //=> []
     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     *      R.concat('ABC', 'DEF'); // 'ABCDEF'
     */
    var concat = flip(invoker(1, 'concat'));

    /**
     * Finds the set (i.e. no duplicates) of all elements contained in the first or
     * second list, but not both.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` or `list2`, but not both.
     * @see R.symmetricDifferenceWith
     * @example
     *
     *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
     *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
     */
    var symmetricDifference = _curry2(function symmetricDifference(list1, list2) {
        return concat(difference(list1, list2), difference(list2, list1));
    });

    /**
     * Finds the set (i.e. no duplicates) of all elements contained in the first or
     * second list, but not both. Duplication is determined according to the value
     * returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.19.0
     * @category Relation
     * @sig (a -> a -> Boolean) -> [a] -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` or `list2`, but not both.
     * @see R.symmetricDifference
     * @example
     *
     *      var eqA = R.eqBy(R.prop('a'));
     *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
     *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
     *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
     */
    var symmetricDifferenceWith = _curry3(function symmetricDifferenceWith(pred, list1, list2) {
        return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
    });

    /**
     * Returns a new list containing only one copy of each element in the original
     * list. `R.equals` is used to determine equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
     *      R.uniq([1, '1']);     //=> [1, '1']
     *      R.uniq([[42], [42]]); //=> [[42]]
     */
    var uniq = uniqBy(identity);

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of those
     * elements common to both lists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The list of elements found in both `list1` and `list2`.
     * @see R.intersectionWith
     * @example
     *
     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
     */
    var intersection = _curry2(function intersection(list1, list2) {
        var lookupList, filteredList;
        if (list1.length > list2.length) {
            lookupList = list1;
            filteredList = list2;
        } else {
            lookupList = list2;
            filteredList = list1;
        }
        return uniq(_filter(flip(_contains)(lookupList), filteredList));
    });

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of the elements
     * of each list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [*] -> [*] -> [*]
     * @param {Array} as The first list.
     * @param {Array} bs The second list.
     * @return {Array} The first and second lists concatenated, with
     *         duplicates removed.
     * @example
     *
     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
     */
    var union = _curry2(compose(uniq, _concat));

    var R = {
        F: F,
        T: T,
        __: __,
        add: add,
        addIndex: addIndex,
        adjust: adjust,
        all: all,
        allPass: allPass,
        allUniq: allUniq,
        always: always,
        and: and,
        any: any,
        anyPass: anyPass,
        ap: ap,
        aperture: aperture,
        append: append,
        apply: apply,
        applySpec: applySpec,
        assoc: assoc,
        assocPath: assocPath,
        binary: binary,
        bind: bind,
        both: both,
        call: call,
        chain: chain,
        clamp: clamp,
        clone: clone,
        comparator: comparator,
        complement: complement,
        compose: compose,
        composeK: composeK,
        composeP: composeP,
        concat: concat,
        cond: cond,
        construct: construct,
        constructN: constructN,
        contains: contains,
        converge: converge,
        countBy: countBy,
        curry: curry,
        curryN: curryN,
        dec: dec,
        defaultTo: defaultTo,
        difference: difference,
        differenceWith: differenceWith,
        dissoc: dissoc,
        dissocPath: dissocPath,
        divide: divide,
        drop: drop,
        dropLast: dropLast,
        dropLastWhile: dropLastWhile,
        dropRepeats: dropRepeats,
        dropRepeatsWith: dropRepeatsWith,
        dropWhile: dropWhile,
        either: either,
        empty: empty,
        eqBy: eqBy,
        eqProps: eqProps,
        equals: equals,
        evolve: evolve,
        filter: filter,
        find: find,
        findIndex: findIndex,
        findLast: findLast,
        findLastIndex: findLastIndex,
        flatten: flatten,
        flip: flip,
        forEach: forEach,
        fromPairs: fromPairs,
        groupBy: groupBy,
        groupWith: groupWith,
        gt: gt,
        gte: gte,
        has: has,
        hasIn: hasIn,
        head: head,
        identical: identical,
        identity: identity,
        ifElse: ifElse,
        inc: inc,
        indexBy: indexBy,
        indexOf: indexOf,
        init: init,
        insert: insert,
        insertAll: insertAll,
        intersection: intersection,
        intersectionWith: intersectionWith,
        intersperse: intersperse,
        into: into,
        invert: invert,
        invertObj: invertObj,
        invoker: invoker,
        is: is,
        isArrayLike: isArrayLike,
        isEmpty: isEmpty,
        isNil: isNil,
        join: join,
        juxt: juxt,
        keys: keys,
        keysIn: keysIn,
        last: last,
        lastIndexOf: lastIndexOf,
        length: length,
        lens: lens,
        lensIndex: lensIndex,
        lensPath: lensPath,
        lensProp: lensProp,
        lift: lift,
        liftN: liftN,
        lt: lt,
        lte: lte,
        map: map,
        mapAccum: mapAccum,
        mapAccumRight: mapAccumRight,
        mapObjIndexed: mapObjIndexed,
        match: match,
        mathMod: mathMod,
        max: max,
        maxBy: maxBy,
        mean: mean,
        median: median,
        memoize: memoize,
        merge: merge,
        mergeAll: mergeAll,
        mergeWith: mergeWith,
        mergeWithKey: mergeWithKey,
        min: min,
        minBy: minBy,
        modulo: modulo,
        multiply: multiply,
        nAry: nAry,
        negate: negate,
        none: none,
        not: not,
        nth: nth,
        nthArg: nthArg,
        objOf: objOf,
        of: of,
        omit: omit,
        once: once,
        or: or,
        over: over,
        pair: pair,
        partial: partial,
        partialRight: partialRight,
        partition: partition,
        path: path,
        pathEq: pathEq,
        pathOr: pathOr,
        pathSatisfies: pathSatisfies,
        pick: pick,
        pickAll: pickAll,
        pickBy: pickBy,
        pipe: pipe,
        pipeK: pipeK,
        pipeP: pipeP,
        pluck: pluck,
        prepend: prepend,
        product: product,
        project: project,
        prop: prop,
        propEq: propEq,
        propIs: propIs,
        propOr: propOr,
        propSatisfies: propSatisfies,
        props: props,
        range: range,
        reduce: reduce,
        reduceBy: reduceBy,
        reduceRight: reduceRight,
        reduced: reduced,
        reject: reject,
        remove: remove,
        repeat: repeat,
        replace: replace,
        reverse: reverse,
        scan: scan,
        sequence: sequence,
        set: set,
        slice: slice,
        sort: sort,
        sortBy: sortBy,
        split: split,
        splitAt: splitAt,
        splitEvery: splitEvery,
        splitWhen: splitWhen,
        subtract: subtract,
        sum: sum,
        symmetricDifference: symmetricDifference,
        symmetricDifferenceWith: symmetricDifferenceWith,
        tail: tail,
        take: take,
        takeLast: takeLast,
        takeLastWhile: takeLastWhile,
        takeWhile: takeWhile,
        tap: tap,
        test: test,
        times: times,
        toLower: toLower,
        toPairs: toPairs,
        toPairsIn: toPairsIn,
        toString: toString,
        toUpper: toUpper,
        transduce: transduce,
        transpose: transpose,
        traverse: traverse,
        trim: trim,
        tryCatch: tryCatch,
        type: type,
        unapply: unapply,
        unary: unary,
        uncurryN: uncurryN,
        unfold: unfold,
        union: union,
        unionWith: unionWith,
        uniq: uniq,
        uniqBy: uniqBy,
        uniqWith: uniqWith,
        unless: unless,
        unnest: unnest,
        until: until,
        update: update,
        useWith: useWith,
        values: values,
        valuesIn: valuesIn,
        view: view,
        when: when,
        where: where,
        whereEq: whereEq,
        without: without,
        wrap: wrap,
        xprod: xprod,
        zip: zip,
        zipObj: zipObj,
        zipWith: zipWith
    };
  /* eslint-env amd */

  /* TEST_ENTRY_POINT */

  if (typeof exports === 'object') {
    module.exports = R;
  } else if (typeof define === 'function' && define.amd) {
    define(function() { return R; });
  } else {
    this.R = R;
  }

}.call(this));

},{}]},{},[19])

//# sourceMappingURL=dalliance-all.js.map
